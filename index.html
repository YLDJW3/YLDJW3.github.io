<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.11.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Talk is cheap, show me the code.">
<meta property="og:type" content="website">
<meta property="og:title" content="元朗食品">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="元朗食品">
<meta property="og:description" content="Talk is cheap, show me the code.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Young">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>元朗食品</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">元朗食品</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Young"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Young</p>
  <div class="site-description" itemprop="description">Talk is cheap, show me the code.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">117</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


<!-- require APlayer -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">

<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
<!-- require MetingJS-->

<script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script> 
<!--playlist外链地址-->   
<meting-js
  server="tencent"
  type="playlist" 
  id="8356942170"
  mini="false"
  fixed="false"
  list-folded="true"
  autoplay="false"
  volume="0.4"
  theme="#FADFA3"
  order="list"
  loop="all"
  preload="auto"
  lrc-type="1"
  mutex="true">
</meting-js>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/08/B+tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Young">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="元朗食品">
      <meta itemprop="description" content="Talk is cheap, show me the code.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 元朗食品">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/08/B+tree/" class="post-title-link" itemprop="url">B+tree</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-04-08 20:27:12 / 修改时间：22:10:44" itemprop="dateCreated datePublished" datetime="2022-04-08T20:27:12+08:00">2022-04-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Database-System/" itemprop="url" rel="index"><span itemprop="name">Database System</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>数据库索引数据结构——B+树总结</strong></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/04/08/B+tree/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/05/C++-%E5%AE%9E%E7%8E%B0Vector/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Young">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="元朗食品">
      <meta itemprop="description" content="Talk is cheap, show me the code.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 元朗食品">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/05/C++-%E5%AE%9E%E7%8E%B0Vector/" class="post-title-link" itemprop="url">C++ 实现Vector</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-05 23:10:19" itemprop="dateCreated datePublished" datetime="2022-04-05T23:10:19+08:00">2022-04-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-08 20:08:32" itemprop="dateModified" datetime="2022-04-08T20:08:32+08:00">2022-04-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="vector">Vector</h1>
<h2 id="数据成员">数据成员</h2>
<ul>
<li>容量：capacity，表示当前数组的大小</li>
<li>大小：sz，表示当前Vector存放的元素个数</li>
<li>存放数据的数组arr</li>
</ul>
<h2 id="接口">接口</h2>
<h3 id="构造函数">构造函数</h3>
<ul>
<li>默认构造函数</li>
<li>接受元素数量参数的构造函数</li>
<li>接受元素数量参数和元素初始值的构造函数</li>
<li>接受初始值列表的构造函数</li>
<li>拷贝构造函数</li>
<li>移动构造函数</li>
</ul>
<h3 id="赋值运算符">赋值运算符</h3>
<ul>
<li>拷贝赋值运算符</li>
<li>移动赋值运算符</li>
</ul>
<h3 id="增加元素">增加元素</h3>
<ul>
<li>insert</li>
<li>push_back</li>
</ul>
<h3 id="删除元素">删除元素</h3>
<ul>
<li>pop_back</li>
<li>erase</li>
</ul>
<h3 id="获取信息">获取信息</h3>
<ul>
<li>size</li>
<li>empty</li>
<li>getCapacity</li>
</ul>
<h3 id="访问元素">访问元素</h3>
<ul>
<li>重载[]运算符</li>
</ul>
<h3 id="扩容">扩容</h3>
<ul>
<li>reserve，用户请求容量</li>
<li>grow，当溢出时将容量扩大为之前的两倍（使得添加元素的均摊复杂度为O(1)）</li>
</ul>
<h2 id="实现">实现</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 默认构造函数</span></span><br><span class="line">	<span class="built_in">Vector</span>(): <span class="built_in">arr</span>(<span class="literal">nullptr</span>), <span class="built_in">capacity</span>(<span class="number">1</span>), <span class="built_in">sz</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 接受元素数量的构造函数</span></span><br><span class="line">	<span class="built_in">Vector</span>(<span class="keyword">int</span> cnt): <span class="built_in">arr</span>(<span class="keyword">new</span> T[std::<span class="built_in">max</span>(<span class="number">1</span>, cnt * <span class="number">2</span>)]), <span class="built_in">capacity</span>(std::<span class="built_in">max</span>(<span class="number">1</span>, cnt * <span class="number">2</span>)), <span class="built_in">sz</span>(cnt) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 接受元素数量和元素值的构造函数</span></span><br><span class="line">	<span class="built_in">Vector</span>(<span class="keyword">int</span> cnt, T val): <span class="built_in">arr</span>(<span class="keyword">new</span> T[std::<span class="built_in">max</span>(<span class="number">1</span>, cnt * <span class="number">2</span>)]), <span class="built_in">capacity</span>(std::<span class="built_in">max</span>(<span class="number">1</span>, cnt * <span class="number">2</span>)), <span class="built_in">sz</span>(cnt) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i) &#123;</span><br><span class="line">			arr[i] = val;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 接受初始值列表的构造函数</span></span><br><span class="line">	<span class="built_in">Vector</span>(std::initializer_list&lt;T&gt; li): <span class="built_in">arr</span>(<span class="keyword">new</span> T[std::<span class="built_in">max</span>(<span class="number">1</span>, (<span class="keyword">int</span>)li.<span class="built_in">size</span>() * <span class="number">2</span>)]), <span class="built_in">capacity</span>(std::<span class="built_in">max</span>(<span class="number">1</span>, (<span class="keyword">int</span>)li.<span class="built_in">size</span>() * <span class="number">2</span>)), <span class="built_in">sz</span>(li.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v: li) &#123;</span><br><span class="line">			arr[i] = v;</span><br><span class="line">			++i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拷贝构造函数</span></span><br><span class="line">	<span class="built_in">Vector</span>(<span class="keyword">const</span> Vector&amp; other) &#123;</span><br><span class="line">		arr = <span class="keyword">new</span> T[other.capacity];</span><br><span class="line">		capacity = other.capacity;</span><br><span class="line">		sz = other.sz;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)</span><br><span class="line">			arr[i] = other.arr[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 移动构造函数</span></span><br><span class="line">	<span class="built_in">Vector</span>(Vector&amp;&amp; other) &#123;</span><br><span class="line">		arr = other.arr;</span><br><span class="line">		capacity = other.capacity;</span><br><span class="line">		sz = other.sz;</span><br><span class="line">		other.arr = <span class="literal">nullptr</span>;</span><br><span class="line">		other.capacity = <span class="number">0</span>;</span><br><span class="line">		other.sz = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">	Vector&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Vector&amp; other) &#123;</span><br><span class="line">		arr = <span class="keyword">new</span> T[other.capacity];</span><br><span class="line">		capacity = other.capacity;</span><br><span class="line">		sz = other.sz;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)</span><br><span class="line">			arr[i] = other.arr[i];</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 移动赋值运算符</span></span><br><span class="line">	Vector&amp; <span class="keyword">operator</span>=(Vector&amp;&amp; other) &#123;</span><br><span class="line">		arr = other.arr;</span><br><span class="line">		capacity = other.capacity;</span><br><span class="line">		sz = other.sz;</span><br><span class="line">		other.arr = <span class="literal">nullptr</span>;</span><br><span class="line">		other.capacity = <span class="number">0</span>;</span><br><span class="line">		other.sz = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 析构函数</span></span><br><span class="line">	~<span class="built_in">Vector</span>() &#123;</span><br><span class="line">		<span class="keyword">delete</span>[] arr;</span><br><span class="line">		arr = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 插入</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, T val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (sz == capacity)</span><br><span class="line">			<span class="built_in">grow</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = sz; i &gt; pos; --i)</span><br><span class="line">			arr[i] = arr[i - <span class="number">1</span>];</span><br><span class="line">		arr[pos] = val;</span><br><span class="line">		++sz;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除第一个等于val的元素</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[i] == val) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; sz - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">					arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				&#125;</span><br><span class="line">				--sz;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 末尾添加/删除</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (sz == capacity)</span><br><span class="line">			<span class="built_in">grow</span>();</span><br><span class="line">		arr[sz] = val;</span><br><span class="line">		++sz;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			--sz;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回元素数量</span></span><br><span class="line">	<span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sz;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回是否空的vector</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sz == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 随机访问</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) &#123;</span><br><span class="line">		<span class="keyword">if</span> (index &gt;= sz || index &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="string">&quot;Out of range&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> arr[index];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 扩容reserve</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">reserve</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (cap &lt;= capacity)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		T* newArrary = <span class="keyword">new</span> T[cap];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)</span><br><span class="line">			newArrary[i] = arr[i];</span><br><span class="line">		<span class="keyword">delete</span> arr;</span><br><span class="line">		arr = newArrary;</span><br><span class="line">		capacity = cap;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 测试接口, 获取当前容量</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> capacity;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 测试接口, 获取当前数组</span></span><br><span class="line">	<span class="function">T* <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> arr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T* arr;</span><br><span class="line">	<span class="keyword">int</span> capacity;</span><br><span class="line">	<span class="keyword">int</span> sz;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 溢出, 分配当前两倍的空间</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">grow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		T* newArrary = <span class="keyword">new</span> T[capacity * <span class="number">2</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)</span><br><span class="line">			newArrary[i] = arr[i];</span><br><span class="line">		<span class="keyword">delete</span> arr;</span><br><span class="line">		arr = newArrary;</span><br><span class="line">		capacity *= <span class="number">2</span>;</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BasicTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">10</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)vec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		std::cout &lt;&lt; vec[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		<span class="built_in">assert</span>(vec[i] == <span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	vec.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	<span class="built_in">assert</span>(vec.<span class="built_in">size</span>() == <span class="number">11</span>);</span><br><span class="line">	<span class="built_in">assert</span>(vec[<span class="number">10</span>] == <span class="number">4</span>);</span><br><span class="line">	vec.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="built_in">assert</span>(vec.<span class="built_in">size</span>() == <span class="number">10</span>);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;BasicTest passed\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CopyTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Vector&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">	Vector&lt;<span class="keyword">int</span>&gt; v2 = v1;</span><br><span class="line">	<span class="function">Vector&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(v2)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)v2.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="built_in">assert</span>(v2[i] == <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)v3.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="built_in">assert</span>(v3[i] == <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;CopyTest passed\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">	vec.<span class="built_in">insert</span>(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">assert</span>(vec.<span class="built_in">size</span>() == <span class="number">11</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)vec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="built_in">assert</span>(vec[i] == (i == <span class="number">0</span>? <span class="number">3</span>: <span class="number">1</span>));</span><br><span class="line">		std::cout &lt;&lt; vec[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;InsertTest passed\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EraseTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Vector&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">	vec.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">assert</span>(vec.<span class="built_in">size</span>() == <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)vec.<span class="built_in">size</span>(); ++i)</span><br><span class="line">		std::cout &lt;&lt; vec[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;EraseTest passed\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReserveTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Vector&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">	<span class="built_in">assert</span>(vec.<span class="built_in">getCapacity</span>() == <span class="number">10</span>);</span><br><span class="line">	vec.<span class="built_in">reserve</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="built_in">assert</span>(vec.<span class="built_in">getCapacity</span>() == <span class="number">10</span>);</span><br><span class="line">	vec.<span class="built_in">reserve</span>(<span class="number">11</span>);</span><br><span class="line">	<span class="built_in">assert</span>(vec.<span class="built_in">getCapacity</span>() == <span class="number">11</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)vec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="built_in">assert</span>(vec[i] == i);</span><br><span class="line">		std::cout &lt;&lt; vec[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;ReserveTest passed\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GrowTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Vector&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">assert</span>(v.<span class="built_in">getCapacity</span>() == <span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">assert</span>(v.<span class="built_in">getCapacity</span>() == <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">assert</span>(v.<span class="built_in">size</span>() == <span class="number">3</span>);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;GrowTest passed\n&quot;</span>;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MoveTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Vector&lt;<span class="keyword">int</span>&gt; v1&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">	<span class="function">Vector&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(std::move(v1))</span></span>;</span><br><span class="line">	<span class="built_in">assert</span>(v1.<span class="built_in">size</span>() == <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">assert</span>(v1.<span class="built_in">getData</span>() == <span class="literal">nullptr</span>);</span><br><span class="line">	<span class="built_in">assert</span>(v2.<span class="built_in">size</span>() == <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)v2.<span class="built_in">size</span>(); ++i)</span><br><span class="line">		<span class="built_in">assert</span>(v2[i] == i);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;MoveTest passed\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">BasicTest</span>();</span><br><span class="line">	<span class="built_in">CopyTest</span>();</span><br><span class="line">	<span class="built_in">InsertTest</span>();</span><br><span class="line">	<span class="built_in">EraseTest</span>();</span><br><span class="line">	<span class="built_in">ReserveTest</span>();</span><br><span class="line">	<span class="built_in">GrowTest</span>();</span><br><span class="line">	<span class="built_in">MoveTest</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/05/C++-%E5%AE%9E%E7%8E%B0%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Young">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="元朗食品">
      <meta itemprop="description" content="Talk is cheap, show me the code.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 元朗食品">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/05/C++-%E5%AE%9E%E7%8E%B0%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">C++-实现智能指针</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-05 20:49:44" itemprop="dateCreated datePublished" datetime="2022-04-05T20:49:44+08:00">2022-04-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-08 20:08:32" itemprop="dateModified" datetime="2022-04-08T20:08:32+08:00">2022-04-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="智能指针原理">智能指针原理</h1>
<h2 id="shared_ptr">shared_ptr</h2>
<h3 id="引用计数">引用计数</h3>
<ul>
<li>shared_ptr包含两个指针，一个指向所共享的对象，另一个指向引用计数器，此外还保存着指向删除器的指针</li>
<li>当对shared_ptr进行拷贝时，引用计数加1，当shared_ptr被销毁时，引用计数减1。特别地，如果某个shared_ptr在销毁时引用计数为0，则需要对所共享的对象进行销毁并释放相应的内存</li>
</ul>
<h3 id="线程安全性">线程安全性</h3>
<ul>
<li>基于上述原理，对shared_ptr的操作包含对其指向对象的指针，以及指向引用计数的指针的修改，操作不具有原子性，因此多线程修改shared_ptr时可能出现race
condition，不具有线程安全性</li>
</ul>
<h2 id="unique_ptr">unique_ptr</h2>
<ul>
<li>包含指向所拥有对象的指针，不支持拷贝操作，支持移动操作</li>
<li>包含销毁所指对象的删除器</li>
<li>若自定义删除器，则删除器类型也是unique_ptr的模板类型</li>
</ul>
<h1 id="shared_ptr的实现">shared_ptr的实现</h1>
<h2 id="成员变量">成员变量</h2>
<ul>
<li>T* pointer，指向所共享的对象</li>
<li>D* deleter，指向删除器，即销毁所指对象时调用的函数</li>
<li>Counter* ctr，指向引用计数器</li>
</ul>
<h2 id="接口实现">接口实现</h2>
<ul>
<li>构造函数：接受指针的构造函数、拷贝构造函数、移动构造函数</li>
<li>赋值运算符：拷贝赋值运算符、移动赋值运算符</li>
<li>析构函数：引用计数减1，若为0则调用删除器销毁所指对象</li>
<li>重载bool运算符</li>
<li>重载解引用运算符</li>
<li>重载箭头运算符</li>
<li>get()获取裸指针</li>
<li>reset()，reset(ptr)，reset(ptr, del)，放弃对对象的引用</li>
<li>unique()，返回是否唯一引用对象的智能指针</li>
<li>use_count()，返回引用该对象的智能指针数目</li>
<li>swap(shared_ptr&amp; rhs)，与另一个智能指针交换所指对象</li>
</ul>
<h1 id="unique_ptr的实现">unique_ptr的实现</h1>
<h2 id="成员变量-1">成员变量</h2>
<ul>
<li>T* pointer，指向所共享的对象</li>
<li>D
deleter，删除器，即销毁所指对象时调用的函数，默认采用delete删除</li>
</ul>
<h2 id="接口实现-1">接口实现</h2>
<ul>
<li>构造函数：接受指针的构造函数、移动构造函数</li>
<li>赋值运算符：移动赋值运算符</li>
<li>析构函数：采用删除器销毁对象</li>
<li>拷贝构造函数合拷贝赋值运算符定义为delete，表示不支持拷贝操作</li>
<li>重载bool运算符</li>
<li>重载解引用运算符</li>
<li>重载箭头运算符</li>
<li>get()获取裸指针</li>
<li>reset()，reset(ptr)</li>
<li>release()放弃对指针的控制权，返回指针并置空</li>
</ul>
<h1 id="总结">总结</h1>
<ul>
<li><strong>构造函数、赋值运算符</strong>的使用</li>
<li><strong>重载bool、解引用和箭头运算符</strong>的使用</li>
<li><strong>模板类</strong>的使用</li>
<li>shared_ptr和unique_ptr的不同实现原理</li>
<li>shared_ptr和unique_ptr对<strong>删除器的管理方式</strong>：shared_ptr内部包含指向删除器的指针，删除器可以改变，不影响shared_ptr的类型；unique_ptr内部存放了删除器本身，删除器类型不可改变，删除器类型也作为unique_ptr类型的一部分</li>
</ul>
<h1 id="代码">代码</h1>
<h2 id="shared_ptr-1">shared_ptr</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedPointer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(SharedPointer&lt;T&gt;&amp; lhs, SharedPointer&lt;T&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">	std::<span class="built_in">swap</span>(lhs.pointer, rhs.pointer);</span><br><span class="line">	std::<span class="built_in">swap</span>(lhs.ctr, rhs.ctr);</span><br><span class="line">	std::<span class="built_in">swap</span>(lhs.deleter, rhs.deleter);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(T* ptr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Counter</span>(<span class="keyword">int</span> cnt = <span class="number">1</span>): <span class="built_in">counter</span>(cnt) &#123;&#125;</span><br><span class="line">	<span class="keyword">int</span> counter;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedPointer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 默认构造函数</span></span><br><span class="line">	<span class="built_in">SharedPointer</span>(T* ptr = <span class="literal">nullptr</span>, std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(T*)&gt; del = A::Delete&lt;T&gt;): <span class="built_in">pointer</span>(ptr), <span class="built_in">ctr</span>(<span class="keyword">new</span> <span class="built_in">Counter</span>(<span class="number">1</span>)), <span class="built_in">deleter</span>(del) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拷贝构造函数</span></span><br><span class="line">	<span class="built_in">SharedPointer</span>(<span class="keyword">const</span> SharedPointer&amp; other): <span class="built_in">pointer</span>(other.pointer), <span class="built_in">ctr</span>(other.ctr), <span class="built_in">deleter</span>(other.deleter) &#123;</span><br><span class="line">		++ctr-&gt;counter;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 移动构造函数</span></span><br><span class="line">	<span class="built_in">SharedPointer</span>(SharedPointer&amp;&amp; other): <span class="built_in">pointer</span>(other.pointer), <span class="built_in">ctr</span>(other.ctr), <span class="built_in">deleter</span>(other.deleter) &#123;</span><br><span class="line">		other.pointer = <span class="literal">nullptr</span>;</span><br><span class="line">		other.ctr = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">	SharedPointer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SharedPointer&amp; other) &#123;</span><br><span class="line">		<span class="built_in">decrementAndDestory</span>();</span><br><span class="line">		pointer = other.pointer;</span><br><span class="line">		ctr = other.ctr;</span><br><span class="line">		deleter = other.deleter;</span><br><span class="line">		++ctr-&gt;counter;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 移动赋值运算符</span></span><br><span class="line">	SharedPointer&amp; <span class="keyword">operator</span>=(SharedPointer&amp;&amp; other) &#123;</span><br><span class="line">		<span class="built_in">decrementAndDestory</span>();</span><br><span class="line">		<span class="built_in">swap</span>(other);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">SharedPointer</span>() &#123;</span><br><span class="line">		<span class="built_in">decrementAndDestory</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将SharedPtr对象作为bool值</span></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> pointer? <span class="literal">true</span>: <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重载解引用运算符</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line">		<span class="keyword">if</span> (!pointer)</span><br><span class="line">			<span class="keyword">throw</span> <span class="string">&quot;Bad operator*&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> *pointer;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重载箭头运算符</span></span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;<span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">T* <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> pointer;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">decrementAndDestory</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(T* ptr)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">decrementAndDestory</span>();</span><br><span class="line">		pointer = ptr;</span><br><span class="line">		ctr = <span class="keyword">new</span> <span class="built_in">Counter</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(T* ptr, <span class="keyword">const</span> std::function&lt;<span class="keyword">void</span>(T*)&gt; del)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">reset</span>(ptr);</span><br><span class="line">		deleter = del;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">unique</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ctr-&gt;counter == <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">use_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ctr-&gt;counter;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(SharedPointer&amp; rhs)</span> </span>&#123;</span><br><span class="line">		A::<span class="built_in">swap</span>(*<span class="keyword">this</span>, rhs);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T* pointer;</span><br><span class="line">	Counter* ctr;</span><br><span class="line">	std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(T*)&gt; deleter;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 递减计数器, 若计数器为0则销毁所指对象, 重置指针值为nullptr</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">decrementAndDestory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (pointer) &#123;</span><br><span class="line">			--ctr-&gt;counter;</span><br><span class="line">			<span class="keyword">if</span> (ctr-&gt;counter == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">deleter</span>(pointer);</span><br><span class="line">				<span class="keyword">delete</span> ctr;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">delete</span> ctr;</span><br><span class="line">		&#125;</span><br><span class="line">		pointer = <span class="literal">nullptr</span>;</span><br><span class="line">		ctr = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copySharedPointerTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">2022</span>;</span><br><span class="line">	<span class="function">SharedPointer&lt;<span class="keyword">int</span>&gt; <span class="title">sp1</span><span class="params">(&amp;i)</span></span>;</span><br><span class="line">	<span class="function">SharedPointer&lt;<span class="keyword">int</span>&gt; <span class="title">sp2</span><span class="params">(sp1)</span></span>;</span><br><span class="line">	<span class="built_in">assert</span>(*sp1 == <span class="number">2022</span>);</span><br><span class="line">	<span class="built_in">assert</span>(*sp2 == <span class="number">2022</span>);</span><br><span class="line">	<span class="built_in">assert</span>(sp1.<span class="built_in">use_count</span>() == <span class="number">2</span>);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;copyTest passed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveSharedPointerTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">2022</span>;</span><br><span class="line">	<span class="function">SharedPointer&lt;<span class="keyword">int</span>&gt; <span class="title">sp1</span><span class="params">(&amp;i)</span></span>;</span><br><span class="line">	<span class="function">SharedPointer&lt;<span class="keyword">int</span>&gt; <span class="title">sp2</span><span class="params">(std::move(sp1))</span></span>;</span><br><span class="line">	<span class="built_in">assert</span>(sp1.<span class="built_in">get</span>() == <span class="literal">nullptr</span>);</span><br><span class="line">	<span class="built_in">assert</span>(*sp2 == <span class="number">2022</span>);</span><br><span class="line">	<span class="built_in">assert</span>(sp2.<span class="built_in">use_count</span>() == <span class="number">1</span>);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;moveTest passed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">copySharedPointerTest</span>();</span><br><span class="line">	<span class="built_in">moveSharedPointerTest</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="unique_ptr-1">unique_ptr</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(T* ptr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> D = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(T*)&gt;&gt;</span><br><span class="line">class UniquePointer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 默认构造函数</span></span><br><span class="line">	<span class="built_in">UniquePointer</span>(T* ptr = <span class="literal">nullptr</span>, D del = A::Delete&lt;T&gt;): <span class="built_in">pointer</span>(ptr), <span class="built_in">deleter</span>(del) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 移动构造函数</span></span><br><span class="line">	<span class="built_in">UniquePointer</span>(UniquePointer&amp;&amp; rhs) &#123;</span><br><span class="line">		pointer = rhs.pointer;</span><br><span class="line">		deleter = std::forward&lt;D&gt;(rhs.deleter);</span><br><span class="line">		rhs.pointer = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 移动赋值运算符</span></span><br><span class="line">	UniquePointer&amp; <span class="keyword">operator</span>=(UniquePointer&amp;&amp; rhs) &#123;</span><br><span class="line">		pointer = rhs.pointer;</span><br><span class="line">		deleter = std::forward&lt;D&gt;(rhs.deleter);</span><br><span class="line">		rhs.pointer = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 析构函数</span></span><br><span class="line">	~<span class="built_in">UniquePointer</span>() &#123;</span><br><span class="line">		<span class="built_in">destroy</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拷贝构造函数</span></span><br><span class="line">	<span class="built_in">UniquePointer</span>(<span class="keyword">const</span> UniquePointer&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">	UniquePointer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> UniquePointer&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 裸指针赋值</span></span><br><span class="line">	UniquePointer&amp; <span class="keyword">operator</span>=(T* ptr) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重载bool</span></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> pointer? <span class="literal">true</span>: <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重载解引用运算符</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line">		<span class="keyword">return</span> *pointer;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重载箭头运算符</span></span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;<span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取裸指针</span></span><br><span class="line">	<span class="function">T* <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> pointer;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 放弃对指针的控制权, 返回指针并置空</span></span><br><span class="line">	<span class="function">T* <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		T* temp = pointer;</span><br><span class="line">		pointer = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 释放所指对象</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">destroy</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放所指对象, 并指向另一个对象</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(T* ptr)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">reset</span>();</span><br><span class="line">		pointer = ptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T* pointer;</span><br><span class="line">	D deleter;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (pointer) &#123;</span><br><span class="line">			<span class="built_in">deleter</span>(pointer);</span><br><span class="line">			pointer = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br><span class="line">	<span class="function">UniquePointer&lt;<span class="keyword">int</span>&gt; <span class="title">up1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">	<span class="built_in">assert</span>(*up1 == <span class="number">10</span>);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Basic test passed\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br><span class="line">	<span class="function">UniquePointer&lt;<span class="keyword">int</span>&gt; <span class="title">up1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">	<span class="function">UniquePointer&lt;<span class="keyword">int</span>&gt; <span class="title">up2</span><span class="params">(std::move(up1))</span></span>;</span><br><span class="line">	<span class="built_in">assert</span>(*up2 == <span class="number">10</span>);</span><br><span class="line">	<span class="built_in">assert</span>(up1.<span class="built_in">get</span>() == <span class="literal">nullptr</span>);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Move test passed\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resetTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br><span class="line">	<span class="function">UniquePointer&lt;<span class="keyword">int</span>&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">	up.<span class="built_in">reset</span>();</span><br><span class="line">	<span class="built_in">assert</span>(up1.<span class="built_in">get</span>() == <span class="literal">nullptr</span>);</span><br><span class="line">	up.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">2022</span>));</span><br><span class="line">	<span class="built_in">assert</span>(*up1 == <span class="number">2022</span>);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Reset test passed\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">basicTest</span>();</span><br><span class="line">	<span class="built_in">moveTest</span>();</span><br><span class="line">	<span class="built_in">resetTest</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/29/%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Young">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="元朗食品">
      <meta itemprop="description" content="Talk is cheap, show me the code.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 元朗食品">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/29/%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">图解系统笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-29 11:55:08" itemprop="dateCreated datePublished" datetime="2022-03-29T11:55:08+08:00">2022-03-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-08 20:08:32" itemprop="dateModified" datetime="2022-04-08T20:08:32+08:00">2022-04-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Computer-Network/" itemprop="url" rel="index"><span itemprop="name">Computer Network</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="硬件结构">硬件结构</h1>
<h2 id="冯诺依曼模型">冯诺依曼模型</h2>
<ul>
<li><strong>计算机结构</strong>：中央处理器、内存、输入设备、输出设备、总线</li>
</ul>
<h2 id="程序执行的基本过程">程序执行的基本过程</h2>
<ul>
<li><strong>取指</strong>：CPU读取PC得到指令的内存地址，访问该内存得到指令并存入指令寄存器</li>
<li><strong>执行</strong>：分析指令寄存器中的指令，若为计算类型的指令则交给逻辑运算单元运算，若为存储类型的指令则交给控制单元执行</li>
<li><strong>PC自增</strong>：指令执行完后，PC自增指向下一条指令</li>
</ul>
<h2 id="指令周期">指令周期</h2>
<ul>
<li><strong>Fetch</strong>：取得指令</li>
<li><strong>Decode</strong>：指令译码</li>
<li><strong>Execution</strong>：执行指令</li>
<li><strong>Store</strong>：数据回写</li>
</ul>
<h2 id="存储器金字塔">存储器金字塔</h2>
<ul>
<li><strong>寄存器</strong>：读写速度最快</li>
<li><strong>CPU
cache</strong>：读写速度快，存储容量小，静态随机存储器SRAM，分为三级L1、L2、L3
Cache</li>
<li><strong>内存</strong>：动态随机存储器DRAM</li>
<li><strong>SSD/HDD硬盘</strong>：存储容量大，读写速度慢，断电后数据仍存在</li>
</ul>
<h2 id="cpu缓存一致性">CPU缓存一致性</h2>
<ul>
<li>多核CPU中，每个核心都有<strong>各自的L1/L2
Cache</strong>，而<strong>L3
Cache</strong>则是所有核心<strong>共享</strong>使用的</li>
</ul>
<h3 id="写直达">写直达</h3>
<ul>
<li><strong>写直达</strong>：把数据同时写入内存和Cache中</li>
<li><strong>如果数据没有在Cache里面</strong>：直接把数据更新到内存中</li>
<li><strong>缺点</strong>：每次写操作都写回到内存，写操作花费大量时间</li>
</ul>
<h3 id="写回">写回</h3>
<ul>
<li><p><strong>写回</strong>：发生写操作时，新的数据仅仅写入Cache
block，只有当修改过的Cache block被替换时，才需要写到内存中</p></li>
<li><p><strong>写操作时数据已经在CPU Cache中</strong>：数据更新到CPU
Cache里，标记CPU
Cache里的block为dirty，代表该block的数据和内存是不一致的</p></li>
<li><p><strong>写操作时数据不在Cache中</strong>：进行替换，检查被替换的Cache
block是否为dirty，若为dirty则要把Cache
Block里的数据写回到内存，在把当前要写入的数据写入到Cache
block并标记为dirty</p></li>
<li><p><strong>优点</strong>：减少了写内存的次数，性能提高</p></li>
</ul>
<h1 id="操作系统结构">操作系统结构</h1>
<ul>
<li><strong>操作系统的作用</strong>：进程管理、内存管理、设备管理、提供系统调用</li>
</ul>
<h2 id="内核态与用户态">内核态与用户态</h2>
<ul>
<li><p><strong>内核态与用户态</strong>：内核程序执行在内核态，用户程序执行在用户态</p></li>
<li><p>内核态与用户态的切换方式</p>
<p><strong>系统调用</strong>：用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作</p>
<p><strong>异常</strong>：CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中</p>
<p><strong>设备中断</strong>：外围设备完成用户请求的操作后，向CPU发出中断信号</p></li>
<li><p><strong>系统调用</strong>：应用程序使用系统调用时会产生一个<strong>中断</strong>。发生中断后，CPU会中断当前在执行的用户程序，转而跳转到<strong>中断处理程序</strong>，即开始执行内核程序。内核处理完成后，主动触发<strong>中断</strong>，把CPU执行权限交回给<strong>用户程序</strong>，回到用户态继续工作</p></li>
</ul>
<h2 id="宏内核与微内核">宏内核与微内核</h2>
<ul>
<li><strong>宏内核</strong>：系统内核的所有模块都运行在内核态</li>
<li><strong>微内核</strong>：内核只保留最基本的能力，如进程调度、虚拟机内存、中断等</li>
<li><strong>混合类型内核</strong>：内核里有一个最小版本的内核，其他模块在其基础上搭建，但整个内核是仍然作为一个完整程序，大部分服务都在内核中</li>
</ul>
<h1 id="内存管理">内存管理</h1>
<h2 id="虚拟内存的概念">虚拟内存的概念</h2>
<ul>
<li><p><strong>虚拟内存</strong>：操作系统让每个进程都拥有独立的连续地址空间，称为虚拟内存</p></li>
<li><p><strong>虚拟内存地址与物理内存地址</strong>：进程使用虚拟内存地址访问内存，而存在硬件中的实际地址是物理内存地址，虚拟内存地址到物理地址的转换是由硬件<strong>内存管理单元MMU</strong>完成的</p></li>
<li><p><strong>分段/分页</strong>：内存空间常通过分段或分页的方式进行组织</p></li>
</ul>
<h2 id="内存分段">内存分段</h2>
<ul>
<li><p><strong>分段</strong>：程序由若干个逻辑分段组成，如代码分段、数据分段、栈段、堆段，不同的段有不同的属性</p></li>
<li><p><strong>虚拟地址</strong>：由段号和段内偏移量组成</p></li>
<li><p><strong>段表</strong>：虚拟地址通过段表与物理地址进行映射，段表中包含段基地址、段界限</p></li>
<li><p>虚拟地址向物理地址转换的过程</p>
<p><strong>根据段号索引段表</strong>：根据虚拟地址的段号找到段表</p>
<p><strong>检查越界</strong>：对比段内偏移量和段表中的段界限，判断虚拟地址是否合法</p>
<p><strong>得到物理地址</strong>：段基地址加上段内偏移量即得到虚拟地址对应的物理地址</p></li>
<li><p>缺点</p>
<p><strong>内存碎片</strong>：产生多个不连续的小物理内存，导致新的程序无法被装载</p>
<p><strong>内存交换效率低</strong>：为了解决内存碎片问题，采用内存交换方法，先将程序写到硬盘上，再从硬盘读回内存，并紧跟着上一个程序，从而消除了该内存碎片。如果将较大的程序写回硬盘再读入内存，则速度较慢</p></li>
</ul>
<h2 id="内存分页">内存分页</h2>
<ul>
<li><strong>分页</strong>：把整个虚拟和物理内存空间切成一段段固定尺寸的大小，这个连续且尺寸固定的内存空间称为<strong>页</strong></li>
<li><strong>页表</strong>：虚拟地址与物理地址之间通过页表进行映射，内存管理单元MMU负责将虚拟地址映射为物理地址</li>
<li><strong>缺页异常</strong>：当进程访问的虚拟地址在页表中查不到时，产生一个缺页异常，进入内核态由操作系统分配物理内存、更新进程页表，最后返回用户空间继续执行</li>
</ul>
<h3 id="分页怎么解决内存碎片内存交换效率低等问题">分页怎么解决内存碎片、内存交换效率低等问题</h3>
<ul>
<li><p><strong>内存碎片问题</strong>：采用分页，内存的释放是以页为单位进行的，不会产生无法给进程使用的小内存</p></li>
<li><p><strong>内存交换效率问题</strong>：<strong>LRU策略</strong>，当内存空间不足时，若需要换入新页面，则操作系统将最久未被使用的内存页面释放掉</p></li>
<li><p><strong>Demand
paging</strong>：加载程序时，无需把整个程序加载到物理内存中，而是在进程使用该页时，发生缺页异常时由操作系统将该页换入内存中</p></li>
</ul>
<h3 id="虚拟地址和物理地址的映射">虚拟地址和物理地址的映射</h3>
<ul>
<li><p><strong>虚拟地址</strong>：分为页号和页内偏移量</p></li>
<li><p><strong>页表</strong>：包含物理页所在的物理内存基地址，由该基地址和页内偏移量组合得到虚拟地址对应的物理地址</p></li>
<li><p><strong>地址转换</strong>的步骤</p>
<p>虚拟地址划分为<strong>页号</strong>和<strong>偏移量</strong></p>
<p>根据页号从页表里查询得到物理页所在内存的<strong>物理内存基地址</strong></p>
<p>将物理页基地址加上<strong>页内偏移量</strong>得到<strong>物理内存地址</strong></p></li>
<li><p><strong>分页的缺点</strong></p>
<p><strong>页表占用较大存储空间</strong>：若页的大小为4KB，而虚拟地址空间为4GB，则共有<span class="math inline">\(2^{20}\)</span>个页，每个页表项为4字节，则共需要4MB空间存放页表</p></li>
</ul>
<h3 id="多级页表">多级页表</h3>
<ul>
<li><strong>目的</strong>：解决页表占用过多存储空间的问题</li>
<li><strong>原理</strong>：将上述<span class="math inline">\(2^{20}\)</span>个页建立两级页表，一级页表包含1024个页表项，对应1024个二级页表；二级页表也包含1024个页表项，对应<span class="math inline">\(2^{20}\)</span>个物理页</li>
<li><strong>优点</strong>：进程并非需要页表中的每一项，因此部分页表项是空的，即一级页表中的部分表项不需要建立对应的二级页表。具体地，考虑一个进程只使用了4MB的连续空间，则只需要一个一级页表和一个二级页表即可，总共<span class="math inline">\(2*2^{10}\)</span>个页表项。若不采用多级页表，则他仍然需要为每个页建立一个页表项，共<span class="math inline">\(2^{20}\)</span>个页表项</li>
<li><strong>速记</strong>：一级页表必须覆盖所有内存空间，二级页表按需建立，因此可以减小存储空间</li>
</ul>
<h3 id="局部性原理">局部性原理</h3>
<ul>
<li><strong>时间局部性</strong>：程序中的某条指令一旦执行，则不久后该指令很可能会再次执行（循环）</li>
<li><strong>空间局部性</strong>：程序访问了某个存储单元，则不久后其附近的存储单元也很可能被访问（指令顺序执行、数组）</li>
</ul>
<h3 id="tlb">TLB</h3>
<ul>
<li><strong>多级页表缺点</strong>：虽然解决了存储空间上的问题，但从虚拟地址到物理地址的转换步骤更加复杂，增加了时间上的开销</li>
<li><strong>TLB</strong>：CPU中加入一个专门存放程序最常访问页表项的Cache（TLB），也称为快表、页表缓存等</li>
</ul>
<h2 id="段页式内存管理">段页式内存管理</h2>
<ul>
<li><p>实现</p>
<p><strong>分段</strong>：程序划分为多个有逻辑意义的段</p>
<p><strong>分页</strong>：对分段划分出来的连续空间，再划分固定大小的页</p></li>
<li><p><strong>虚拟地址</strong>：段号、段内页号、页内偏移量</p></li>
<li><p><strong>地址转换过程</strong></p>
<p>第一次访问段表，得到<strong>页表起始地址</strong></p>
<p>第二次访问页表，得到<strong>物理页号</strong></p>
<p>第三次将物理页号和页内偏移量结合，得到<strong>物理地址</strong></p></li>
</ul>
<h2 id="xv6的内存管理">xv6的内存管理</h2>
<h1 id="进程与线程">进程与线程</h1>
<h2 id="进程">进程</h2>
<h3 id="并发与并行">并发与并行</h3>
<ul>
<li><strong>并发</strong>：在操作系统中，某一时间段内有几个程序在同一个CPU上运行，但<strong>在任意一个时间点上，只有一个程序在CPU上运行</strong></li>
<li><strong>并行</strong>：两个程序在某一时刻同时运行，强调<strong>同时发生</strong></li>
</ul>
<h3 id="进程状态">进程状态</h3>
<ul>
<li><p><strong>创建、就绪、阻塞、运行、终止</strong></p></li>
<li><p><strong>挂起状态</strong>：虚拟内存管理的操作系统中，可能把阻塞状态的进程的物理内存空间换出到硬盘，等需要再次运行时再从硬盘换入到物理内存，描述进程没有占用实际物理内存空间的状态就是挂起状态</p></li>
<li><p><strong>阻塞挂起状态</strong>：进程在外存等待某个事件发生</p></li>
<li><p><strong>就绪挂起状态</strong>：进程在外存中，只要进入内存即可立刻运行</p></li>
</ul>
<h3 id="进程控制块pcb">进程控制块PCB</h3>
<ul>
<li><p><strong>作用</strong>：PCB是进程存在的<strong>唯一标识</strong>，进程创建时PCB创建，进程终止时PCB销毁</p></li>
<li><p>进程描述信息</p>
<p><strong>进程标识符PID</strong>：标识各个进程，每个进程都有一个唯一的标识符</p>
<p><strong>用户标识符UID</strong>：进程归属的用户，为了共享和保护服务</p></li>
<li><p>进程控制和管理信息</p>
<p><strong>进程当前状态</strong>：new、ready、running、waiting或blocked等</p>
<p><strong>进程优先级</strong></p></li>
<li><p><strong>资源</strong>分配清单</p>
<p>有关内存地址空间或虚拟地址空间的信息，所<strong>打开文件的列表</strong>和所<strong>使用的I/O设备信息</strong></p></li>
<li><p>CPU相关信息</p>
<p>CPU中<strong>各个寄存器的值</strong>，当进程切换时，CPU的状态信息被保存在进程的PCB中，以便进程重新执行时，能从断点处继续执行</p></li>
</ul>
<h4 id="pcb是如何组织的">PCB是如何组织的</h4>
<ul>
<li><strong>链表</strong>：通过链表将具有相同状态的进程的PCB链在一起，组成各种队列，如<strong>就绪队列、阻塞队列</strong></li>
</ul>
<h3 id="进程的控制">进程的控制</h3>
<h4 id="创建进程">创建进程</h4>
<ul>
<li><p><strong>创建进程</strong>：操作系统允许一个进程创建另一个进程，且子进程继承父进程所拥有的资源</p></li>
<li><p><strong>过程</strong></p>
<p><strong>分配PID和PCB</strong>：分配新的进程标识号，申请空白的PCB，若申请失败则进程创建失败</p>
<p><strong>分配资源</strong>：为进程分配资源，若资源不足则进程进入等待状态</p>
<p><strong>初始化PCB</strong>：资源分配完成后，初始化PCB</p>
<p><strong>插入就绪队列</strong>：将进程插入到就绪队列，等待被调度</p></li>
</ul>
<h4 id="终止进程">终止进程</h4>
<ul>
<li><strong>查找PCB</strong>：查找需要终止的进程的PCB</li>
<li><strong>终止执行</strong>：若处于执行状态，则立即终止其执行，将CPU资源分配给其他进程</li>
<li><strong>终止子进程</strong>：若该进程有子进程，则子进程也终止</li>
<li><strong>归还资源</strong>：将该进程所拥有的全部资源归还给父进程或操作系统</li>
<li><strong>删除PCB</strong>：将进程PCB从所在队列中删除</li>
</ul>
<h4 id="阻塞进程">阻塞进程</h4>
<ul>
<li><strong>查找PCB</strong>：找到被阻塞进程的PCB</li>
<li><strong>状态转换</strong>：若为运行状态，则保护现场（将CPU寄存器内容保存在PCB等），状态转为阻塞状态</li>
<li><strong>插入阻塞队列</strong>：将PCB插入到阻塞队列</li>
</ul>
<h4 id="唤醒进程">唤醒进程</h4>
<ul>
<li><strong>唤醒</strong>：该进程等待的事件发生，由发现者进程用唤醒语句叫醒阻塞的进程</li>
<li><strong>查找PCB</strong>：在该事件的阻塞队列中找到相应进程的PCB</li>
<li><strong>状态转换</strong>：将PCB从阻塞队列移除，转为就绪状态</li>
<li><strong>插入就绪队列</strong>：PCB插入就绪队列，等待队列</li>
</ul>
<h3 id="进程的上下文切换">进程的上下文切换</h3>
<ul>
<li><p><strong>上下文切换</strong>：从一个进程切换到另一个进程运行的过程</p></li>
<li><p><strong>CPU上下文切换</strong></p>
<p><strong>寄存器和程序计数器</strong>：执行任务前，操作系统需要帮CPU设置好CPU寄存器和程序计数器PC</p>
<p><strong>切换</strong>：将前一个任务的CPU寄存器和PC保存起来，加载新任务的CPU寄存器和PC，跳转到PC所指的新位置运行新任务</p></li>
<li><p><strong>进程上下文切换</strong></p>
<p><strong>进程上下文</strong>：虚拟内存、栈、全局变量等用户空间资源，内核堆栈、寄存器等内核空间资源</p>
<p><strong>存储</strong>：进程上下文信息保存在进程的PCB，当运行时从PCB取出上下文恢复到CPU并继续执行</p></li>
<li><p>进程上下文切换的<strong>场景</strong></p>
<p><strong>时间片耗尽</strong>：CPU采用时间片轮转调度时，当时间片耗尽则进程应从运行态转为就绪态</p>
<p><strong>系统资源不足</strong>：进程需要等待资源满足才可运行，此时它将转换为阻塞态</p>
<p><strong>sleep</strong>：进程通过sleep主动挂起</p>
<p><strong>优先级更高的进程需要运行</strong>：当前运行的进程将被挂起</p>
<p><strong>硬件中断</strong>：CPU上的进程会被中断挂起，转而执行内核中的中断服务程序</p></li>
</ul>
<h2 id="线程">线程</h2>
<ul>
<li><p><strong>概念</strong>：线程是CPU调度的基本单位，同一个进程内的多个线程之间可以<strong>共享代码段、数据段、打开的文件</strong>等资源，每个线程各自都有<strong>独立的寄存器和栈</strong></p></li>
<li><p>优点</p>
<p>一个进程可以同时存在多个线程</p>
<p>各个线程之间可以并发执行</p>
<p>各个线程之间可以共享地址空间和文件等资源</p></li>
<li><p>缺点</p>
<p>进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃</p></li>
</ul>
<h3 id="进程与线程的比较">进程与线程的比较</h3>
<ul>
<li>进程是资源分配的单位，线程是CPU调度的单位</li>
<li>进程拥有完整的资源，而线程只独享必不可少的资源，如<strong>寄存器和栈</strong></li>
<li>线程同样有<strong>就绪、阻塞、执行三种状态</strong>，以及状态之间的转换关系</li>
<li>线程能<strong>减少并发执行的时间和空间开销</strong></li>
</ul>
<h3 id="线程的开销更小">线程的开销更小</h3>
<ul>
<li><strong>线程创建时间比进程快</strong>，因为线程创建不涉及资源管理信息，而是共享所属进程的资源</li>
<li><strong>线程终止时间比进程快</strong>，因为线程释放的资源比进程少很多</li>
<li><strong>同一个进程内的线程切换比进程切换快</strong>，因为线程具有相同的地址空间（虚拟内存共享），切换时无需切换页表</li>
<li><strong>同一个进程内的线程数据交互效率更高</strong>，同一进程的各个线程之间共享内存和文件资源</li>
</ul>
<h3 id="线程的上下文切换">线程的上下文切换</h3>
<ul>
<li>两个线程属于不同进程时，切换过程与进程上下文切换一致</li>
<li>两个线程属于同一个进程，则虚拟内存等资源无需切换，只需切换线程的寄存器、程序计数器等数据</li>
</ul>
<h3 id="线程的实现">线程的实现</h3>
<ul>
<li><p><strong>用户线程</strong>：用户空间实现的线程，由用户态的线程库完成管理</p></li>
<li><p><strong>内核线程</strong>：内核中实现的线程，由内核管理</p></li>
<li><p><strong>轻量级进程</strong>：在内核中支持用户线程</p></li>
<li><p>用户线程和内核线程的对应关系</p>
<p><strong>多对一</strong>：多个用户线程对应同一个内核线程</p>
<p><strong>一对一</strong>：一个用户线程对应一个内核线程</p>
<p><strong>多对多</strong>：多个用户线程对应多个内核线程</p></li>
<li><p><strong>线程控制块TCB</strong></p></li>
</ul>
<h2 id="进程调度">进程调度</h2>
<h3 id="调度原则">调度原则</h3>
<ul>
<li><strong>CPU利用率</strong></li>
<li><strong>系统吞吐量</strong>：单位时间内CPU完成进程的数量</li>
<li><strong>周转时间</strong>：进程运行和阻塞时间的总和</li>
<li><strong>等待时间</strong>：进程处于就绪队列的时间</li>
<li><strong>响应时间</strong>：从用户提交请求到系统第一次产生响应所花费的时间</li>
</ul>
<h3 id="调度算法">调度算法</h3>
<ul>
<li><p><strong>先来先服务FCFS</strong></p></li>
<li><p><strong>最短作业优先SJF</strong></p></li>
<li><p><strong>高响应比优先算法</strong></p>
<p>优先权=(等待时间+要求服务时间)/要求服务时间</p></li>
<li><p><strong>时间片轮转调度算法</strong></p></li>
<li><p><strong>最高优先级调度算法</strong></p></li>
<li><p><strong>多级反馈队列调度算法</strong></p></li>
</ul>
<h2 id="进程间通信">进程间通信</h2>
<h3 id="管道">管道</h3>
<ul>
<li><strong>Linux命令中的管道</strong>：竖线<code>|</code>将前一个命令的输出作为后一个命令的输入，如下将ps
auxf的输出作为grep mysql的输入</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps auxf | grep mysql</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>单向</strong>：管道传输数据是单向的，如果想相互通信需要创建两个管道</p></li>
<li><p><strong>匿名管道</strong>：<code>|</code>表示的管道称为匿名管道，用完了就销毁</p></li>
<li><p><strong>命名管道</strong>：也叫做<code>FIFO</code>，因为数据是先进先出的传输方式。通过<code>mkfifo</code>命令创建并指定管道名字，命名管道以文件的方式存在，类型为p（pipe）</p></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkfifo myPipe</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; myPipe	// 将数据写进管道</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat &lt; myPipe			// 读取管道数据</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure>
<h4 id="匿名管道创建的原理">匿名管道创建的原理</h4>
<ul>
<li><strong>pipe系统调用</strong>：返回两个描述符，分别是管道的读取端描述符<code>fd[0]</code>，另一个是管道的写入端描述符<code>fd[1]</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>管道是内核里的一段缓存</strong>：写入管道的数据实际上是缓存在内核中的，从管道读取数据实则从内核中读取数据</li>
</ul>
<h4 id="父子进程通信">父子进程通信</h4>
<ul>
<li><strong>管道描述符复制</strong>：父进程使用fork创建子进程，子进程会复制父进程的文件描述符，因此子进程也拥有该管道的读取端、写入端的描述符</li>
<li><strong>单向通信</strong>：父进程关闭读取端描述符<code>fd[0]</code>，保留写入端<code>fd[1]</code>；子进程关闭写入端<code>fd[1]</code>，保留读取端<code>fd[0]</code>，这样父进程往管道写入的数据就能被子进程读取</li>
<li><strong>双向通信</strong>：如果需要双向通信，则应该创建两个管道</li>
</ul>
<h4 id="匿名管道和命名管道的区别">匿名管道和命名管道的区别</h4>
<ul>
<li><p><strong>匿名管道</strong>：<strong>通信范围</strong>是存在<strong>父子关系的进程</strong>，管道没有实体，没有管道文件，因此该管道只能通过fork复制父进程文件描述符，来达到通信的目的</p></li>
<li><p><strong>命名管道</strong>：可以在<strong>不相关的进程</strong>间相互通信，命名管道创建了类型为管道的设备文件，进程只要使用这个设备文件，就可以相互通信</p></li>
<li><p><strong>共同点</strong>：数据都是缓存在内核中，数据遵循FIFO原则</p></li>
</ul>
<h3 id="消息队列">消息队列</h3>
<ul>
<li><p><strong>链表</strong>：消息队列是保存在内核中的消息链表，发送数据时会分成多个独立的数据单元，即消息体。进程从消息队列中读取了消息体，内核就把该消息体删除</p></li>
<li><p><strong>消息队列不阻塞进程</strong>：A进程要给B进程发送消息，则A进程只要把数据放在对应的消息队列后就可正常返回，B进程需要的时候再去读取数据即可</p></li>
<li><p><strong>消息队列存在用户态与内核态之间的数据拷贝开销</strong>：进程写入数据到内核中的消息队列时，需要把数据从用户态拷贝到内核态；进程读取消息队列的数据时，需要将数据从内核态拷贝到用户态</p></li>
</ul>
<h3 id="共享内存">共享内存</h3>
<ul>
<li><p><strong>优点</strong>：消息队列在进行读取和写入时，都得进行内核态与用户态之间的数据拷贝，共享内存则解决了该问题</p></li>
<li><p><strong>虚拟内存</strong>：每个进程都有独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存，因此两个进程相同的虚拟地址对应着不同的物理内存地址</p></li>
<li><p><strong>共享内存</strong>：将一块虚拟地址空间映射到相同的物理内存中，进程A写入的内容将立刻被进程B看见，无需进行拷贝，大大提高了进程间通信的速度</p></li>
</ul>
<h3 id="信号量">信号量</h3>
<ul>
<li><p><strong>共享内存的问题</strong>：如果多个进程同时修改同一个共享内存，则部分进程的修改将被其他进程覆盖，造成数据错乱</p></li>
<li><p><strong>保护机制</strong>：为了防止多进程竞争共享资源，造成数据错乱，需要保护机制，是的共享资源在任意时刻只能被一个进程访问</p></li>
<li><p><strong>信号量</strong>：一个整型的计数器，主要用于实现进程间的互斥与同步</p></li>
<li><p><strong>控制信号量的两种原子操作</strong></p>
<p><strong>P操作</strong>：把信号量减去1，相减后若信号量小于0，则表明资源已被占用，进程需要阻塞等待；若相减后信号量大于等于0，则表明还有资源可用，进程可正常继续执行</p>
<p><strong>V操作</strong>：把信号量加上1，相加后若信号量小于等于0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量大于0，则表明没有阻塞中的进程</p></li>
<li><p><strong>互斥信号量</strong>：<strong>信号初始化为1</strong>，则保证共享资源在任何时刻只有一个进程在访问，因此为互斥信号量</p></li>
<li><p><strong>同步信号量</strong>：<strong>信号初始化为0</strong>，假如必须保证进程A在进程B之前执行，则进程A在最后执行V操作，进程B在最开始执行P操作</p></li>
</ul>
<h3 id="信号">信号</h3>
<ul>
<li><p><strong>信号</strong>：<strong>异常情况</strong>下，需要用信号的方式通知进程</p></li>
<li><p><strong>Linux信号</strong></p>
<p>对于运行在shell终端的进程，可以通过键盘输入某些组合键给进程发送信号，如</p>
<p><strong>终止进程</strong>：Ctrl+C产生SIGINT信号，表示终止进程</p>
<p><strong>停止进程</strong>：Ctrl+Z产生SIGTSTP信号，表示停止进程，但还未结束</p>
<p>如果进程在后台运行，可以通过<strong>kill命令和进程PID</strong>给进程发送信号，如</p>
<p><code>kill -9 1050</code>，表示给PID为1050的进程发送SIGKILL信号，用来立即结束该进程</p></li>
</ul>
<h3 id="socket">Socket</h3>
<ul>
<li><p><strong>Socket通信</strong>：跨网络与不同主机上的进程之间通信，也可以在同主机上进程间通信</p></li>
<li><p>创建socket的系统调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>
<p>domain指定协议族，比如AF_INET用于IPv4，AF_INET6用于IPv6，AF_LOCAL用于本机</p>
<p>type指定通信特性，如SOCK_STREAM表示字节流，对应TCP；SOCK_DGRAM表示数据报，对应UDP；SOCK_RAW表示原始套接字</p>
<p>protocol用于指定通信协议，现在基本废弃</p></li>
</ul>
<h4 id="基于tcp协议通信的socket编程模型">基于TCP协议通信的socket编程模型</h4>
<ul>
<li><p>过程</p>
<p><strong>初始化socket</strong>：服务端和客户端初始化socket，得到文件描述符</p>
<p><strong>绑定</strong>：服务端调用bind，绑定在IP地址和端口</p>
<p><strong>监听</strong>：服务端调用listen进行监听</p>
<p><strong>accept</strong>：服务端调用accept等待客户端连接，客户端发起连接后，accept返回用于传输的socket的文件描述符</p>
<p><strong>发起连接</strong>：客户端调用connect向服务端的地址和端口发起连接请求</p>
<p><strong>数据传输</strong>：客户端调用write写入数据，服务端调用read读取数据</p>
<p><strong>断开连接</strong>：客户端调用close，服务器调用read读取数据时会读取到EOF，处理完数据后服务端调用close表示连接关闭</p></li>
<li><p>两个socket</p>
<p><strong>监听socket</strong>：服务端进行监听的socket</p>
<p><strong>已完成连接socket</strong>：用于传送数据的socket</p></li>
</ul>
<h4 id="基于udp协议通信的socket编程模型">基于UDP协议通信的socket编程模型</h4>
<ul>
<li><strong>初始化socket</strong></li>
<li><strong>绑定</strong>：每个UDP的socket都需要绑定IP地址和端口</li>
<li><strong>sendto</strong>：向目标主机的IP地址和端口发送数据</li>
<li><strong>recvfrom</strong>：接收源主机IP地址和端口的数据</li>
<li><strong>无连接</strong>：UDP是无连接的，因此不需要三次握手，也不需要调用listen和connect</li>
</ul>
<h4 id="针对本地进程间通信的socket编程模型">针对本地进程间通信的socket编程模型、</h4>
<ul>
<li><strong>效率提高</strong>：编程接口和IPv4、IPv6套接字编程接口一致，支持字节流、数据报两种协议，但实现效率大大提高</li>
<li><strong>绑定</strong>：本地字节流socket和本地数据报socket在bind时，并非<strong>绑定IP地址和端口</strong>，而是<strong>绑定本地文件</strong></li>
</ul>
<h2 id="多线程同步">多线程同步</h2>
<h3 id="互斥">互斥</h3>
<ul>
<li><p><strong>race
condition</strong>：多线程相互竞争操作共享变量时，由于在执行过程中发生了上下文切换，得到了错误的结果</p></li>
<li><p><strong>临界区</strong>：访问共享资源的代码片段，不能给多线程同时执行</p></li>
<li><p><strong>互斥</strong>：一个线程在临界区执行时，其他线程应该被阻止进入临界区</p></li>
</ul>
<h3 id="同步">同步</h3>
<ul>
<li><strong>同步</strong>：并发进程/线程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通消息称为进程/线程同步。即多个进程/线程在合作共同完成任务时，需要有一定的先后执行顺序的制约。</li>
</ul>
<h3 id="互斥与同步的实现和使用">互斥与同步的实现和使用</h3>
<h4 id="锁">锁</h4>
<ul>
<li><p><strong>加锁</strong>：任何进入临界区的线程，必须先执行加锁操作，加锁成功则进入临界区，否则阻塞</p></li>
<li><p><strong>解锁</strong>：完成对临界资源的访问后执行解锁操作，以释放该临界资源</p></li>
<li><p><strong>原子操作指令Test-and-Set</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TestAndSet</span><span class="params">(<span class="keyword">int</span> *old_ptr, <span class="keyword">int</span> <span class="keyword">new</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old = *old_ptr;</span><br><span class="line">    *old_ptr = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>功能</strong>：该指令由硬件完成，把old_ptr更新为new的值，并返回old_ptr的旧值</p>
<p><strong>原子性</strong>：要么全部执行，要么都不执行，不会出现执行到一半的中间状态</p></li>
<li><p><strong>使用原子操作指令实现忙等待锁</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">&#125; <span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (TestAndSet(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">    ;	<span class="comment">// do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">   	lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>flag的含义</strong>：flag为1代表该锁被某个线程持有，否则代表该锁未被持有</p>
<p><strong>加锁时的操作</strong>：假如该锁已被其他线程持有，则<code>lock-&gt;flag</code>为1，执行<code>TestAndSet(&amp;lock-&gt;flag, 1)</code>不会改变flag的值，而且会读取到1，此时while循环条件满足，将继续循环；若该锁被其他线程释放，则<code>lock-&gt;flag</code>为0，执行<code>TestAndSet(&amp;lock-&gt;flag, 0)</code>会改变flag的值，从而获取该锁，同时读取到原来的值0，将跳出循环，并执行临界区代码</p></li>
<li><p><strong>自旋锁</strong>：当获取不到锁时，线程会一直执行while循环而不做任何其他事情，因此称为忙等待锁，也叫自旋锁spin
lock</p></li>
<li><p><strong>无等待锁</strong>：获取不到锁时，线程放入到锁的等待队列，当前线程阻塞，CPU会调度其他线程执行。待持有锁的线程释放锁时，将唤醒该锁的等待队列中的某个线程让其获取锁并继续执行</p></li>
</ul>
<h4 id="信号量-1">信号量</h4>
<ul>
<li><p><strong>含义</strong>：信号量通常表示资源的数量，对应一个整型变量</p></li>
<li><p><strong>原子操作</strong></p>
<p><strong>P操作</strong>：将信号量减1，若<strong>信号量小于0则阻塞等待</strong>，否则继续执行</p>
<p><strong>V操作</strong>：将信号量加1，若<strong>信号量小于等于0则唤醒一个等待中的线程/进程</strong></p></li>
</ul>
<h3 id="c实现信号量机制">C++实现信号量机制</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unique_lock&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    mutex mtx;</span><br><span class="line">    condition_variable cv;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Semaphore</span>(<span class="keyword">int</span> count = <span class="number">1</span>): <span class="built_in">count</span>(cnt) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">        	cv.<span class="built_in">wait</span>(guard);</span><br><span class="line">       	--count;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        ++count;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="生产者-消费者问题">生产者-消费者问题</h3>
<ul>
<li><p><strong>问题描述</strong>：生产者生成数据后，放在缓冲区中；消费者从缓冲区取出数据处理；任何时刻，只能有一个生产者或消费者可以访问缓冲区</p></li>
<li><p>问题分析</p>
<p><strong>互斥访问缓冲区</strong>：任何时刻只有一个线程能访问缓冲区，需要设置互斥信号量保护缓冲区</p>
<p><strong>缓冲区空</strong>：消费者必须等待生产者生成数据</p>
<p><strong>缓冲区满</strong>：生产者必须等待消费者取出数据</p></li>
<li><p>信号量设置</p>
<p><strong>互斥信号量mutex</strong>：用于互斥访问缓冲区，初始化值为1</p>
<p><strong>资源信号量full</strong>：用于消费者询问缓冲区是否有数据，有数据则读取，无数据则阻塞，初始化为0（表示缓冲区初始为空）</p>
<p><strong>资源信号量empty</strong>：用于生产者询问缓冲区是否有空位，有空位则生成数据，初始化值为n（缓冲区大小）</p></li>
<li><p>实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N = <span class="number">10</span>;	<span class="comment">// buffer size</span></span><br><span class="line"><span class="function">Semaphore <span class="title">mutex</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">Semaphore <span class="title">full</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Semaphore <span class="title">empty</span><span class="params">(N)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(full);</span><br><span class="line">        P(mutex);</span><br><span class="line">        read();</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;     </span><br><span class="line">        P(empty);</span><br><span class="line">        P(mutex);</span><br><span class="line">        write();</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>先获取full或empty信号量，再获取互斥锁mutex</strong>：如果先获取mutex则会导致死锁，假设当前缓冲区为空，消费者获取了mutex，然后尝试获取full失败并阻塞，但它仍然持有mutex。此时，生产者想要生成数据必须先获取mutex，由于已被持有因此生产者也会被阻塞，造成死锁</p></li>
</ul>
<h3 id="哲学家进餐问题">哲学家进餐问题</h3>
<ul>
<li>限制就餐人数为N-1</li>
<li>指定拿筷子规则，奇数哲学家先拿左手，偶数哲学家先拿右手</li>
</ul>
<h3 id="读者-写者问题">读者-写者问题</h3>
<ul>
<li><p><strong>问题描述</strong>：多个读者可以共同访问，但是写者必须单独访问（不能与其他读者共同访问，也不能与其他写者共同访问）</p></li>
<li><p><strong>实现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Semaphore <span class="title">rMutex</span><span class="params">(<span class="number">1</span>)</span></span>;		<span class="comment">// 访问读者计数器rCount的互斥量</span></span><br><span class="line"><span class="function">Semaphore <span class="title">wMutex</span><span class="params">(<span class="number">1</span>)</span></span>;		<span class="comment">// 读者与写者互斥访问文件的互斥量</span></span><br><span class="line"><span class="function">Semaphore <span class="title">flag</span><span class="params">(<span class="number">1</span>)</span></span>;			<span class="comment">// 读者与写者互斥访问wMutex的互斥量</span></span><br><span class="line"><span class="keyword">int</span> rCount = <span class="number">0</span>;				<span class="comment">// 读者计数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(flag);</span><br><span class="line">        P(wMutex);</span><br><span class="line">        write();</span><br><span class="line">        V(wMutex);</span><br><span class="line">        V(flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(flag);</span><br><span class="line">        P(rMutex);</span><br><span class="line">        <span class="keyword">if</span> (rCount == <span class="number">0</span>) &#123;</span><br><span class="line">            P(wMutex);			<span class="comment">// 第一个读者进入时, 需要阻塞写者写操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        ++rCount;</span><br><span class="line">        V(rMutex);</span><br><span class="line">        V(flag);</span><br><span class="line">        read();</span><br><span class="line">        P(rMutex);</span><br><span class="line">        --rCount;</span><br><span class="line">        <span class="keyword">if</span> (rCount == <span class="number">0</span>) &#123;</span><br><span class="line">            V(wMutex);			<span class="comment">// 没有读者了, 唤醒阻塞中的写者</span></span><br><span class="line">        &#125;</span><br><span class="line">        V(rMutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="死锁">死锁</h2>
<h3 id="死锁的必要条件">死锁的必要条件</h3>
<ul>
<li>互斥访问</li>
<li>不可抢占</li>
<li>占有并等待</li>
<li>环路等待</li>
</ul>
<h3 id="解决方法">解决方法</h3>
<ul>
<li>死锁预防</li>
<li>死锁检测与恢复</li>
<li>死锁避免：银行家算法</li>
</ul>
<h2 id="锁-1">锁</h2>
<h3 id="互斥锁与自旋锁">互斥锁与自旋锁</h3>
<ul>
<li><p><strong>互斥锁</strong>：加锁失败后，线程<strong>释放CPU</strong>给其他线程</p></li>
<li><p><strong>自旋锁</strong>：加锁失败后，线程会忙等待（<strong>占用CPU</strong>），直到拿到锁</p></li>
<li><p><strong>互斥锁的开销成本</strong>：当线程获取互斥锁失败时将被阻塞，线程从运行切换为阻塞状态，从用户态陷入内核态，内核完成线程切换；当该互斥锁被其他线程释放时，之前睡眠的线程变为就绪状态，内核会在合适的时间把CPU切换到该线程运行。因此互斥锁的开销成本为两次线程上下文切换的成本</p></li>
<li><p><strong>自旋锁的开销成本</strong>：自旋锁通过CPU提供的CAS函数（Compare
And
Swap）在用户态完成加锁和解锁操作，无需进行线程上下文切换，但是会一直占用CPU</p></li>
<li><p><strong>选择</strong>：如果临界区代码执行时间很短，则不应该用互斥锁，而是用自旋锁；若临界区代码执行时间较长，则使用互斥锁，因为此时使用自旋锁将导致较长时间内CPU资源的浪费</p></li>
</ul>
<h3 id="读写锁">读写锁</h3>
<ul>
<li><strong>原理</strong>：写锁是独占锁，读锁是共享锁</li>
<li><strong>应用</strong>：读写锁在读多写少的场景，能发挥出优势</li>
</ul>
<h3 id="乐观锁与悲观锁">乐观锁与悲观锁</h3>
<ul>
<li><strong>悲观锁</strong>：认为多线程同时修改共享资源的概率较高，很容易出现冲突，所以<strong>访问共享资源前先上锁</strong></li>
<li><strong>乐观锁</strong>：认为多线程同时修改共享资源的概率较低。<strong>先修改</strong>共享资源，<strong>再验证</strong>这段时间内有没有发生冲突，如果没有其他线程修改资源则操作完成，否则<strong>放弃本次操作并重试</strong></li>
</ul>
<h1 id="调度算法-1">调度算法</h1>
<h2 id="进程调度算法">进程调度算法</h2>
<ul>
<li>先来先服务调度算法FCFS</li>
<li>最短作业优先调度算法SJF</li>
<li>高响应比优先调度算法</li>
<li>时间片轮转调度算法</li>
<li>最高优先级调度算法</li>
<li>多级反馈队列调度算法</li>
</ul>
<h2 id="页面置换算法">页面置换算法</h2>
<h3 id="缺页中断">缺页中断</h3>
<ul>
<li><p><strong>缺页中断</strong>：当CPU访问的页面不在物理内存时，则产生一个缺页中断，请求操作系统将所缺页调入到物理内存</p></li>
<li><p>缺页中断的处理流程</p>
<p><strong>执行指令</strong>：Load M指令，CPU寻找M对应的页表项</p>
<p><strong>页表项无效，发出缺页中断</strong>：如果该页表项的状态位是无效的，则CPU发送缺页中断请求</p>
<p><strong>缺页中断处理函数</strong>：操作系统收到缺页中断，执行缺页中断处理函数，查找该页面在磁盘中的页面的位置</p>
<p><strong>换入</strong>：在物理内存中找到空闲页，把该页面从磁盘换入到内存中</p>
<p><strong>修改页表项为有效的</strong>：把该页的页表项的有效位修改为有效的</p>
<p><strong>重新执行指令</strong>：CPU重新执行导致缺页异常的指令</p></li>
<li><p><strong>页面置换</strong>：物理内存没有空闲页时，则需要进行页面置换，选择一个物理页，若其dirty位置位，则换出到磁盘，并将其页表项改为无效的。然后把需要访问的页从磁盘换入到物理内存</p></li>
<li><p><strong>页表项：页号、物理页号、有效位、访问字段、dirty位、硬盘地址</strong></p></li>
</ul>
<h3 id="虚拟内存访存的整体流程">虚拟内存访存的整体流程</h3>
<ul>
<li><strong>检查虚拟地址</strong>：程序通过虚拟地址访问某个页面，先检查该地址是否有效</li>
<li><strong>检索TLB、访问页表</strong>：若有效则检索TLB，TLB命中则得到了该页表项；否则访问页表，并将该页表项更新至TLB</li>
<li><strong>检查页表项有效位、缺页中断</strong>：检查该页表项有效位，若无效则发送缺页中断，由操作系统从磁盘中找到缺页并换入内存，若需要进行页面置换则检查该页面是否dirty，若是还需要将其写入磁盘</li>
<li><strong>置访问位、dirty位</strong>：修改该页的页表项的访问位和dirty位</li>
<li><strong>得到物理地址</strong>：将物理页号和页内偏移量组合得到物理地址，最后访问该地址</li>
</ul>
<h3 id="页面置换算法-1">页面置换算法</h3>
<ul>
<li><strong>最佳页面置换算法OPT</strong></li>
<li><strong>先进先出置换算法FIFO</strong></li>
<li><strong>最近最久未使用LRU</strong></li>
<li><strong>时钟页面置换算法Lock</strong></li>
<li><strong>最不常用置换算法LFU</strong></li>
</ul>
<h1 id="io模型">I/O模型</h1>
<ul>
<li><p>一个输入操作通常包括<strong>两个阶段</strong></p>
<p><strong>等待数据到来</strong>：等待数据准备好</p>
<p><strong>拷贝数据</strong>：从内核向进程复制数据</p></li>
<li><p>对于套接字上输入操作的两个阶段</p>
<p><strong>等待数据从网络到来</strong>：等待数据从网络中到达，到达后数据被复制到内核中的某个缓冲区</p>
<p><strong>拷贝数据</strong>：把数据从内核缓冲区复制到应用进程缓冲区</p></li>
</ul>
<h2 id="阻塞io">阻塞I/O</h2>
<ul>
<li>应用进程被阻塞，直至<strong>数据从内核缓冲区复制到应用进程缓冲区</strong>才返回</li>
<li>阻塞时，CPU调度将执行其他线程/进程</li>
</ul>
<h2 id="非阻塞io">非阻塞I/O</h2>
<ul>
<li><p><strong>轮询</strong>：应用进程执行系统调用后，内核返回一个错误码，应用进程可以继续执行，但是需要<strong>不断执行系统调用以获知I/O是否完成</strong></p></li>
<li><p><strong>缺点</strong>：应用进程需要进行多次系统调用，<strong>CPU利用率较低</strong></p></li>
</ul>
<h2 id="io复用">I/O复用</h2>
<ul>
<li><p><strong>等待数据</strong>：使用select或poll等待数据，等待多个套接字中的任何一个变为可读，此过程会被阻塞</p></li>
<li><p><strong>读取数据</strong>：某一个套接字可读时返回，使用<code>recvfrom</code>系统调用把数据从内核复制到进程中</p></li>
<li><p><strong>优点</strong>：单个进程具有处理多个I/O事件的能力，又称为事件驱动I/O</p></li>
</ul>
<h2 id="信号驱动io">信号驱动I/O</h2>
<ul>
<li><strong>sigaction系统调用</strong>：应用进程使用sigaction系统调用，内核立刻返回，等待数据阶段是非阻塞的</li>
<li><strong>数据到达</strong>：内核在数据到达时向应用进程发送SIGIO信号，应用进程收到后在信号处理程序中调用recvfrom将数据从内核复制到应用进程中</li>
<li><strong>优点</strong>：相比于非阻塞式的I/O轮询方式，提高了CPU利用率</li>
</ul>
<h2 id="异步io">异步I/O</h2>
<ul>
<li><p><strong>aio_read系统调用</strong>：应用进程执行aio_read系统调用后立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成后向应用进程发送信号</p></li>
<li><p><strong>异步I/O与信号驱动I/O的区别</strong></p>
<p>异步I/O的信号是<strong>通知应用进程I/O完成</strong>（数据已经复制到应用进程缓冲区）</p>
<p>信号驱动I/O的信号是<strong>通知应用进程可以开始I/O</strong>（数据已经到达内核缓冲区，需要调用recv_from将数据拷贝到应用进程缓冲区）</p></li>
</ul>
<h2 id="同步io与异步io的区别">同步I/O与异步I/O的区别</h2>
<ul>
<li><strong>同步I/O</strong>：将数据从内核缓冲区复制到应用进程缓冲区阶段，应用进程会被阻塞</li>
<li><strong>异步I/O</strong>：上述第二阶段不会被阻塞</li>
</ul>
<h2 id="io多路复用">I/O多路复用</h2>
<h3 id="select">select</h3>
<ul>
<li><p><strong>功能</strong>：允许应用程序监视一组文件描述符，等待一个或多个描述符称为就绪状态，从而完成I/O操作</p></li>
<li><p><strong>参数</strong></p>
<p>fd_set：文件描述符集合，使用数组实现，数组大小固定为FD_SETSIZE（Linux中为1024）。三种类型的描述符类型为readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合</p>
<p>timeout：超时参数，调用select会一直阻塞直到有描述符的时间到达，或等待的时间超过了timeout</p></li>
<li><p><strong>返回值</strong>：调用成功返回结果大于0，超时返回0，出错返回-1</p></li>
</ul>
<h3 id="poll">poll</h3>
<ul>
<li><p><strong>功能</strong>：poll的功能与select类似，也是等待一组描述符中的任意一个成为就绪状态</p></li>
<li><p><strong>描述符数量限制</strong>：select使用数组实现文件描述符集合，数组大小为1024，poll没有描述符数量限制</p></li>
<li><p>缺点</p>
<p><strong>速度较慢</strong>，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区</p></li>
</ul>
<h3 id="epoll">epoll</h3>
<ul>
<li><p>接口</p>
<p><code>epoll_create</code>用于让内核创建一组大小为size的文件描述符集合</p>
<p><code>epoll_ctl</code>用于向内核注册新的描述符或改变某个文件描述符的状态</p>
<p><code>epoll_wait</code>获取事件完成的文件描述符集合</p></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>数据结构</strong>：已注册的描述符在内核中被维护在一棵<strong>红黑树</strong>上，通过回调函数，内核会将I/O已准备好的描述符加入到一个<strong>链表</strong>中管理，通过epoll_wait系统调用就能得到事件完成的文件描述符集合</p></li>
<li><p><strong>触发模式</strong></p>
<p><strong>水平触发level
trigger</strong>：调用epoll_wait检测到描述符事件到达时，将事件通知进程，进程可以不立即处理该事件，下次调用epoll_wait时会再次通知进程</p>
<p><strong>边沿触发edge
trigger</strong>：描述符事件到达后，通知进程，进程必须立即处理事件，否则下次再次调用epoll_wait不会再得到事件到达的通知</p></li>
<li><p>优缺点</p>
<p><strong>优点</strong>：所有文件描述符都存在于内核中，<strong>无需</strong>进行从用户进程缓存到内核缓存的文件描述符集合<strong>拷贝</strong></p>
<p><strong>缺点</strong>：每次<strong>修改</strong>文件描述符状态都需要<strong>通过epoll_ctl()系统调用</strong></p></li>
</ul>
<h3 id="比较">比较</h3>
<ul>
<li><strong>时间精度</strong>：select的时间精度为微秒，而poll和epoll为毫秒，因此<strong>select适用于实时性要求更高的场景</strong></li>
<li><strong>描述符数量限制</strong>：select上限为1024，poll和epoll无限制</li>
<li><strong>文件描述符存储位置</strong>：select和poll存储在用户进程，每次系统调用都需要进行从用户进程缓冲区到内核缓冲区的拷贝，epoll存储在内核。因此如果需要<strong>监听处理大量文件描述符时，使用epoll效率更高</strong></li>
<li><strong>可移植性</strong>：select几乎被所有主流平台所支持，epoll只能运行在linux平台</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/24/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Young">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="元朗食品">
      <meta itemprop="description" content="Talk is cheap, show me the code.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 元朗食品">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/24/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">图解网络笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-24 10:23:21" itemprop="dateCreated datePublished" datetime="2022-03-24T10:23:21+08:00">2022-03-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-08 20:08:32" itemprop="dateModified" datetime="2022-04-08T20:08:32+08:00">2022-04-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Computer-Network/" itemprop="url" rel="index"><span itemprop="name">Computer Network</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="http1.1">HTTP/1.1</h1>
<h2 id="无状态">无状态</h2>
<ul>
<li><p><strong>优点</strong>：服务器不记忆HTTP状态，不需要额外资源记录状态信息，<strong>减轻服务器的负担</strong></p></li>
<li><p><strong>缺点</strong>：进行<strong>关联性操作</strong>时非常麻烦，如对于购物网站，登录、添加购物车、下单、结算、支付等系列操作都需要知道用户身份，若无状态则服务器每次都需要询问身份信息</p></li>
<li><p><strong>Cookie工作原理</strong></p>
<p><strong>Cookie</strong>：服务器发送到浏览器并保存在浏览器本地的一小块数据</p>
<p><strong>Set-Cookie</strong>：服务器发送的HTTP响应报文包含<strong>Set-Cookie首部字段</strong>，字段内容是Cookie的数据</p>
<p><strong>携带Cookie</strong>：浏览器之后向同一服务器再次发起请求时会携带该Cookie数据，并放在HTTP请求报文的<strong>Cookie首部字段</strong></p></li>
</ul>
<h2 id="不安全">不安全</h2>
<ul>
<li><strong>明文</strong>：通信使用明文（不加密），内容可能会被<strong>窃听</strong></li>
<li><strong>无身份验证</strong>：不验证通信方的身份，可能遭遇<strong>伪装</strong></li>
<li><strong>无完整性保护</strong>：无法证明报文的完整性，所以可能遭遇<strong>篡改</strong></li>
</ul>
<h2 id="长连接">长连接</h2>
<ul>
<li><strong>HTTP1.0默认使用短链接</strong>：每个请求-响应对都建立一个TCP连接</li>
<li><strong>HTTP1.1默认使用长连接</strong>：只要任意一端没有明确提出断开连接，则保持TCP连接状态</li>
</ul>
<h2 id="管道传输网络">管道传输网络</h2>
<ul>
<li><strong>管道</strong>：在同一个TCP连接里面，客户端可以发起多个HTTP请求，不必等第一个请求响应，即可发出第二个请求，减少整体响应时间</li>
<li><strong>服务器按顺序处理</strong>：尽管客户端可以发送多个请求，服务器还是按照顺序响应，若前面的响应特别慢，就会导致后面的请求排队等候，称为<strong>队头堵塞</strong></li>
<li><strong>队头堵塞</strong>：顺序发送的请求序列中一个请求因某种原因被阻塞时，后面排队的所有请求
也一同被阻塞</li>
</ul>
<h1 id="https">HTTPS</h1>
<h2 id="http与https的区别">HTTP与HTTPS的区别</h2>
<ul>
<li><strong>加密</strong>：HTTP使用明文传输，存在安全风险；HTTPS在HTTP和TCP之间加入了SSL/TLS安全协议，使得报文能够加密传输</li>
<li><strong>连接建立过程</strong>：HTTP只需要经过TCP三次握手，即可进行HTTP报文传输；HTTPS在TCP三次握手后，还需要进行SSL/TLS握手过程，才可进行加密报文传输</li>
<li><strong>端口号</strong>：HTTP端口号是80，HTTPS端口号是443</li>
<li><strong>认证</strong>：HTTPS协议需要向CA（证书权威机构）申请数字证书，保证服务器身份可信</li>
</ul>
<h2 id="https解决了http的哪些问题">HTTPS解决了HTTP的哪些问题</h2>
<ul>
<li><p>HTTP的安全风险</p>
<p><strong>窃听风险</strong>：HTTP采用明文传输，攻击者可能从通信链路上获取通信内容</p>
<p><strong>篡改风险</strong>：HTTP没有完整性保护，攻击者可能篡改报文信息</p>
<p><strong>冒充风险</strong>：HTTP没有认证，攻击者可能伪造身份</p></li>
<li><p>HTTPS在HTTP与TCP之间加入了SSL/TLS协议，解决了上述风险</p>
<p><strong>加密</strong>：通过混合加密的方式保证信息的机密性，解决了窃听的风险</p>
<p><strong>认证</strong>：通过数字证书签名机制，认证身份</p>
<p><strong>完整性保护</strong>：通过摘要算法，为数据生成独一无二的指纹，校验数据的完整性，解决了篡改的风险</p></li>
</ul>
<h3 id="混合加密">混合加密</h3>
<ul>
<li><strong>非对称加密</strong>：通信建立前采用非对称加密方式交换“会话密钥”</li>
<li><strong>对称加密</strong>：通信过程中使用对称加密的会话密钥加密明文数据</li>
</ul>
<h3 id="摘要算法">摘要算法</h3>
<ul>
<li><strong>发送方计算指纹</strong>：客户端在发送前通过摘要算法算出明文的“指纹”，发送时把“指纹+明文”一同加密后发送</li>
<li><strong>接收方计算指纹并比对</strong>：服务器解密后，用相同的摘要算法算出发送过来的明文的”指纹“，并与客户端携带的”指纹“进行对比，若两者相同则数据完整</li>
</ul>
<h3 id="数字证书">数字证书</h3>
<ul>
<li>公钥不被篡改：通信建立前，客户端需要用服务器发来的公钥对会话密钥进行加密，客户端如何保证该公钥的确是由服务器发送的，且未被篡改呢？</li>
<li><strong>服务器向CA注册</strong>：客户端</li>
<li>与服务器都信任的第三方机构，服务端将自己的公钥注册到CA，CA会用CA私钥对服务端公钥进行加密得到数字签名</li>
<li><strong>CA颁发数字证书</strong>：CA将数字签名与服务器公钥一起放入数字证书，并发送给服务器</li>
<li><strong>服务器发送数字证书</strong>：服务器将CA颁发的数字证书发送给客户端，里面包含服务器公钥，以及CA对该公钥的数字签名</li>
<li><strong>客户端进行认证</strong>：客户端浏览器或操作系统已经内置了CA的公钥，客户收到数字证书后，将数字签名用CA公钥解密，并比对解密后的服务器公钥与数字证书中的服务器公钥是否匹配，若匹配则认证成功</li>
</ul>
<h2 id="ssltls的四次握手过程">SSL/TLS的四次握手过程</h2>
<ul>
<li><p><code>ClientHello</code>：客户端向服务器发起加密通信请求，告诉服务器自己</p>
<p>所支持的<strong>SSL/TLS协议版本</strong></p>
<p>所生成的<strong>随机数</strong>（Client
Random，用于生成会话密钥）</p>
<p>所支持的<strong>密码套件列表</strong>，如RSA加密算法</p></li>
<li><p><code>ServerHello</code>：服务器收到客户端请求后进行响应，包含内容</p>
<p>确认<strong>SSL/TLS协议版本</strong></p>
<p>服务器生成的<strong>随机数</strong>（Server
Random，用于生成会话密钥）</p>
<p>确认<strong>密码套件列表</strong></p>
<p>服务器的<strong>数字证书</strong></p></li>
<li><p><strong>客户端回应</strong>：收到Server
Hello后，客户端通过CA公钥解密数字签名，确认数字证书真实性，认证后从数字证书取出服务器公钥，发送以下信息</p>
<p>经服务器公钥加密的<strong>随机数</strong></p>
<p>加密通信算法改变通知，表示随后信息都将用“会话密钥”加密通信</p>
<p>客户端握手结束通知，表示客户端的握手阶段已结束</p>
<blockquote>
<p>整个握手过程中，客户端和服务器总共生成了<strong>三个随机数</strong>，且双方都知道这三个随机数，它们会用协商的加密算法，各自生成本次通信的会话密钥</p>
</blockquote></li>
<li><p><strong>服务器回应</strong>：服务器收到客户端的第三个随机数后，通过协商的加密算法，计算出本次通信的”会话密钥“，发送以下信息</p>
<p>加密通信算法改变通知</p>
<p>服务器握手结束通知</p></li>
</ul>
<h1 id="http2">HTTP/2</h1>
<h2 id="头部压缩">头部压缩</h2>
<ul>
<li><strong>头部压缩</strong>：如果同时发出多个请求，而其Header是一样或相似的，则协议会帮助消除重复的部分</li>
<li><strong>原理-HPACK算法</strong>：客户端和服务器同时维护一张头信息表，所有字段都会存入这个表并生成一个索引号，以后则不发送同样字段，而是只发送索引号，提高了速度</li>
</ul>
<h2 id="二进制格式">二进制格式</h2>
<ul>
<li><strong>二进制格式</strong>：HTTP/2不再使用纯文本形式的报文，而是采用二进制格式，头部和数据体都是二进制，分别称为header
frame和data frame</li>
<li><strong>优点</strong>：接收方收到报文后，直接解析二进制报文，增加了数据传输效率</li>
</ul>
<h2 id="数据流">数据流</h2>
<ul>
<li><strong>编号</strong>：HTTP/2的每个请求或响应的所有数据包称为一个数据流（Stream），每个<strong>数据流都有唯一的编号</strong></li>
<li><strong>顺序</strong>：数据包不是按顺序发送，同一个连接里的数据包可能属于不同的响应</li>
</ul>
<h2 id="多路复用">多路复用</h2>
<ul>
<li><strong>并发</strong>：HTTP/2可以在一个连接中并发多个请求或响应，不用按顺序一一对应，<strong>解决了队头阻塞问题</strong></li>
</ul>
<h2 id="服务器推送">服务器推送</h2>
<ul>
<li><strong>服务器推送</strong>：浏览器刚请求html时，服务器提前把可能用到的js、css文件等静态资源主动发给客户端</li>
</ul>
<h1 id="http3">HTTP/3</h1>
<h2 id="http2尚存问题">HTTP/2尚存问题</h2>
<ul>
<li><strong>HTTP/1.1的阻塞</strong>：管道传输中的<strong>队头阻塞</strong>，即一个请求阻塞，队列后的请求也统统被阻塞</li>
<li><strong>HTTP/2的阻塞</strong>：多个HTTP请求复用一个TCP连接，一旦发生<strong>丢包</strong>则会触发TCP重传机制，一个TCP连接中的所有HTTP请求都必须等待这个丢了的包被重传回来</li>
</ul>
<h2 id="quic协议">QUIC协议</h2>
<ul>
<li><p><strong>UDP</strong>：HTTP/3的下层使用UDP协议，而不是TCP协议，同时通过基于UDP的QUIC协议实现了类似TCP的可靠传输</p></li>
<li><p><strong>可靠传输</strong>：QUIC实现的可靠传输机制，在某个流发生丢包时，只阻塞这个流，而不会阻塞其他流</p></li>
<li><p><strong>TLS协议版本</strong>：使用TLS1.3</p></li>
<li><p><strong>头部压缩算法</strong>：使用QPack算法</p></li>
<li><p><strong>QUIC三次握手</strong>：HTTPS建立连接时，需要进行TCP三次握手和TLS/1.3的三次握手共<strong>六次握手</strong>，而QUIC将握手过程合并，只需要进行QUIC三次握手</p></li>
</ul>
<h1 id="tcp">TCP</h1>
<h2 id="三次握手">三次握手</h2>
<h3 id="三次握手的详细过程">三次握手的详细过程</h3>
<ul>
<li>客户端发送SYN报文段</li>
<li>服务器回复SYN + ACK报文段</li>
<li>客户端发送ACK报文段</li>
</ul>
<h3 id="为什么不能是两次握手">为什么不能是两次握手</h3>
<ul>
<li><strong>防止历史连接初始化连接</strong>：客户端发送的第一个SYN报文段由于网络拥塞暂时未到达服务器，它又发起了第二个TCP连接，此时服务器收到第一个连接的SYN报文段，并返回SYN+ACK报文段，如果客户端该过期的SYN+ACK报文段，应该发送RST报文段终止该过期连接</li>
<li><strong>防止服务器资源浪费</strong>：若只需两次握手即建立TCP连接，则服务器收到SYN报文段后就建立连接。如果客户端SYN阻塞，则它可能建立多次SYN报文，那么服务器在收到请求后就会建立多个冗余的无效连接，造成资源浪费</li>
</ul>
<h3 id="为什么不是四次握手">为什么不是四次握手</h3>
<ul>
<li><strong>减少通信次数</strong>：可以使用四次握手，即客户端发送SYN，服务器回复ACK，服务器发送SYN，客户端回复ACK，但是可以将服务器发送的SYN与ACK合并为SYN
+ ACK报文段，从而减少通信次数</li>
</ul>
<h3 id="为什么客户端和服务端的初始序列号isn不同">为什么客户端和服务端的初始序列号ISN不同</h3>
<ul>
<li><strong>分辨历史报文</strong>：通信双方能根据序号将不属于本连接的报文段丢弃</li>
<li><strong>安全性</strong>：防止黑客伪造相同序列号的TCP报文段被对方接收</li>
</ul>
<h3 id="ip层会进行分片为什么tcp层还需要mss">IP层会进行分片，为什么TCP层还需要MSS？</h3>
<ul>
<li><strong>MTU</strong>：物理层帧的最大数据长度，对于以太网为1500字节，包含IP头部、TCP头部和TCP数据</li>
<li><strong>MSS</strong>：TCP数据段的最大长度</li>
<li><strong>IP分片</strong>：如果IP层有超过MTU大小的数据要发送，则IP层会对其分片，使得每一分片都小于MTU，目标主机的IP层将分片进行重新组装后再交给TCP</li>
<li><strong>IP分片丢失</strong>：若一个IP分片丢失，则整个IP数据报的所有分片都要重传，<strong>效率较低</strong></li>
<li>因此，TCP层发现数据超过MSS，则先对数据进行分片，保证IP数据报长度不超过MTU，从而避免了IP分片</li>
</ul>
<h3 id="syn攻击是什么如何避免">SYN攻击是什么？如何避免</h3>
<ul>
<li><p><strong>SYN攻击</strong>：TCP连接建立需要三次握手，若攻击者短时间伪造不同IP地址的SYN报文，服务端收到后进入SYN_RCVD状态，并发送SYN+ACK报文段，但该报文段无法得到未知IP地址主机的ACK应答，从而导致这些报文段占满服务端的SYN接收队列，服务器无法正常提供服务</p></li>
<li><p><strong>避免SYN攻击方式一</strong>：设置SYN_RCVD状态连接的最大个数，超出处理能力时，服务器对于新的SYN将直接回复RST报文段以丢弃该连接</p></li>
</ul>
<h4 id="linux的syn队列和accept队列">Linux的SYN队列和Accept队列</h4>
<ul>
<li><p><strong>SYN队列</strong>：收到客户端的SYN报文后，将连接加入SYN队列</p></li>
<li><p><strong>Accpet队列</strong>：发送SYN+ACK报文段，等待客户端回应ACK报文段，收到ACK报文段后，将连接从SYN队列移除，加入Accept队列</p></li>
<li><p><strong>应用调用</strong>：应用通过调用<code>accept()</code>socket接口，从Accept队列取出连接</p></li>
<li><p><strong>Accept队列占满</strong>：如果应用程序过慢，会导致Accept队列被占满</p></li>
<li><p><strong>SYN队列被占满</strong>：不断受到SYN攻击，会导致SYN队列被占满</p></li>
<li><p><strong>避免SYN攻击方式二</strong>：当SYN队列满之后，后续服务器收到SYN包，不进入SYN队列，而是计算一个cookie值作为SYN+ACK报文段的序列号返回客户端，收到客户端的ACK报文段后，讲检查其ACK的合法性，若合法则将该连接直接放入Accept队列</p></li>
</ul>
<h2 id="四次挥手">四次挥手</h2>
<h3 id="四次挥手过程和状态变迁">四次挥手过程和状态变迁</h3>
<ul>
<li>客户端发送FIN报文段，并进入FIN_WAIT1状态</li>
<li>服务器回复ACK报文段，进入CLOSE_WAIT状态、</li>
<li>客户端收到服务器对FIN报文段的ACK，进入FIN_WAIT2状态</li>
<li>服务器处理完已发送的报文段后，发送FIN报文段，进入LAST_ACK状态</li>
<li>客户端收到服务端的FIN报文段，回复ACK报文段，进入TIME_WAIT状态</li>
<li>服务器收到ACK报文段，关闭连接并进入CLOSED状态</li>
<li>客户端在2MSL时间内未收到服务器重传的FIN报文段，断开连接并进入CLOSED状态</li>
</ul>
<h3 id="为什么需要四次挥手">为什么需要四次挥手</h3>
<ul>
<li>客户端和发送方都需要发送FIN报文段，并对对方的FIN报文段回复ACK报文段</li>
<li>而且服务段发送ACK报文段与FIN报文段无法合并，因为通常它需要处理完所有需要发送的报文段后，才能发送FIN报文段</li>
</ul>
<h3 id="为什么time_wait等待的时间是2msl">为什么TIME_WAIT等待的时间是2MSL</h3>
<ul>
<li><p><strong>MSL</strong>：maximum segment
lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃</p></li>
<li><p><strong>等待2MSL</strong>：TIME_WAIT等待2MSL，是因为如果报文段从发送方到接收方最多需要1MSL，接收方回复的报文段到达发送方最多需要1MSL，因此一来一回为2MSL</p></li>
<li><p><strong>重新计时</strong>：若在等待时间内，客户端收到了服务端重传的FIN报文段，则客户端再次发送ACK报文段，且2MSL将重新计时</p></li>
<li><p><strong>Linux系统的MSL</strong>：2MSL默认是60秒，即1MSL是30秒，Linux系统停留在TIME_WAIT的时间为固定的60秒</p></li>
</ul>
<h3 id="为什么需要time_wait状态">为什么需要TIME_WAIT状态</h3>
<ul>
<li><strong>防止旧连接的数据包</strong>：经过2MSL，网络中阻塞的数据包都肯定被丢弃，这样此后同一客户端、服务端在之前的端口号再次发起TCP连接，也不会被上一连接的旧数据包所干扰</li>
<li><strong>保证连接正确关闭</strong>：保证被动关闭连接的一方能够被正确地关闭，即保证最后的ACK能让被动关闭方接收，从而帮助其正常关闭。否则，服务端会一直处于LAST_ACK状态，此时任何客户端向其发起连接，服务段都会回复RST报文段</li>
</ul>
<h3 id="time_wait过多有何危害">TIME_WAIT过多有何危害</h3>
<h4 id="客户端受端口资源限制">客户端受端口资源限制</h4>
<ul>
<li><strong>内存资源占用</strong></li>
<li><strong>端口资源占用</strong>：一个TCP连接至少消耗一个本地端口，如果发起连接一方的TIME_WAIT状态过多，占满了所有端口资源，将导致无法创建新连接</li>
</ul>
<h4 id="服务端受系统资源限制">服务端受系统资源限制</h4>
<ul>
<li>一个TCP连接由四元组标识，理论上服务端可以建立很多连接，它只监听一个端口，并把连接交给处理线程。但由于线程池也无法处理大量的连接，所以服务端出现大量TIME_WAIT时，系统资源被耗尽</li>
</ul>
<h3 id="如果建立连接后客户端故障怎么办">如果建立连接后，客户端故障怎么办？</h3>
<ul>
<li><strong>TCP保活机制</strong>：如果一个时间段内，没有任何连接相关的活动，则启动TCP保活机制。每隔一个时间间隔发送一个探测报文，若连续几个探测报文都没有得到响应，则认为当前的TCP连接已死亡，系统内核将错误信息通知上层应用程序</li>
<li>TCP保活机制的可能情况
<ul>
<li><strong>对端正常工作</strong>，则探测报文能够得到对端正常响应，TCP保活时间被重置</li>
<li><strong>对端崩溃并重启</strong>，此时对端收到探测报文后，将回复RST报文段</li>
<li><strong>对端崩溃或由于其他原因导致报文不可达</strong>，则TCP连续重传探测报文后，将报告该TCP连接已死亡</li>
</ul></li>
</ul>
<h2 id="重传机制">重传机制</h2>
<h3 id="超时重传">超时重传</h3>
<ul>
<li><p><strong>含义</strong>：发送数据时，设定一个定时器，当超过指定时间后，没有收到对方的ACK确认应答报文，就会重发该数据，即超时重传</p></li>
<li><p><strong>原因</strong>：发送方发送的报文段丢失，或接收方回复的应答报文丢失，都可能导致超时重传</p></li>
<li><p><strong>超时时间RTO的设置</strong></p>
<p><strong>RTT</strong>：RTO大小至少为RTT往返时延，即数据从网络一端传送到另一端，并收到另一端的确认应答的时间，即包的<strong>往返时间</strong></p>
<p><strong>RTO设置过大</strong>：重传太慢，效率低，性能差</p>
<p><strong>RTO设置过小</strong>：在没有丢包的情况下就重发，增加了冗余报文，加剧网络拥塞</p>
<p><strong>Linux计算RTO的方法</strong></p>
<ul>
<li><strong>采样RTT时间</strong>，并进行加权平均得到平滑RTT的值</li>
<li><strong>采样RTT的波动范围</strong>，当RTT变化较大时需要增加RTO的值</li>
</ul>
<p><strong>超时重传时RTO的变化</strong>，当发生超时重传时，TCP将RTO加倍，即在网络拥塞的情况下允许更长的等待时间</p></li>
</ul>
<h3 id="快速重传">快速重传</h3>
<ul>
<li><strong>冗余ACK</strong>：接收方对于之前已经确认过的报文段，进行了重复的确认，原因是因为接收方收到了一个乱序的报文，而并未收到所期望的下一个报文</li>
<li><strong>快速重传</strong>：当发送方接收到三个相同的冗余ACK报文时，会立刻重传当前第一个未确认的报文段，而无需等待定时器中断</li>
</ul>
<h3 id="sack方法选择性确认">SACK方法（选择性确认）</h3>
<ul>
<li><strong>SACK</strong>：接收方在TCP头部选项字段加入SACK，将接收缓存的map发送给发送方，发送方从SACK获取哪些数据没收到，只重传丢失的数据</li>
</ul>
<h3 id="d-sack方法duplicate-sack">D-SACK方法（Duplicate SACK）</h3>
<ul>
<li>使用SACK告诉发送方有哪些数据被重复接收了，发送方能根据SACK判断出这些重复接收的报文的ACK报文丢失了，无需重传</li>
</ul>
<h2 id="流量控制">流量控制</h2>
<ul>
<li><p><strong>窗口大小限制发送速率</strong>：发送方无需等待确认应答，可以继续发送数据的最大值</p></li>
<li><p><strong>窗口大小的决定</strong>：TCP首部包含接收窗口字段，<strong>接收方根据自己的缓冲区还能接收多少数据决定</strong>，告诉发送方接收窗口大小</p></li>
<li><p><strong>接收窗口大小为0</strong>：此时发送方仍然需要发送报文段（<strong>窗口探测报文</strong>）并携带1字节数据，这是为了从接收方回复的应答报文中，获取接收窗口大小的变化，否则发送方将一直认为接收窗口为0而不发送报文</p></li>
</ul>
<h2 id="拥塞控制">拥塞控制</h2>
<ul>
<li><strong>慢启动</strong>：拥塞窗口cwnd为1，表示可以发送一个携带MSS字节数据的报文段，每接收1个ACK则cwnd就增加1。当不断增长直至发生超时，则将慢启动阈值设为cwnd/2，并进入拥塞避免状态</li>
<li><strong>拥塞避免</strong>：拥塞窗口cwnd设为慢启动阈值，此后每接收1个ACK则cwnd增加1/cwnd</li>
<li><strong>快速恢复</strong>：当发送方收到3个重复的冗余ACK报文，则进行快速重传，将慢启动阈值设为cwnd/2，cwnd设为慢启动阈值
+
3。快速恢复阶段中，每收到1个冗余ACK则cwnd增加1，若收到一个新的有效ACK，则恢复拥塞避免状态</li>
</ul>
<h1 id="ip协议">IP协议</h1>
<ul>
<li><p><strong>网络层</strong>和<strong>数据链路层</strong>之间的区别和联系</p>
<p>MAC的作用是实现<strong>直连</strong>的两个设备之间的通信，而IP则负责在<strong>没有直连</strong>的两个网络之间进行通信传输</p>
<p>MAC负责<strong>某一个区间</strong>之内的通信传输，而IP负责将数据包发给最终的目的地址</p>
<p>在此过程中，源MAC地址和目标MAC地址一直在<strong>变化</strong>，而源IP地址和目标IP地址在传输过程中<strong>不会改变</strong></p></li>
</ul>
<h2 id="ip地址的分类">IP地址的分类</h2>
<ul>
<li><p><strong>分类</strong>：IP地址划分为5种类型，分别是A类、B类、C类、D类、E类</p>
<p>A类以0开头，地址范围为0.0.0.0-127.255.255.255</p>
<p>B类以10开头，地址范围为128.0.0.0-191.255.255.255</p>
<p>C类以110开头，地址范围为192.0.0.0-223.255.255.255</p>
<p>D类以1110开头，地址范围为224.0.0.0-239.255.255.255</p>
<p>E类以1111开头，地址范围为240.0.0.0-255.255.255.255</p></li>
<li><p><strong>广播地址</strong></p>
<p><strong>主机号全为0</strong>指定某个网络</p>
<p><strong>主机号全为1</strong>指定某个网络下的所有主机，用于广播</p>
<p>广播地址用于在同一个链路中相互连接的主机之间发送数据包</p></li>
<li><p>分类地址的<strong>缺点</strong></p>
<p>同一网络下<strong>没有地址层次</strong></p>
<p>不能很好地与现实网络匹配，因为C类地址只包含254个主机数量，而B类地址包含65534个主机，容易造成<strong>地址浪费</strong></p></li>
</ul>
<h2 id="cidr无分类地址">CIDR无分类地址</h2>
<ul>
<li><strong>网络号+主机号</strong>，32位的IP地址划分为网络号和主机号，<code>a.b.c.d/x</code>，其中<code>/x</code>表示前x位为网络号，x的范围为0-32</li>
<li><strong>子网掩码</strong>：掩盖掉主机号，将IP地址和子网掩码按位相与即可得到网络号，因此子网掩码的高x位为1，低位为0</li>
<li><strong>广播地址</strong>：网络号 + 主机号全为1的地址</li>
</ul>
<h3 id="网络号和主机号分离的原因">网络号和主机号分离的原因</h3>
<ul>
<li><strong>直接交付</strong>：两台计算机通讯，首先应判断是否处于同一个广播域内，若网络号相同，则接收方在本网络上，可以把数据包直接发送到目标主机</li>
</ul>
<h3 id="子网划分">子网划分</h3>
<ul>
<li><p><strong>子网划分</strong>：将主机地址划分为两个部分，子网网络地址和子网主机地址</p>
<p><strong>未做子网划分的IP地址</strong>：网络地址 + 主机地址</p>
<p><strong>做了子网划分的IP地址</strong>：网络地址 + 子网网络地址 +
子网主机地址</p></li>
</ul>
<h2 id="公有ip地址和私有ip地址">公有IP地址和私有IP地址</h2>
<ul>
<li>A、B、C分类地址中，实际上有公有IP地址和私有IP地址</li>
<li><strong>私有IP地址</strong>允许组织内部的IT人员自己管理、自己分配，且<strong>可以重复</strong>，如学校、办公室使用的IP地址常为私有IP地址</li>
<li><strong>公有IP地址</strong>在整个互联网范围内保持<strong>唯一</strong>，由<strong>ICANN</strong>组织统一管理，称为互联网名称与数字地址分配机构</li>
</ul>
<h2 id="ip地址与路由控制">IP地址与路由控制</h2>
<ul>
<li><strong>路由控制表</strong>：网络地址用于进行路由控制，路由控制表记录着网络地址与下一步应该发送到的路由器地址</li>
<li><strong>路由器转发</strong>：根据IP包首部中的目标IP地址，在路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将IP包转发给响应的下一个路由器</li>
<li><strong>最长匹配</strong>：如果路由控制表中存在多条相同网络地址的记录，就选择相同位数最多的网络地址</li>
</ul>
<h3 id="默认路由">默认路由</h3>
<ul>
<li><strong>默认路由</strong>：如果路由控制表中没有找到匹配的项，则数据包被转发到默认路由</li>
</ul>
<h3 id="环回地址">环回地址</h3>
<ul>
<li><strong>环回地址</strong>：在同一台计算机上的程序之间进行网络通信时，使用环回地址，即127.0.0.1。使用环回地址时，数据包不会流向网络</li>
</ul>
<h2 id="ip分片与重组">IP分片与重组</h2>
<ul>
<li><strong>MTU</strong>：数据链路的最大传输单元，如以太网MTU是1500字节，且不同数据链路的MTU常常不同</li>
<li><strong>IP分片</strong>：若IP数据报的大小大于MTU，则会由路由器进行分片，而重组则由目标主机进行</li>
<li><strong>IP分片丢失</strong>：某个分片丢失，将会导致整个IP数据报重传。为此，TCP引入了MSS，在运输层进行分片而不是IP层分片，则某个分组丢失只需要重传该分组即可。对于UDP，尽量不要发送一个大于MTU的数据报文</li>
</ul>
<h2 id="ipv6">IPv6</h2>
<ul>
<li><p>优点</p>
<p><strong>自动配置</strong>，即使没有DHCP服务器也可以实现自动分配IP地址</p>
<p><strong>首部长度固定</strong>为40字节</p>
<p><strong>安全性</strong>提高，具有应对伪造IP地址、防止线路窃听等功能</p></li>
<li><p>标识方法</p>
<p>IPv6地址长度为128位，每16位为1组，共8组，用冒号分隔</p></li>
</ul>
<h1 id="重要协议">重要协议</h1>
<h2 id="dns">DNS</h2>
<ul>
<li><p><strong>域名解析功能</strong>：将域名网址转换为具体的IP地址</p></li>
<li><p><strong>域名的层级关系</strong>：根DNS服务器、顶级域DNS服务器、权威DNS服务器</p></li>
<li><p>域名解析流程</p>
<p>查看<strong>浏览器缓存</strong></p>
<p>查看<strong>操作系统缓存</strong></p>
<p>查看<strong>本机域名解析文件hosts</strong></p>
<p>若均未查到则向<strong>DNS服务器</strong>进行查询：本地DNS服务器（递归查询）、根DNS服务器（迭代查询）、顶级域DNS服务器（迭代）、权威DNS服务器（迭代）</p></li>
</ul>
<h2 id="arp">ARP</h2>
<ul>
<li><p><strong>功能</strong>：根据IP地址获取MAC地址</p></li>
<li><p><strong>ARP协议</strong></p>
<p><strong>ARP请求报文</strong>：将IP地址放入ARP请求，广播发送ARP请求</p>
<p><strong>ARP响应报文</strong>：同一链路的所有设备收到ARP请求时，会比对其中的IP地址与自己的IP地址，若匹配则将自己的MAC地址放入ARP响应报文并返回</p>
<p><strong>操作系统缓存</strong>：操作系统会将ARP获取的MAC地址缓存起来，该缓存有一定期限</p></li>
<li><p><strong>RARP协议</strong>：已知MAC地址，求IP地址</p></li>
</ul>
<h2 id="dhcp">DHCP</h2>
<ul>
<li><p>动态主机配置协议</p>
<p><strong>DHCP
discover报文</strong>：客户端发送DHCP发现报文，由于此时客户端没有IP地址，也不知道DHCP服务器地址，因此目的IP地址设为广播地址255.255.255.255:
67，源地址为0.0.0.0: 68</p>
<p><strong>DHCP offer报文</strong>：DHCP服务器收到DHCP发现报文后，用DHCP
offer报文响应，仍然使用IP广播地址，其中携带可租约的IP地址、子网掩码、默认网关、DNS服务器以及IP地址租用期等</p>
<p><strong>DHCP request报文</strong>：客户端可能收到多个服务器的DHCP
offer报文，从中选择一个，并向选中的服务器发送DHCP请求报文响应，回显配置的参数</p>
<p><strong>DHCP ACK报文</strong>：最后服务器用DHCP
ACK报文进行响应，应答所要求的参数</p></li>
<li><p><strong>DHCP中继代理</strong>：现实中并非每个子网都有一个DHCP服务器，使用DHCP中继代理解决。中继代理收到DHCP发现报文后，以单播的形式将其发送给DHCP服务器，DHCP服务器返回DHCP
offer报文给中继代理，中继代理将该offer报文广播，以发送给DHCP客户端</p></li>
</ul>
<h2 id="nat">NAT</h2>
<ul>
<li><p><strong>网络地址转换</strong>：将私有IP地址转换为公有IP地址</p></li>
<li><p><strong>网络地址与端口转换</strong>，将<strong>IP地址 +
端口号</strong>一起进行转换</p>
<ul>
<li>如某个家庭子网的公有IP地址为120.299.175.121，其主机A具有私有IP地址192.168.1.10、主机B具有私有IP地址192.168.1.11</li>
<li>主机A端口1025和主机B端口1025与远程服务器进行通信，则NAT将其都转换为公有IP地址120.299.175.121，并以<strong>不同的端口号进行区分</strong></li>
<li>NAT路由器转换表</li>
</ul>
<table>
<thead>
<tr class="header">
<th>私有IP地址</th>
<th>公有IP地址</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>192.168.1.10:1025</td>
<td>120.299.175.121:1025</td>
</tr>
<tr class="even">
<td>192.168.1.11:1025</td>
<td>120.299.175.121:1026</td>
</tr>
</tbody>
</table></li>
<li><p><strong>NAT缺点</strong></p>
<p>NAT转换表的生成，转换操作本身都会产生<strong>性能开销</strong></p>
<p>若<strong>NAT路由器重启</strong>，则所有TCP连接都将重置</p></li>
</ul>
<h2 id="icmp">ICMP</h2>
<ul>
<li><p><strong>名称</strong>：互联网控制报文协议</p></li>
<li><p><strong>功能</strong>：确认IP数据报是否成功送达目标地址、报告发送过程中IP数据报被丢弃的原因、改善网络设置等</p></li>
<li><p>类型</p>
<p><strong>查询报文类型</strong>：用于诊断的查询消息</p>
<p><strong>差错报文类型</strong>：通知出错原因的错误消息</p></li>
</ul>
<h1 id="ping的工作原理">ping的工作原理</h1>
<h2 id="icmp协议">ICMP协议</h2>
<ul>
<li><p><strong>功能</strong></p>
<p>报告IP数据报是否送达目的地址</p>
<p>报告IP数据报被丢弃的原因</p>
<p>改善网络设置</p></li>
<li><p>ICMP报文格式</p>
<p>ICMP报文封装在<strong>IP数据报</strong>，工作在网络层</p></li>
<li><p>类型</p>
<p><strong>查询报文类型</strong>：用于诊断的查询消息，包括</p>
<ul>
<li>0 <strong>回送应答</strong></li>
<li>8 <strong>回送请求</strong></li>
</ul>
<p><strong>差错报文类型</strong>：通知出错原因，包括</p>
<ul>
<li>3
<strong>目标不可达</strong>，又可细分为：网络不可达、主机不可达、协议不可达、端口不可达、需要进行分片但设置了不分片位</li>
<li>4 <strong>原点抑制</strong>，为了缓解网络拥堵</li>
<li>5
<strong>重定向或改变路由</strong>，路由器发现发送端主机使用了非最优路径发送数据时，通过ICMP重定向消息告知主机最合适的路由信息</li>
<li>11
<strong>超时</strong>，当IP数据报的<strong>TTL字段变为0时</strong>该IP数据报将被丢弃，路由器发送ICMP超市消息给发送端主机</li>
</ul></li>
</ul>
<h2 id="ping查询报文类型的使用">ping—查询报文类型的使用</h2>
<ul>
<li><p>ICMP报文字段</p>
<p><strong>类型字段</strong>：0或8</p>
<p><strong>标识符</strong>：区分哪个应用程序发送ICMP包，如用进程PID作为标识符</p>
<p><strong>序号</strong>：每发送一个新的ICMP回送请求则递增</p>
<p><strong>选项</strong>：常存放发送请求的时间值，用于计算往返时间</p></li>
<li><p><strong>ICMP回送请求</strong>：源主机生成ICMP回送请求消息，包含<strong>类型字段为8</strong>、序号字段、发送时间等，并交给IP层发送给目的主机</p></li>
<li><p><strong>ICMP回送响应</strong>：目的主机构建ICMP回送响应消息数据包，包含<strong>类型字段为0</strong>、序号字段（与接收的ICMP回送请求序号一致），并交付给IP层发送给源主机</p></li>
<li><p><strong>是否可达</strong>：规定时间内，源主机收到ICMP回送响应，则目标主机可达；否则，目标主机不可达</p></li>
<li><p><strong>往返时延</strong>：源主机利用发送时间和接收时间可以计算往返时延RTT</p></li>
</ul>
<h2 id="traceroute差错报文类型的使用">traceroute—差错报文类型的使用</h2>
<h3 id="作用一追踪去往目的地时沿途经过的路由器">作用一：追踪去往目的地时沿途经过的路由器</h3>
<ul>
<li>发送端主机不断发送UDP报文段，设置端口号为不可能的端口号，IP数据包的<strong>TTL从1</strong>开始不断递增</li>
<li>若未达到目的主机将返回<strong>ICMP超时消息</strong>，若达到主机将返回<strong>ICMP端口不可达消息</strong></li>
</ul>
<h3 id="作用二确定路径的mtu">作用二：确定路径的MTU</h3>
<ul>
<li><strong>设置分片禁止标志位</strong>：发送端主机发送IP数据报时，将IP首部的分片禁止标志位设置为1，则沿途的路由器在需要进行分片时不会对IP数据报进行分片，而是直接丢弃</li>
<li><strong>ICMP不可达消息</strong>：通过ICMP不可达消息将数据链路上<strong>MTU的值</strong>返回给发送主机</li>
<li><strong>调整包大小</strong>：发送主机端收到ICMP不可达消息后即调整包的大小，最终得到能到达目标主机的合适的MTU</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/18/Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Young">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="元朗食品">
      <meta itemprop="description" content="Talk is cheap, show me the code.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 元朗食品">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/18/Redis/" class="post-title-link" itemprop="url">Redis</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-18 23:08:51" itemprop="dateCreated datePublished" datetime="2022-03-18T23:08:51+08:00">2022-03-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-08 20:08:32" itemprop="dateModified" datetime="2022-04-08T20:08:32+08:00">2022-04-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="问题">问题</h1>
<ul>
<li>Redis应用场景有哪些？</li>
<li>为什么需要使用缓存？</li>
<li>Redis支持的数据类型有哪些？底层数据结构是什么?</li>
<li>为什么说Redis是单线程模型？它由哪几部分组成？</li>
<li>Redis不使用多线程的原因是什么？Redis6.0后引入多线程是为了解决什么问题？</li>
<li>Redis为什么需要设置过期机制？</li>
<li>Redis如何判断数据过期？</li>
<li>Redis如何删除过期数据？该策略有何问题？</li>
<li>Redis的内存淘汰机制是怎样的？常用的策略是什么？</li>
<li>Redis的持久化机制目的是什么？</li>
<li>Redis持久化方式有哪两种？</li>
<li>Redis事务由哪些命令组成？redis事务与关系型数据库的事务有何区别？</li>
<li>Redis缓存穿透是什么？如何解决该问题？</li>
<li>Redis缓存雪崩是什么?如何解决?</li>
<li>缓存读写策略有哪几种？Redis采取哪种？</li>
<li>单机redis有何缺点？为什么要使用redis集群？</li>
<li>redis集群有几种实现模式？</li>
<li>redis主从模式是怎样的？有何优点？有何缺点？</li>
<li>redis哨兵模式中，哨兵集群有何作用？该模式有何优点？有何缺点？</li>
<li>redis自研模式中，客户端分片是怎样的，代理分片是怎样的，分别有何优点、缺点？</li>
<li>redis cluster模式中
<ul>
<li>分片是怎样实现的？什么是一致性哈希技术？什么是虚拟slot技术？</li>
<li>redis cluster结构是怎样的？</li>
<li>redis bus的作用是什么?</li>
<li>节点交互的配置信息包括哪些？</li>
</ul></li>
<li>redis主从架构中数据会丢失吗？如何解决？</li>
<li>redis集群的主从复制过程是怎样的？</li>
<li>什么是分布式锁？有何实现方案？</li>
<li>redis实现分布式锁的方案是怎样的？</li>
<li>RedLock算法是怎样的？</li>
</ul>
<h1 id="redis应用场景">Redis应用场景</h1>
<h2 id="缓存">缓存</h2>
<ul>
<li><p><strong>缓存</strong>：Redis常用作缓存，因为它是内存数据库，读写速度非常快</p></li>
<li><p><strong>缓存数据的处理流程</strong></p>
<p><strong>查找缓存</strong>：如果用户请求的数据在缓存中就直接返回</p>
<p><strong>查找数据库</strong>：如果用户请求的数据在数据库中，则更新缓存数据并返回</p>
<p><strong>返回空数据</strong>：如果数据库中也不存在该数据，则返回空数据</p></li>
<li><p>为什么要用缓存？</p>
<p><strong>高性能</strong>：从内存中的缓存读取数据，比从磁盘读取数据更快</p>
<p><strong>高并发</strong>：诸如MySQL的数据库的QPS大概在1w左右，而使用Redis缓存则可达10w以上</p>
<blockquote>
<p>QPS: Query Per Second，服务器每秒可以执行的查询次数</p>
</blockquote></li>
</ul>
<h2 id="其他">其他</h2>
<ul>
<li>分布式锁</li>
<li>限流</li>
<li>消息队列</li>
</ul>
<h1 id="redis支持五种数据类型">Redis支持五种数据类型</h1>
<h2 id="string">string</h2>
<ul>
<li><strong>字符串类型</strong>：Redis构建了简单动态字符串SDS类型，可以保存二进制数据，获取字符串长度的复杂度为<span class="math inline">\(O(1)\)</span></li>
<li><strong>常用命令</strong>：set、get、strlen、exists、decr、incr、setex</li>
<li><strong>应用场景</strong>：计数，如统计用户访问次数、文章点赞转发数量</li>
</ul>
<h3 id="普通字符串操作">普通字符串操作</h3>
<ul>
<li><p><strong>设置键值对</strong>：set key value</p></li>
<li><p><strong>根据key获取值</strong>：get key</p></li>
<li><p><strong>判断某个key是否存在</strong>：exists key</p></li>
<li><p><strong>返回key存储的字符串值的长度</strong>：strlen key</p></li>
<li><p><strong>删除某个key对应的值</strong>：del key</p></li>
</ul>
<h3 id="计数器">计数器</h3>
<ul>
<li>字符串内容为<strong>整数</strong>时可以使用</li>
<li><strong>递增</strong>：incr number</li>
<li><strong>递减</strong>：decr number</li>
</ul>
<h3 id="过期">过期</h3>
<ul>
<li><strong>设置过期时间</strong>：expire key
60，设置数据在60s后过期</li>
<li><strong>同时设置数据值和过期时间</strong>：setex key 60 value</li>
</ul>
<blockquote>
<p>setex = <a href="#set">set</a> + [ex]pire</p>
</blockquote>
<ul>
<li><strong>查询过期时间</strong>：ttl key，返回还有多少秒过期</li>
</ul>
<h2 id="list">list</h2>
<ul>
<li><strong>链表类型</strong>：Redis实现的list是双向链表，支持反向查找和遍历</li>
<li><strong>常用命令</strong>：rpush、lpush、rpop、lpop、lrange、llen等</li>
<li><strong>应用场景</strong>：发布与订阅、消息队列、慢查询</li>
</ul>
<h3 id="队列">队列</h3>
<ul>
<li>通过rpush、lpop实现队列</li>
</ul>
<h3 id="栈">栈</h3>
<ul>
<li><p>通过rpush、rpop实现栈</p></li>
<li><p>lrange可以查询对应下表范围的列表元素</p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lrange myList 0 1</span><br><span class="line"># 查询链表中下标从0到1(包括1)的元素</span><br></pre></td></tr></table></figure>
<ul>
<li>llen查看链表长度</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llen myList</span><br></pre></td></tr></table></figure>
<h2 id="hash">hash</h2>
<ul>
<li><strong>哈希表类型</strong>：内部实现为数组+链表，类似JDK1.8之前的HashMap，常用于存储对象</li>
<li><strong>常用命令</strong>：hset、hmset、hexists、hget、hgetall、hkeys、hvals等</li>
<li><strong>应用场景</strong>：系统中<strong>对象数据</strong>的存储</li>
</ul>
<h2 id="set">set</h2>
<ul>
<li><p><strong>无序集合类型</strong>：类似于Java中的HashSet</p></li>
<li><p><strong>常用命令</strong>：sadd、spop、smembers、sismember、scard、sinterstore、sunion</p></li>
<li><p><strong>应用场景</strong>：需要存放数据不能重复，且需要获取多个数据源交集、并集的场景</p></li>
<li><p><strong>交集</strong>：sinterstore set1 set2
set3，求set2与set3的交集，并存放在set1中</p></li>
<li><p><strong>并集</strong>：sunion set1
set2，求set1与set2的并集</p></li>
</ul>
<h2 id="sorted-set">sorted set</h2>
<ul>
<li><p><strong>zset类型</strong>：与set相比，增加了一个权重参数score，使得集合的元素能按score进行有序排列，还可以通过score的范围获取元素列表</p></li>
<li><p><strong>常用命令</strong>：zadd、zcard、zscore、zrange、zrevrange、zrem等</p></li>
<li><p><strong>应用场景</strong>：对数据根据某个权重进行排序的场景，如直播系统中的礼物排行榜等</p></li>
</ul>
<h2 id="bitmap">bitmap</h2>
<ul>
<li><strong>bitmap类型</strong>：存储连续的二进制数字，只需要1个bit就可以表示某个元素对应的值或状态，key就是对应元素本身</li>
<li><strong>常用命令</strong>：setbit、getbit、bitcount、bitop</li>
<li><strong>应用场景</strong>：保存状态信息，如是否签到、是否登录，并进一步对这些信息进行分析的场景</li>
</ul>
<h3 id="统计活跃用户">统计活跃用户</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setbit 20220319 1 1		# id为1的用户在20220319活跃</span><br><span class="line">setbit 20220319 2 1		# id为2的用户在20220319活跃</span><br><span class="line">setbit 20220320 1 1		# id为1的用户在20220320活跃</span><br><span class="line">bitop and desk1 20220319 20220320</span><br><span class="line">bitcount desk1			# 20220319和20220310都活跃的人数</span><br><span class="line">bitop or desk2 20220319 20220320</span><br><span class="line">bitcount desk2			# 任意一天活跃的人数</span><br></pre></td></tr></table></figure>
<h1 id="redis单线程模型">Redis单线程模型</h1>
<h2 id="reactor模式">Reactor模式</h2>
<ul>
<li><strong>两种体系</strong>：处理Web请求时，通常有两种体系结构，分别是thread-based
architecture，event-driven architecture</li>
</ul>
<h3 id="thread-based结构">thread-based结构</h3>
<ul>
<li><p><strong>每个请求一个线程</strong>：每接收到一个请求，便开启一个独立的线程处理</p></li>
<li><p><strong>适用场景</strong>：并发访问量不大的场景，因为线程需要占用一定的内存资源，且操作系统在线程之间的切换也需要一定的开销，线程数过多时会降低web服务器的性能</p></li>
</ul>
<h3 id="event-driven结构">event-driven结构</h3>
<ul>
<li><p><strong>事件</strong>：状态的改变，如tcp中socket的new incoming
connection、ready for read、ready for write</p></li>
<li><p><strong>事件处理器</strong>：用于响应特定事件的发生，服务端接受连接与对事件的处理分离</p></li>
</ul>
<h3 id="reactor">reactor</h3>
<ul>
<li><p><strong>reactor设计模式</strong>：event-driven
architecture的一种实现方式</p>
<ul>
<li><p><strong>并发请求</strong>：处理多个客户端并发的向服务端请求服务的场景</p></li>
<li><p><strong>服务由多个方法组成</strong>：每种服务在服务端可能由多个方法组成</p></li>
<li><p><strong>解耦服务、分发给事件处理器</strong>：reactor解耦并发请求的服务，并分发给对应的事件处理器处理</p></li>
</ul></li>
<li><p><strong>角色</strong>：文件描述符、同步时间分离器、初始分发器、事务处理器、具体的事务处理器</p>
<ul>
<li><strong>文件描述符</strong> handle</li>
<li><strong>同步事件分离器</strong> Synchronous Event
Demultiplexer，本质上是系统调用，如linux中的select、poll、epoll</li>
<li><strong>初始分发器</strong> Initiation
Dispatcher，即reactor角色，提供了注册、删除、转发event
handler的方法</li>
<li><strong>事务处理器</strong> Event Handler</li>
<li><strong>具体的事务处理器</strong> Concrete Event
Handler，实现具体的业务逻辑</li>
</ul></li>
</ul>
<h2 id="redis单线程模型-1">Redis单线程模型</h2>
<ul>
<li><p><strong>Redis的事件处理模型</strong>：Redis的文件事件处理器，它是以单线程方式运行的</p></li>
<li><p>Redis如何监听大量客户端连接？</p>
<p><strong>IO多路复用程序</strong>：redis使用IO多路复用监听多个socket，并根据socket目前执行的任务为socket关联不同的事件处理器</p>
<p><strong>事件驱动程序</strong>：Redis服务器是一个事件驱动程序，服务器需要处理文件事件、时间事件。当socket准备好执行accept、read、write、close等操作时，对应的文件事件就会发生，文件事件处理器就会调用socket之前关联的事件管理器来处理这些事件</p>
<p><strong>文件事件处理器</strong>以单线程方式运行，但通过I/O多路复用程序监听多个套接字，实现了高性能的网络通信模型，又很好地与Redis服务器中其他同样以单线程方式运行的模块对接</p></li>
<li><p><strong>文件事件处理器的组成</strong></p>
<ul>
<li><p><strong>多个socket</strong>：客户端连接</p></li>
<li><p><strong>IO多路复用程序</strong></p></li>
<li><p><strong>文件事件分派器</strong>，将socket关联到相应的事件处理器</p></li>
<li><p><strong>事件处理器</strong>：accept处理器、命令请求处理器、命令回复处理器等</p></li>
</ul></li>
</ul>
<h2 id="redis为何不使用多线程">Redis为何不使用多线程？</h2>
<ul>
<li><strong>易于维护</strong>：单线程编程简单，且易于维护</li>
<li><strong>性能瓶颈</strong>：Redis的性能瓶颈不在CPU，而在<strong>内存和网络</strong></li>
<li><strong>死锁、上下文切换</strong>：多线程存在以上问题</li>
</ul>
<h2 id="redis6.0后引入了多线程的原因">Redis6.0后引入了多线程的原因</h2>
<ul>
<li><strong>提高网络IO读写性能</strong>：Redis引入多线程主要为了提高网络IO读写性能</li>
<li>Redis只在网络数据读写等耗时操作上使用了多线程，而执行命令仍然是单线程顺序执行的</li>
</ul>
<h1 id="redis的过期机制">Redis的过期机制</h1>
<ul>
<li><strong>目的</strong>：防止内存耗尽，如果缓存中的所有数据一直保存，则最终会导致out
of memory</li>
</ul>
<h2 id="redis如何判断数据过期">Redis如何判断数据过期？</h2>
<ul>
<li><p><strong>过期字典</strong>：保存数据过期的时间，可看作哈希表，键指向Redis数据库中的某个键，值是一个long
long类型的整数，保存了key所指向的数据库键的过期时间</p></li>
<li><p>过期字典存储在<code>redisDb</code>结构体的<code>expires</code>变量中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    dict *dict;     <span class="comment">//数据库键空间,保存着数据库中所有键值对</span></span><br><span class="line">    dict *expires   <span class="comment">// 过期字典,保存着键的过期时间</span></span><br><span class="line">    ...</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="过期数据的删除策略">过期数据的删除策略</h2>
<ul>
<li><strong>惰性删除</strong>：在取出key时对数据进行过期检查，对CPU友好，但可能会导致大量过期key没被删除</li>
<li><strong>定期删除</strong>：每隔一段时间则抽取一批key，删除其中的过期键，对内存友好</li>
<li><strong>Redis策略：定期删除 + lazy删除</strong></li>
</ul>
<h2 id="redis内存淘汰机制">Redis内存淘汰机制</h2>
<ul>
<li><p><strong>目的</strong>：redis采用定期删除 +
lazy删除策略，但仍有可能漏掉许多过期key，导致内存空间耗尽，为此redis引入了内存淘汰机制</p></li>
<li><p><strong>数据淘汰机制</strong></p>
<p><strong>volatile-lru</strong>：从已设置过期时间的数据淘汰最近最少使用的数据</p>
<p><strong>volatile-ttl</strong>：从已设置过期时间的数据集中挑选将要过期的数据淘汰</p>
<p><strong>volatile-random</strong>：从已设置过期时间的数据集中任意选择数据淘汰</p>
<p><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，移除最近最少使用的key（<strong>最常用策略</strong>）</p>
<p><strong>allkeys-random</strong>：从数据集中任意选择数据淘汰</p>
<p><strong>no-eviction</strong>：禁止驱逐数据，当内存不足以容纳新数据时则报错</p>
<p><strong>volatile-lfu</strong>：从已设置过期时间的数据淘汰最不经常使用的数据</p>
<p><strong>allkeys-lfu</strong>：当内存不足以容纳新数据时，移除最不经常使用的键</p></li>
</ul>
<h1 id="redis持久化机制">Redis持久化机制</h1>
<ul>
<li><p><strong>目的</strong>：持久化数据，即将内存中的数据写入磁盘，从而在系统故障后仍然可以恢复数据</p></li>
<li><p><strong>Redis支持两种持久化方式</strong>：快照RDB、只追加文件AOF</p></li>
<li><p><strong>快照持久化</strong>：创建快照，获取存储在内存中的数据在某个时间点上的副本</p>
<ul>
<li><strong>备份快照</strong>：创建快照后可对快照进行备份，将快照复制到其他服务器从而创建具有相同数据的服务器副本</li>
<li><strong>数据恢复</strong>：快照留在原地可用于重启服务器时的数据恢复</li>
</ul></li>
<li><p><strong>只追加文件持久化</strong></p>
<p><strong>AOF文件</strong>：每执行一条改变数据的命令，就会将该命令写入到内存缓存中，并在某时刻同步到硬盘中的AOF文件</p>
<p><strong>三种AOF持久化方式</strong>（从内存缓存写入AOF文件的时机）</p>
<ul>
<li>每次数据修改时都写入AOF文件</li>
<li>每秒同步一次，将多个命令同步到硬盘的AOF文件中（常用）</li>
<li>操作系统决定何时同步</li>
</ul></li>
</ul>
<h1 id="redis事务">Redis事务</h1>
<ul>
<li><p><strong>MULTI命令</strong>：开始事务，此后输入的多个命令不会立刻执行，而是放入队列中（FIFO）</p></li>
<li><p><strong>EXEC命令</strong>：执行事务</p></li>
<li><p><strong>DISCARD命令</strong>：取消事务</p></li>
<li><p><strong>WATCH命令</strong>：监听指定的键，调用exec命令执行事务时，若一个被watch命令监听的键被修改，则事务不会执行</p></li>
<li><p><strong>redis事务与关系型数据库的事务区别</strong></p>
<p>redis事务不支持rollback，因而不具备原子性，也不满足持久性</p></li>
</ul>
<h1 id="缓存穿透">缓存穿透</h1>
<ul>
<li><p><strong>含义</strong>：大量请求的key不存在于缓存中，导致请求直接到数据上</p></li>
<li><p><strong>场景</strong>：攻击者故意对不存在缓冲中的key发起大量请求</p></li>
<li><p>解决方法</p>
<p><strong>参数校验</strong>：对于不合法参数的请求应抛出异常信息</p>
<p><strong>缓存无效key</strong>：如果缓存和数据库都查不到某个key的数据，则写一个到redis中并设置过期时间</p>
<p><strong>布隆过滤器</strong>：把所有可能存在的请求的值都存放在布隆过滤器中，用户请求时先判断用户发来的请求的值是否存在于布隆过滤器中，不存在则返回错误参数信息，存在才继续查询缓存</p>
<ul>
<li><strong>先查询布隆过滤器，再查询缓存</strong></li>
<li><strong>误判</strong>：布隆过滤器认为一个数据存在，它可能不存在；但布隆过滤器认为数据不存在，则一定不存在</li>
</ul></li>
</ul>
<h1 id="缓存雪崩">缓存雪崩</h1>
<ul>
<li><p>含义</p>
<p><strong>缓存在同一时间大面积失效</strong>：缓存在同一时间大面积失效，导致后面的请求都直接落在数据库上，数据库在短时间内承受大量请求（如系统缓存的某个模块宕机不可用）</p>
<p><strong>多个热点缓存在某一时刻失效</strong>：同样地，可能导致大量请求直接落在数据库上</p></li>
<li><p><strong>Redis服务不可用</strong>的解决方法</p>
<p><strong>采用redis集群</strong>，避免单机出现问题导致整个缓存服务不可用</p>
<p><strong>限流</strong>，避免同时处理大量请求</p></li>
<li><p><strong>热点缓存失效</strong>的解决方法</p>
<p><strong>设置不同的失效时间</strong>，如随机设置缓存失效时间</p>
<p><strong>设置缓存永不失效</strong></p></li>
</ul>
<h1 id="缓存读写策略">缓存读写策略</h1>
<h2 id="旁路缓存模式">旁路缓存模式</h2>
<ul>
<li><p><strong>写策略</strong>：先更新数据库，然后<strong>删除缓存</strong></p></li>
<li><p><strong>读策略</strong>：先从缓存读数据；若读不到则从数据库读数据，并更新缓存</p></li>
<li><p><strong>一致性问题</strong></p>
<ul>
<li><p>写数据的过程中可以<strong>先删除缓存，再更新数据库</strong>吗？</p>
<p>不行。可能造成数据库和缓存数据不一致问题，如（1）请求1把缓存中的A数据删除（2）请求2从数据库读取数据（3）请求1更新数据库。这样，请求2便无法读取到比自己早执行的请求1写入的数据</p></li>
<li><p>写数据<strong>先更新数据库，再删除缓存</strong>便没有一致性问题吗？</p>
<p>仍然存在。（1）请求1从数据库读取数据，（2）请求2写数据A到数据库，并删除缓存的A数据，（3）请求1将数据A写入缓存。这样，请求2往数据库写入了新数据，但缓存中仍然保留着旧数据</p></li>
<li><p>解决办法</p>
<p><strong>要求强一致性</strong>：更新数据库的同时更新缓存，但需要加<strong>分布式锁</strong>保证更新缓存时不能存在线程安全问题</p>
<p><strong>允许短暂不一致</strong>：更新数据时同样更新缓存，给缓存加一个较短的过期时间</p></li>
</ul></li>
<li><p><strong>缺点</strong></p>
<ul>
<li>首次请求数据一定不在cache中（解决：先将热点数据提前放入cache中）</li>
<li>写操作比较频繁的话，导致cache中的数据被频繁删除，影响缓存命中率</li>
<li>数据不一致问题</li>
</ul></li>
</ul>
<h2 id="读写穿透模式">读写穿透模式</h2>
<ul>
<li><p><strong>缓存视作主要数据存储</strong>：服务端把缓存视为主要数据存储，从中读取数据并将数据写入其中，缓存负责从数据库读取数据，将数据写入数据库</p></li>
<li><p><strong>写策略</strong>：先查缓存，若缓存则存在则更新缓存，缓存服务自己负责更新数据库；若缓存不存在则更新数据库</p></li>
<li><p><strong>读策略</strong>：读缓存，若存在则直接返回；若不存在则从数据库加载，写入缓存后返回</p></li>
<li><p><strong>特点</strong>：在旁路缓存模式中，若读请求的数据不在缓存中，由应用程序自己访问数据库读取并写入缓存；而在读写穿透模式，若读请求的数据不在缓存中，则缓存服务自己会从数据库读取数据并写入缓存，这一过程对用户是透明的</p></li>
<li><p><strong>缺点</strong>：首次请求数据一定不在缓存（解决：把热点数据提前放入缓存）</p></li>
</ul>
<h2 id="异步缓存写入模式">异步缓存写入模式</h2>
<ul>
<li>与读写穿透共同点：由<strong>缓存服务负责更新缓存和数据库的读写</strong></li>
<li>与读写穿透的不同：读写穿透同步更新缓存和数据库，异步缓存写入模式则<strong>只更新缓存</strong>，不直接更新数据库，而是以<strong>异步批量的方式更新数据库</strong></li>
<li><strong>优点</strong>：读写性能高</li>
<li><strong>缺点</strong>：一致性更差</li>
</ul>
<h1 id="redis集群">redis集群</h1>
<ul>
<li>redis单机的缺点：服务器宕机导致服务不可用；性能瓶颈，内存限制了处理能力</li>
<li>redis集群方案：主从模式、哨兵模式、自研、Clustert模式</li>
</ul>
<h2 id="redis主从模式">redis主从模式</h2>
<ul>
<li><p><strong>复制功能</strong>：在master数据库中的数据更新后，自动将更新的数据同步到slave数据库上，即主从模式的redis集群</p></li>
<li><p><strong>优点</strong></p>
<p><strong>高可靠性</strong>，master数据库故障后，可以切换到slave数据库</p>
<p><strong>读写分离</strong>，slave数据库可以扩展master数据库节点的都能力，应对大并发量的读操作</p></li>
<li><p><strong>缺点</strong></p>
<p><strong>不具备自动容错和恢复能力</strong>，主节点故障，
从节点需要<strong>手动</strong>升为主节点</p></li>
</ul>
<h2 id="redis哨兵模式">redis哨兵模式</h2>
<ul>
<li><p><strong>哨兵集群作用</strong></p>
<p><strong>监控运行状态</strong>：监控所有服务器是否正常运行，除监控主服务器、从服务器外，哨兵服务器也相互监控</p>
<p><strong>故障切换</strong>：哨兵检测到master宕机后，会自动将slave切换成master，通过发布订阅模式通知其他从服务器，修改配置文件让其切换master。旧master若从故障恢复后将成为新master的slave服务器</p></li>
<li><p><strong>优点</strong>：解决了主从模式中master故障不能自动切换的问题</p></li>
<li><p><strong>缺点</strong></p>
<p><strong>浪费资源</strong>，集群里所有节点都保存全量数据</p>
<p><strong>切换时间</strong>，主节点宕机后，投票选举结束前，redis会开启保护机制，禁止写操作，直至产生新的redis主机</p>
<p><strong>写操作性能瓶颈</strong>，只有master节点可以执行写请求</p></li>
</ul>
<h2 id="redis自研模式">redis自研模式</h2>
<ul>
<li>各个开发者为了解决redis哨兵模式的问题，自研的redis集群方案</li>
</ul>
<h3 id="客户端分片">客户端分片</h3>
<ul>
<li><p><strong>分片逻辑</strong>：在redis客户端实现，通过预定义的路由规则将对key的访问转发到不同的redis实例中</p></li>
<li><p><strong>路由规则</strong>：对key求哈希值</p></li>
<li><p><strong>优点</strong>：redis实例之间彼此独立，相互无关联，易于扩展，系统灵活性强</p></li>
<li><p><strong>缺点</strong></p>
<p><strong>redis群拓扑结构变化</strong>：客户端sharding不支持动态增删节点，服务端redis实例群拓扑结构变化时，每个客户端都需要更新调整</p>
<p><strong>运维成本</strong>：运维成本较高，集群的数据出了任何问题都需要运维人员和开发人员一起解决</p>
<p><strong>客户端维护分片逻辑</strong>：不同的客户端需要编写和维护多套相同的逻辑</p></li>
</ul>
<h3 id="代理分片">代理分片</h3>
<ul>
<li><strong>目的</strong>：redis实例群拓扑结构变化时，<strong>不需要客户端更新调整</strong>，而是由代理分片完成</li>
<li><strong>实现</strong>：<strong>代理分片</strong>将客户端分片模块单独分出来，作为redis客户端和服务端的桥梁</li>
<li><strong>优点</strong>：解决了服务端redis实例群拓扑结构变化时，每个客户端需要更新调整的问题</li>
<li><strong>缺点</strong>：redis客户端的请求都经过代理才能到达redis服务器，<strong>性能损失</strong></li>
</ul>
<h2 id="redis-cluster模式">redis cluster模式</h2>
<h3 id="redis哈希槽">Redis哈希槽</h3>
<ul>
<li><p><strong>一致性哈希</strong>技术</p>
<p><strong>圆环</strong>：一致性哈希将范围抽象为一个圆环，对key计算hash值后对<span class="math inline">\(2^{32}\)</span>取模，则值的范围在<span class="math inline">\([0,2^{32}-1]\)</span>之间</p>
<p><strong>分配</strong>：将redis示例均匀分布在圆环上，通过上述方法计算key的哈希值后找到其在圆环的位置，然后将其分配到该位置按顺时针旋转的下一个redis实例。若redis实例故障，则继续按顺时针旋转直到找到下一个正常redis实例</p>
<p><strong>缺点</strong>：redis实例节点较少时，节点变化将导致数据倾斜，即部分节点数据过多，部分节点数据过少</p>
<p><strong>虚拟节点</strong>：与真实节点一起分布在圆环上，而且每个虚拟节点都会映射到某个真实节点中</p></li>
<li><p><strong>虚拟槽</strong>技术</p>
<p><strong>槽数量</strong>：redis集群一共有<span class="math inline">\(2^{14}=16384\)</span>个槽</p>
<p><strong>槽范围</strong>：所有的master节点都有一个槽范围，槽数是可以迁移的。master节点的从节点不分配槽，只拥有读权限</p>
<p><strong>分配</strong>：计算key的哈希值，然后对16384取模得到对应的槽位，然后根据槽找到对应的节点</p>
<p><strong>更方便地添加和移除节点</strong></p>
<ul>
<li>增加节点时，只需要把其他节点的某些哈希槽挪到新节点即可</li>
<li>移除节点时，只需要把移除节点上的哈希槽分配到其他节点即可，不需要停止redis任何节点的服务</li>
<li>如果使用一致性哈希技术，则增加和移除节点都需要rehash</li>
</ul></li>
</ul>
<h3 id="redis-cluster结构">redis cluster结构</h3>
<ul>
<li><p><strong>结构</strong>：可以看作多个主从架构结合在一起</p>
<ul>
<li>redis推荐redis
cluster至少包含三个主节点，每个主节点至少有一个从节点，即三主三从六个节点</li>
<li>每组节点都可看做一个主从模式，且负责不同的slot</li>
</ul></li>
<li><p><strong>主备复制</strong>：与主从模式类似，master库数据更新后，将自动同步到slave库上</p></li>
<li><p><strong>对外服务</strong>：外部对redis进行读写操作时，必须访问master进行写操作，可以访问slave进行读操作</p></li>
<li><p><strong>Redis bus</strong></p>
<p><strong>去中心化</strong>：redis
cluster是一个去中心化的架构，不存在统一的配置中心，redis
cluster的每个节点都保存了集群的配置信息</p>
<p><strong>配置信息交互</strong>：节点之间通过redis cluster
bus完成配置信息的交互，最终达成一致性</p>
<p><strong>PING/PONG</strong>：配置信息的一致性主要依靠PING/PONG，每个节点向其他节点频繁地周期性地发送PING/PONG消息，每次PING/PONG都随机携带一部分节点信息，由于交互频繁，短时间内的几次交互后集群状态会达成一致</p>
<p><strong>交互信息</strong>包括</p>
<ul>
<li><strong>数据分片slot和节点的对应关系</strong></li>
<li><strong>集群中每个节点的可用状态</strong></li>
<li><strong>集群结构变更信息</strong>，数据分片的迁移、主备切换、单点master的发现等都会导致集群结构变化</li>
</ul></li>
</ul>
<h2 id="redis主从架构会发生数据丢失吗">redis主从架构会发生数据丢失吗</h2>
<ul>
<li><p><strong>异步复制同步丢失</strong>：redis主节点和从节点的复制是异步的，若主节点的数据未完全复制到从节点，主节点就发生了宕机，则主节点内存中的数据会丢失</p></li>
<li><p><strong>split
brain问题</strong>：一个集群中产生多个主节点，如由于网络原因，集群出现了分区，master与slave节点之间的联系断开，哨兵检测后认为主节点故障，重新选举某个从节点为主节点。而旧的主节点并未故障，客户端仍在其上写数据，当旧的主节点被降为从节点后，会同步新的主节点数据，导致此前客户端写入旧主节点的数据丢失</p></li>
<li><p><strong>解决</strong>：通过设定配置参数，规定至少有x个slave与master的同步复制延迟时间不超过y秒，若不满足该条件则master暂不接受任何客户端请求（降低系统的可用性换取数据一致性）</p></li>
</ul>
<h2 id="redis集群的主从复制过程">redis集群的主从复制过程</h2>
<ul>
<li><p>步骤</p>
<p><strong>设置服务器的地址和端口号</strong></p>
<p><strong>建立套接字连接</strong>：建立主从服务器之间的连接</p>
<p><strong>发送PING命令</strong>：检验套接字是否可用</p>
<p><strong>身份验证</strong></p>
<p><strong>同步</strong>：从master库向slave库同步数据，分为全量复制、部分复制</p>
<p><strong>命令传播</strong>：当同步后主从数据库状态一致，此后若主服务器接受并执行新的写命令，则将该命令发送给从节点，从节点也接收并执行命令，保证主从节点数据的一致性</p></li>
<li><p>全量复制与部分复制</p>
<p><strong>全量复制</strong>：用于<strong>初次复制</strong>或无法进行部分复制的情况，将主节点的所有数据都发送给从节点</p>
<p><strong>部分复制</strong>：用于网络中断恢复后的复制，只将中断期间主节点执行的写命令发送给从节点，更加<strong>高效</strong></p></li>
<li><p>redis如何保证主从服务器一致</p>
<p><strong>心跳检测机制</strong>：命令传播阶段，slave利用心跳检测机制，定时向主服务器发送消息</p></li>
<li><p><strong>网络问题</strong>导致主从复制过程中停止复制会怎样？</p>
<p><strong>断点续传</strong>：网络重新连接后，接着上次复制的地方继续复制，而不是重新复制</p>
<p><strong>replication
buffer</strong>：master库连接的每一个slave库对应一个replication
buffer，master库执行完每一个操作命令后，将命令分别写入每一个从库对应的replication
buffer</p>
<p><strong>replication
backlog</strong>：一个<strong>环形</strong>区域，记录master库写入的位置和slave库读取的位置</p>
<p><strong>master_repl_offset</strong>：记录master库写入记录的偏移量</p>
<p><strong>slave_repl_offset</strong>：记录slave库读取记录的偏移量</p>
<blockquote>
<p>开始时两者相等，当master写入命令时master_repl_offset递增，slave读取命令时master_repl_offset递增，因此两者之间的命令就是从库未复制的命令记录</p>
</blockquote></li>
</ul>
<h1 id="redis的分布式问题">redis的分布式问题</h1>
<h2 id="什么是分布式锁">什么是分布式锁</h2>
<ul>
<li><p><strong>锁的作用</strong>：同步，保证共享资源在同一时刻只能被同一线程访问</p></li>
<li><p><strong>分布式锁</strong>：保证分布式场景下，共享资源在同一时刻只能被同一线程访问，或是用来控制分布式系统之间同步访问共享资源</p></li>
<li><p>分布式锁的特性</p>
<p><strong>互斥性</strong>：任意时刻，同一条数据只能被一台机器上的一个线程执行</p>
<p><strong>高可用性</strong>：部分节点宕机后，客户端仍可以正常地获取锁和释放锁</p>
<p><strong>独占性</strong>：加锁和解锁必须在同一服务器执行，不能在一个服务器上加锁，在另一个服务器上解锁</p>
<p><strong>防锁超时</strong>：如果客户端没有主动释放锁，服务器会在一定时间后自动释放锁，防止客户端宕机或网络异常导致宕机</p></li>
</ul>
<h2 id="分布式锁的实现方法">分布式锁的实现方法</h2>
<ul>
<li><p>基于<strong>关系型数据库</strong></p></li>
<li><p>基于<strong>redis</strong></p>
<p><strong>优点</strong>：性能好，实现方便</p>
<p><strong>缺点</strong>：key的过期时间设置难以确定；redis集群并非强一致性</p></li>
<li><p>基于<strong>zookeeper</strong></p>
<p><strong>优点</strong>：解决了单点问题、不可重入问题、非阻塞问题以及锁无法释放问题，实现简单</p>
<p><strong>缺点</strong>：性能上不如使用缓存实现分布式锁</p></li>
</ul>
<h2 id="redis如何实现分布式锁">Redis如何实现分布式锁</h2>
<ul>
<li><p><strong>SETNX命令</strong>：该命令的作用是，当key不存在时设置key的值，当key存在时则不进行任何操作</p></li>
<li><p><strong>简单流程</strong></p>
<p><strong>实现</strong>：SETNX获取锁，若获取成功则执行业务，然后删除锁并结束</p>
<p><strong>问题</strong>：如执行业务时代码<strong>异常</strong>，导致无法删除锁，则其他线程也无法获取锁</p></li>
<li><p>改进方案1：try-catch-finally</p>
<p><strong>实现</strong>：将删除锁操作放在finally代码块中，保证出现异常时也能释放锁</p>
<p><strong>问题</strong>：若执行业务时<strong>宕机</strong>，则仍然无法删除锁</p></li>
<li><p>改进方案2：<strong>给锁设置过期时间</strong></p>
<p><strong>问题</strong>：线程1获取锁时设置了过期时间，但若执行业务时间超过了该过期时间，则锁到期释放后线程1仍在执行。若此时线程2获取了锁并开始执行业务，而线程1此后执行结束并删除锁，会导致线程2获取的锁被释放</p></li>
<li><p>改进方案3</p>
<p><strong>给锁加上标识UUID</strong>：每个线程获取锁时都会生成一个不同的UUID作为锁的标识，删除锁时，锁的标识和自己生成的UUID相等时才进行删除操作</p>
<p><strong>守护线程</strong>：加锁时设置一个预估的过期时间，并开启守护线程，定时检测锁的失效时间，若快要过期而访问共享资源的操作还未完成，则守护线程对该锁进行续期，重设过期时间</p>
<p><strong>尚存在的问题</strong>：不具备可重入性（同一线程可以重复获取锁）</p></li>
<li><p>改进方案4：<strong>重入计数</strong></p>
<p><strong>实现</strong>：对锁进行重入计数，加锁时加1，解锁时减1，当计数归零时才释放锁</p>
<p><strong>尚存问题</strong>：若线程获取锁失败后，它如何得知该锁被释放而再次获取？</p></li>
<li><p>改进方案5：轮询/发布订阅</p>
<p><strong>轮询</strong>：客户端轮询，即周期性地检测是否可以获取锁，消耗服务器资源</p>
<p><strong>redis的发布订阅功能</strong>：线程获取锁失败时，<strong>订阅锁释放消息</strong>；线程获取锁并执行业务完成后，释放锁时<strong>发送锁释放消息</strong></p></li>
<li><p>改进方案6：<strong>多节点redis的分布式锁——RedLock算法</strong></p></li>
</ul>
<h2 id="redlock算法">RedLock算法</h2>
<ul>
<li><p><strong>客户端获取锁</strong></p>
<ul>
<li><strong>时间戳</strong>：获取当前时间戳</li>
<li><strong>获取锁</strong>：在redis实例中按顺序获取锁，在所有实例中使用相同的键名和随机值，<strong>锁的获取时间</strong>设置为比锁的过期时间短得多（如果一个redis实例不可用，应尽快尝试下一个redis实例）</li>
<li><strong>获取成功</strong>：客户端在超过一半的实例中获得锁，则认为获取锁成功</li>
<li><strong>有效时间</strong>：锁的有效时间为锁初始设置的过期时间，减去锁的获取时间</li>
<li><strong>获取失败</strong>：若客户端无法成功获取锁（无法在超过一半的redis实例中获取锁，或锁的有效时间为负数），则尝试解锁所有redis实例</li>
</ul></li>
<li><p><strong>失败重试</strong></p>
<p>如果无法获取锁，则客户端在<strong>随机时间</strong>后重试</p></li>
<li><p><strong>释放锁</strong></p>
<p>尝试释放所有实例的锁，无需考虑是否释放成功（删除时会判断这个锁是否由自己设置，避免释放其他客户端上设置的锁）</p></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/18/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Young">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="元朗食品">
      <meta itemprop="description" content="Talk is cheap, show me the code.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 元朗食品">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/18/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" class="post-title-link" itemprop="url">编程规范</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-18 22:55:11" itemprop="dateCreated datePublished" datetime="2022-03-18T22:55:11+08:00">2022-03-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-08 20:08:32" itemprop="dateModified" datetime="2022-04-08T20:08:32+08:00">2022-04-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" itemprop="url" rel="index"><span itemprop="name">编程规范</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/16/%E7%BA%A2%E9%BB%91%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Young">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="元朗食品">
      <meta itemprop="description" content="Talk is cheap, show me the code.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 元朗食品">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/16/%E7%BA%A2%E9%BB%91%E6%A0%91/" class="post-title-link" itemprop="url">红黑树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-16 16:25:25" itemprop="dateCreated datePublished" datetime="2022-03-16T16:25:25+08:00">2022-03-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-08 20:08:32" itemprop="dateModified" datetime="2022-04-08T20:08:32+08:00">2022-04-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="应用">应用</h1>
<ul>
<li>STL中的map和set的底层数据结构均为红黑树</li>
</ul>
<h1 id="特点">特点</h1>
<p><strong>颜色</strong>：每个节点要么是红色，要么是黑色</p>
<p><strong>根节点和叶节点</strong>：根节点和叶节点（nil
node）都是黑色</p>
<p><strong>红色节点的子节点</strong>：红色节点的子节点必定为黑色</p>
<p><strong>路径黑色节点数相等</strong>：任意节点到其子树的叶节点的所有路径上，都具有相同数量的黑色节点</p>
<h2 id="补充">补充</h2>
<p><strong>额外存储空间</strong>：每个节点都需要一个比特存储其颜色信息</p>
<p><strong>最长路径与最短路径的关系</strong>：最长路径长度不超过最短路径长度的两倍</p>
<ul>
<li>最长路径：从根节点到nil节点上总是黑红相间</li>
<li>最短路径：从根节点到nil节点上全为黑色节点</li>
</ul>
<h1 id="时间复杂度">时间复杂度</h1>
<p>插入、删除、查找：<span class="math inline">\(O(logN)\)</span></p>
<h1 id="旋转">旋转</h1>
<ul>
<li><p>旋转不会破坏节点的有序性，时间复杂度<span class="math inline">\(O(1)\)</span></p></li>
<li><p>左旋</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">LeftRotate</span>(Tree T, Node x) &#123;</span><br><span class="line">    <span class="comment">// set y</span></span><br><span class="line">	Node y = x.right;</span><br><span class="line">	x.right = y.left;</span><br><span class="line">    <span class="comment">// trun y&#x27;s left subtree into x&#x27;s right subtree</span></span><br><span class="line">	<span class="keyword">if</span> (y.left != T.nil)</span><br><span class="line">		y.left.p = x;</span><br><span class="line">    <span class="comment">// link x&#x27;s parent to y</span></span><br><span class="line">	y.p = x.p			</span><br><span class="line">	<span class="keyword">if</span> x.p == T.nil</span><br><span class="line">		T.root = y</span><br><span class="line">	elseif x == x.p.left</span><br><span class="line">		x.p.left = y</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		x.p.right = y</span><br><span class="line">    <span class="comment">// put x on y&#x27;s left</span></span><br><span class="line">	y.left = x;</span><br><span class="line">	x.p = y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>右旋</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RightRotate</span>()</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="插入">插入</h1>
<h2 id="策略">策略</h2>
<ul>
<li><strong>总是插入红色节点</strong>：插入节点并将其涂为红色，如果其<strong>父节点为黑色，则无需其他操作</strong></li>
<li><strong>recolor和rotate</strong>：通过recolor和rotate各个节点以满足红黑树约束</li>
</ul>
<h2 id="种情况">4种情况</h2>
<ul>
<li><p><strong>插入的是根节点</strong>：直接将其recolor为黑色</p></li>
<li><p><strong>插入节点的uncle是红色</strong></p>
<p><strong>recolor</strong>:
parent和uncle改为黑色，grandparent为红色</p></li>
<li><p><strong>插入节点的uncle是黑色（三角形）</strong></p>
<p><strong>三角形</strong>：三角形指parent是left child，新节点是right
child；或parent是right child，新节点是left child的情况</p>
<p><strong>在parent上旋转</strong>：通过旋转使得三角形转化为直线的情况</p></li>
<li><p><strong>插入节点的uncle是黑色（直线）</strong></p>
<p><strong>直线</strong>：parent是left child，新节点也是left
child；或parent是right child，新节点也是right child</p>
<p><strong>在grandparent节点上进行旋转后recolor</strong></p></li>
</ul>
<h2 id="示例">示例</h2>
<p><img src="/2022/03/16/%E7%BA%A2%E9%BB%91%E6%A0%91/RBTree.png"></p>
<ul>
<li><strong>插入</strong>：插入红色节点10，其父节点为红色节点9，因此需要调整</li>
<li><strong>情况2，uncle是红色，recolor</strong>:
uncle是红色时，将uncle和parent调整为黑色，并将grandparent调整为红色。此时grandparent12为红色，
其parent15为红色， 因此需要继续调整</li>
<li><strong>情况3，uncle是黑色的triangle情况，rotate on
parent</strong>：节点12的uncle是黑色，且与parent形成三角形，则在parent上进行右旋，12变为15的parent</li>
<li><strong>情况4，uncle是黑色的line情况，rotate on
grandparent</strong>：节点15的uncle是黑色，且与parent12形成直线，则在grandparent上进行左旋，12变为8的parent</li>
<li><strong>recolor</strong>：此时将12涂为黑色，将8涂为红色，即可满足要求</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/16/Modern-C++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Young">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="元朗食品">
      <meta itemprop="description" content="Talk is cheap, show me the code.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 元朗食品">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/16/Modern-C++/" class="post-title-link" itemprop="url">Modern C++</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-16 09:37:46" itemprop="dateCreated datePublished" datetime="2022-03-16T09:37:46+08:00">2022-03-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-08 20:08:32" itemprop="dateModified" datetime="2022-04-08T20:08:32+08:00">2022-04-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="型别推导">型别推导</h1>
<h2 id="模板类型推导">1 模板类型推导</h2>
<ul>
<li>函数模板形如</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="paramtype是个指针或引用不是万能引用">ParamType是个指针或引用（不是万能引用）</h3>
<ul>
<li>类型实参的引用性会被忽略</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;</span><br><span class="line"><span class="built_in">f</span>(x);	<span class="comment">// T为int, ParamType为int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);	<span class="comment">// T为const int, ParamType为const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cr);	<span class="comment">// T为const int, ParamType为const int&amp;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;</span><br><span class="line"><span class="built_in">f</span>(x);	<span class="comment">// T为int, ParamType为const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);	<span class="comment">// T为int, ParamType为const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cr);	<span class="comment">// T为int, ParamType为const int&amp;</span></span><br></pre></td></tr></table></figure>
<h3 id="paramtype是个万能引用">ParamType是个万能引用</h3>
<ul>
<li>类型实参是左值则推导为左值引用，则T和ParamType都会被推导为左值引用</li>
<li>类型实参是右值，T的类型会应用情况1的规则，ParamType被推导为右值引用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;</span><br><span class="line"><span class="built_in">f</span>(x);	<span class="comment">// T为int&amp;, ParamType为int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);	<span class="comment">// T为const int&amp;, ParamType为const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cr);	<span class="comment">// T为const int&amp;, ParamType为const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">27</span>);	<span class="comment">// T为int, ParamType为int&amp;&amp;</span></span><br></pre></td></tr></table></figure>
<h3 id="paramtype既非指针也非引用">ParamType既非指针也非引用</h3>
<ul>
<li>按值传递，param是传入实参的一个副本</li>
<li>参数的引用类型将被忽略</li>
<li>参数的const类型也将被忽略</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;</span><br><span class="line"><span class="built_in">f</span>(x);	<span class="comment">// T为int, ParamType为int</span></span><br><span class="line"><span class="built_in">f</span>(cx);	<span class="comment">// T为int, ParamType为int</span></span><br><span class="line"><span class="built_in">f</span>(cr);	<span class="comment">// T为int, ParamType为int</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果是指向常量对象的常量指针作为实参，则<strong>顶层const忽略，底层const保留</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> ptr = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">f</span>(ptr);		<span class="comment">// T和paramType被推导为const char*</span></span><br></pre></td></tr></table></figure>
<h2 id="auto类型推导">2 auto类型推导</h2>
<h3 id="类型修饰词非指针非引用">类型修饰词非指针非引用</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">27</span>;		<span class="comment">// int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cx = x;	<span class="comment">// const int</span></span><br></pre></td></tr></table></figure>
<h3 id="类型修饰词是指针或引用但非万能引用">类型修饰词是指针或引用，但非万能引用</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; rx = x;	<span class="comment">// const int&amp;</span></span><br></pre></td></tr></table></figure>
<h3 id="类型修饰词是万能引用">类型修饰词是万能引用</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; r1 = x;		<span class="comment">// int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; r2 = cx;		<span class="comment">// const int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; r3 = <span class="number">27</span>;		<span class="comment">// int&amp;&amp;</span></span><br></pre></td></tr></table></figure>
<h3 id="auto类型推导的不同点">auto类型推导的不同点</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">int</span> x1 = &#123;<span class="number">27</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> x2&#123;<span class="number">27</span>&#125;;		<span class="comment">// 都将得到值为27的int变量</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">27</span>;		<span class="comment">// int</span></span><br><span class="line"><span class="keyword">auto</span> x1 = &#123;<span class="number">27</span>&#125;;		<span class="comment">// std::initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="keyword">auto</span> x2&#123;<span class="number">27</span>&#125;;		<span class="comment">// std::initializer_list&lt;int&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>auto声明变量的初始化表达式用大括号括起时，推导得到的类型是<code>std::initializer_list</code></li>
</ul>
<h2 id="decltype类型推导">3 decltype类型推导</h2>
<ul>
<li>绝大多数情况会直接得到变量或表达式的类型</li>
<li>对于类型为T的左值表达式，若表达式仅有一个名字，则得到类型<code>T</code>，否则得到类型<code>T&amp;</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">28</span>;</span><br><span class="line"><span class="comment">// decltype(x)得到类型int, 因为仅包含一个名字x</span></span><br><span class="line"><span class="comment">// decltype(x + 27)得到类型int&amp;</span></span><br><span class="line"><span class="comment">// 特别地, decltype((x))也得到类型int&amp;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>decltype(auto)</code>作为函数返回值类型，按decltype的规则根据返回表达式进行推导</li>
</ul>
<h1 id="auto">auto</h1>
<h2 id="当auto推导的类型不符合要求时使用带显式型别的初始化物习惯用法">6
当auto推导的类型不符合要求时，使用带显式型别的初始化物习惯用法</h2>
<ul>
<li><strong>隐形的代理类型</strong>可以导致auto根据初始化表达式推导出错误的型别，如<code>std::vector&lt;bool&gt;</code>的下标表达式返回<code>std::vector&lt;bool&gt;::reference</code>，而非<code>bool&amp;</code></li>
<li>带显式型别的初始化物习惯用法强制auto推导出你想要的型别</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> highPriority = <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(<span class="built_in">features</span>(w)[<span class="number">5</span>]);</span><br></pre></td></tr></table></figure>
<h1 id="modern-c">Modern C++</h1>
<h2 id="创建对象时注意区分和">7 创建对象时注意区分()和</h2>
<ul>
<li>{}适用范围更宽泛，可以阻止隐式窄化类型转换</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> c_;</span><br><span class="line">    <span class="keyword">int</span> x_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">T</span>(<span class="keyword">int</span> c, <span class="keyword">int</span> x): <span class="built_in">c_</span>(c), <span class="built_in">x_</span>(x) &#123;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">t1</span><span class="params">(<span class="number">1</span>, <span class="number">3.0</span>)</span></span>;	<span class="comment">// 通过</span></span><br><span class="line">T t2&#123;<span class="number">1</span>, <span class="number">3.0</span>&#125;;	<span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure>
<ul>
<li>只要有<strong>任何可能</strong>，<strong>大括号</strong>初始化就会与带有<code>std::initializer_list</code>类型的形参匹配，即使其他重载版本有着更加匹配的形参表</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">T</span>(<span class="keyword">int</span> i, <span class="keyword">bool</span> b);</span><br><span class="line">    <span class="built_in">T</span>(<span class="keyword">int</span> i, <span class="keyword">double</span> d);</span><br><span class="line">    <span class="built_in">T</span>(std::initializer_list&lt;<span class="keyword">bool</span>&gt; il);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">T t&#123;<span class="number">10</span>, <span class="literal">true</span>&#125;;	</span><br><span class="line"><span class="comment">// 会匹配std::initializer_list版本, 而且因为要求窄化型别转换会导致编译错误</span></span><br></pre></td></tr></table></figure>
<h2 id="优先选用nullptr而非0或null">8 优先选用nullptr，而非0或NULL</h2>
<ul>
<li>0和NULL都非指针类型</li>
</ul>
<h2 id="优先选用别名声明而非typedef补充">9
优先选用别名声明，而非typedef（补充）</h2>
<ul>
<li>typedef不支持模板化，但别名声明支持</li>
</ul>
<h2 id="优先选用限定作用域的枚举类型而非不限作用域的枚举类型">10
优先选用限定作用域的枚举类型，而非不限作用域的枚举类型</h2>
<ul>
<li>优先使用<code>enum class</code>而非<code>enum</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enum Color &#123; black, white, red &#125;;</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Color</span> &#123;</span> black, white, red &#125;;</span><br></pre></td></tr></table></figure>
<p><strong>限定作用域的枚举类型不会泄露名字</strong>：必须使用<code>Color::red</code></p>
<p><strong>限定作用域的枚举类型不允许枚举量进行隐式类型转换</strong>：<code>enum</code>版本允许枚举量隐式转换为整数，造成不必要的错误</p>
<h2 id="为意在改写的函数添加override声明">12
为意在改写的函数添加override声明</h2>
<ul>
<li><p><strong>改写override需要满足的要求</strong></p>
<p><strong>虚函数</strong>：基类中的函数必须是虚函数</p>
<p><strong>名字相同</strong>：基类和派生类中的函数名字必须完全相同</p>
<p><strong>形参类型相同</strong>：基类和派生类中的函数的形参类型必须完全相同</p>
<p><strong>函数常量性相同</strong>：基类和派生类的函数常量性必须完全相同（const限定符）</p>
<p><strong>函数返回值兼容</strong></p>
<p><strong>函数引用限定词相同</strong>：<code>&amp;</code>限定了只能通过左值调用成员函数，<code>&amp;&amp;</code>限定了只能通过右值调用成员函数</p></li>
<li><p><code>override</code><strong>声明的作用</strong>：只有在成员函数加上<code>override</code>声明，编译器才会检查它是否改写了基类的虚函数，若没有改写则报错</p></li>
<li><p><code>&amp;</code>限定词与<code>&amp;&amp;</code>限定词</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DataType&amp; <span class="title">data</span><span class="params">()</span> &amp; </span>&#123; <span class="keyword">return</span> values; &#125;				<span class="comment">// 返回左值</span></span><br><span class="line"></span><br><span class="line"><span class="function">DataType <span class="title">data</span><span class="params">()</span> &amp;&amp; </span>&#123; <span class="keyword">return</span> std::<span class="built_in">move</span>(values); &#125;	<span class="comment">// 返回右值</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="保证const成员函数的线程安全性">16
保证const成员函数的线程安全性</h2>
<ul>
<li><strong>保证const成员函数的线程安全性</strong>：const成员函数可能使用缓存，因此实际上会修改声明为mutable的成员变量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例: 多项式类, 其中roots成员函数用于计算该多项式的根, 结果缓存在rootVals中</span></span><br><span class="line"><span class="comment">// 缓存根：由于求根不会改变多项式, 因此该成员声明为const, 但为了防止重复计算, 我们对根使用了缓存, 并将变量设为mutable, 从而可在const限定的roots成员函数中修改缓存</span></span><br><span class="line"><span class="comment">// 问题：如果两个线程同时进行求根, 则可能引发问题, 虽然由于roots是const成员函数, 但实际上它会修改缓存内容, 为此必须使用std::mutex保证const成员函数的线程安全性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polynomial</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RootsType <span class="title">roots</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!rootsAreValid) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            rootsAreValid = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rootVals;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> rootsAreValid&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="keyword">mutable</span> RootsType rootVals&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="智能指针">智能指针</h1>
<h2 id="shared_ptrunique_ptr和weak_ptr">shared_ptr、unique_ptr和weak_ptr</h2>
<ul>
<li>unique_ptr实现的是专属所有权的语义，它是个只移类型，不能复制或共享，unique_ptr大小等同于一个指针</li>
<li>shared_ptr采用引用计数，大小等同于两个指针，一个用于指向所共享的对象，另一个指向包含引用计数的共享控制块</li>
<li>weak_ptr是结合shared_ptr使用的特例智能指针，它提供对shared_ptr所共享对象的访问，但不参与引用计数</li>
</ul>
<h2 id="shared_ptr的线程安全性">shared_ptr的线程安全性</h2>
<ul>
<li><code>shared_ptr</code>包含两个指针，一个指向<strong>所共享的对象</strong>，一个指向引用<strong>计数器所在的内存</strong>，<code>shared_ptr</code>的操作都涉及对这两个指针的修改，操作不具有原子性。因此多线程修改<code>shared_ptr</code>时应该通过<code>std::mutex</code>保证线程安全性</li>
</ul>
<h1 id="右值引用移动语义和完美转发">右值引用、移动语义和完美转发</h1>
<h2 id="理解stdmove和stdforward">23 理解std::move和std::forward</h2>
<ul>
<li><strong>强制类型转换</strong>：std::move不进行任何移动，std::forward不进行任何转发，它们不生成任何可执行代码，而是只执行强制类型转换的函数</li>
<li><strong>std::move</strong>：无条件地将实参强制转换成<strong>右值</strong>，它并不进行移动，也不保证经过强制类型转换后的对象具备可移动能力，它只保证结果是个右值</li>
<li><strong>std::forward</strong>：仅在某个<strong>特定条件</strong>满足时才执行右值强制转换，即传入的实参被绑定到右值时才进行向右值的强制转换</li>
<li><strong>作用</strong>：std::move常用于为移动操作做铺垫，而std::forward常用作传递或转发一个对象到另一个对象</li>
<li>std::move实现具体原理
<ul>
<li><strong>引用折叠</strong>：通过引用折叠原理，T&amp;&amp;类型参数，传入右值实参将得到右值，传入左值实参将得到左值</li>
<li><strong>移除引用</strong>：通过remove_reference移除引用，得到具体类型T</li>
<li><strong>强制转换</strong>：通过static_cast显式转换得到T&amp;&amp;右值引用类型</li>
</ul></li>
</ul>
<h2 id="区分万能引用和右值引用">24 区分万能引用和右值引用</h2>
<ul>
<li>T&amp;&amp;：有两种含义，右值引用或万能引用（绑定到左值时为左值引用，绑定到右值时为右值引用）</li>
<li><strong>万能引用：函数模板的形参</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;		<span class="comment">// param是个万能引用</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>万能引用：auto声明</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1;		<span class="comment">// var2是个万能引用</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>右值引用</strong>：如果T&amp;&amp;形式，没有涉及类型推导，则为右值引用</li>
</ul>
<h2 id="针对右值引用实施stdmove针对万能引用实施stdforward">25
针对右值引用实施std::move，针对万能引用实施std::forward</h2>
<ul>
<li>右值引用实施std::move，万能引用实施std::forward</li>
<li>若局部对象可能适用于返回值优化RVO，则不应实施std::move或std::forward</li>
</ul>
<h2 id="避免使用万能引用类型进行函数重载">26
避免使用万能引用类型进行函数重载</h2>
<ul>
<li><strong>避免使用万能引用类型作为函数参数</strong>：万能引用作为重载函数的形参类型，几乎总会让该重载版本在始料未及的情况下被调用</li>
<li><strong>避免使用完美转发构造函数</strong>：对于非常量的左值类型，一般会形成比复制构造函数的更佳匹配</li>
</ul>
<h2 id="理解引用折叠">28 理解引用折叠</h2>
<ul>
<li><strong>引用折叠发生的语境</strong>：模板实例化、auto类型生成、typedef和别名声明，decltype</li>
<li><strong>引用折叠</strong>：编译器在引用折叠语境下生成引用的引用，结果会变为单个引用。若原始的引用中存在任意一个为左值引用，则结果为左值引用；否则，为右值引用</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86-%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Young">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="元朗食品">
      <meta itemprop="description" content="Talk is cheap, show me the code.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 元朗食品">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86-%E7%B4%A2%E5%BC%95/" class="post-title-link" itemprop="url">数据库原理-索引</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-10 23:54:04" itemprop="dateCreated datePublished" datetime="2022-03-10T23:54:04+08:00">2022-03-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-08 20:08:32" itemprop="dateModified" datetime="2022-04-08T20:08:32+08:00">2022-04-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="basic">Basic</h1>
<ul>
<li><p>引入</p>
<p>如果我们想在A市范围内寻找<strong>名为张伟且年龄为98岁</strong>的男子，我有一个包含A市所有人信息的登记表</p>
<ul>
<li>假如该登记表杂乱无章，那只能从头开始核对登记表的每个人，直到找到符合的人的信息<code>O(N)</code></li>
<li>如果该登记表按名字拼音顺序排列，则可以快速地定位到Z开头的部分，找到张姓的部分，并找到张伟，然后逐个核对直到找到符合的人的信息<code>O(logN)</code></li>
<li>如果翻动登记表时，突然掉出了一张纸，里面记录了A市所有年龄为98岁的人，在登记表中的页号与行号，而且总共只有10个人年龄是98岁，则我可以非常迅速地分别找到这10个人的信息，并找到张伟<code>O(C)</code></li>
</ul></li>
<li><p>索引产生的<strong>原因</strong></p>
<p>许多时候，查询只涉及文件的一小部分记录，如</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> name<span class="operator">=</span>&quot;Amy&quot;</span><br></pre></td></tr></table></figure>
<p>倘若为此搜寻数据库的每一条记录，则查询效率低下，因此引入了索引</p></li>
<li><p>索引的<strong>作用</strong></p>
<p>建立记录的属性或属性集到记录之间的映射关系，可以通过某个属性或某几个属性组成的属性集快速定位到具有此属性
(集) 值的记录</p></li>
<li><p>索引的<strong>搜索码</strong></p>
<p>用于在文件中查找记录的属性或属性集。如果一个文件上有多个索引，则它有多个搜索码</p></li>
<li><p>索引的<strong>种类</strong></p>
<ul>
<li><strong>顺序索引</strong>：基于<strong>值的顺序</strong>排序</li>
<li><strong>散列索引</strong>：基于将值平均分布到若干<strong>桶</strong>中，一个值所属的桶是由<strong>散列函数</strong>决定的</li>
</ul></li>
<li><p>索引的<strong>评价标准</strong></p>
<ul>
<li>支持的访问类型</li>
<li>访问时间</li>
<li>插入时间</li>
<li>删除时间</li>
<li>空间开销</li>
</ul></li>
</ul>
<h1 id="顺序索引">顺序索引</h1>
<ul>
<li><strong>顺序索引</strong>：按照排好的<strong>顺序存储搜索码的值</strong>，并将每个搜索码与包含该搜索码的记录关联起来</li>
<li><strong>聚集索引/主索引</strong>：搜索码定义了文件的次序</li>
<li><strong>非聚集索引/辅助索引</strong>：搜索码指定的次序与文件的排列次序不同的索引</li>
<li><strong>索引项或索引记录</strong>：由一个<strong>搜索码值</strong>和<strong>指针</strong>组成，指针指向具有该搜索码的一个或多条记录，指针由&lt;磁盘块标识，块内偏移量&gt;组成</li>
</ul>
<h2 id="稠密索引与稀疏索引">稠密索引与稀疏索引</h2>
<ul>
<li><p><strong>稠密索引</strong>：每个搜索码值都有一个索引项</p></li>
<li><p><strong>稀疏索引</strong>：只有部分搜索码值有索引项，索引是聚集索引时才能使用稀疏索引</p></li>
<li><p>比较</p>
<ul>
<li><strong>稠密索引</strong>的查找<strong>速度更快</strong></li>
<li><strong>稀疏索引</strong>占用的<strong>空间更小</strong>，所需的插入和删除时的维护开销也较小</li>
</ul></li>
<li><p>常用方案</p>
<p><strong>为每个块建立一个索引项的稀疏索引</strong>，因为查询的开销集中在把块从磁盘读入内存，而把块读入内存后扫描的开销较小</p></li>
</ul>
<h2 id="多级索引">多级索引</h2>
<ul>
<li><p>索引的空间开销问题</p>
<p>假如数据库元组较多，即使使用每个块建立一个索引项的稀疏索引，仍然占用较大的空间</p></li>
<li><p>引入<strong>多级索引</strong>，即在<strong>内层索引</strong>基础上，建立<strong>外层索引</strong></p></li>
<li><p>多级索引形成了树形结构</p></li>
</ul>
<h2 id="索引更新">索引更新</h2>
<ul>
<li><p>索引什么时候更新</p>
<p>文件中有<strong>记录插入或删除</strong>时，<strong>每个索引</strong>都必须更新</p>
<p>文件中有<strong>记录被更新</strong>时，<strong>搜索码属性受影响的任何索引</strong>也必须更新</p>
<p>记录的更新可以转换为紧接着的索引的删除和插入操作，因此我们只需考虑索引的删除和插入操作</p></li>
<li><p><strong>插入一条记录</strong></p>
<ul>
<li>稠密索引
<ul>
<li>如果搜索码值未出现在索引中，则在索引中适当的位置插入带有该搜索码值的索引项</li>
<li>如果索引项存储指向具有相同搜索码值的所有记录的指针，则系统在索引项中增加一个指向新纪录的指针</li>
<li>索引项存储一个仅指向具有相同搜索码值的第一条记录的指针，则把待插入的记录放到具有相同搜索码值的其他记录后</li>
</ul></li>
<li>稀疏索引，假设索引为每个块保存一个索引项
<ul>
<li>如果系统创建了一个<strong>新的块</strong>，则将出现在新块中的<strong>第一个搜索码值插入索引中</strong></li>
<li>如果新插入的记录具有它在块中的最小搜索码值，则<strong>更新指向该块的索引项</strong></li>
<li>否则，索引无需改动</li>
</ul></li>
</ul></li>
<li><p>删除一条记录</p>
<ul>
<li><p>稠密索引</p>
<ul>
<li>如果所删除的记录是具有该搜索码值的唯一记录，则从索引中删除具有该搜索码的索引项</li>
<li>如果索引项存储指向具有相同搜索码值的所有记录的指针，则系统在索引项中删除指向该纪录的指针</li>
<li>如果索引项存储一个仅指向具有相同搜索码值的第一条记录的指针，如果待删除的记录是第一条记录，则更新索引项使其指向下一条记录</li>
</ul></li>
<li><p>稀疏索引</p>
<ul>
<li><p>如果索引中并不包含具有待删除记录搜索码值的索引项，则索引不必改动</p></li>
<li><p>如果被删除的记录是具有该搜索码的唯一记录，则系统用下一个记录的搜索码值的索引记录替换相应的索引记录，如果下一个记录已经有索引项，则直接删除索引项</p></li>
<li><p>如果被删除的记录并非具有该搜索码的唯一记录，则更新索引项使其指向具有该搜索码的下一条记录</p></li>
</ul></li>
</ul></li>
</ul>
<h2 id="辅助索引">辅助索引</h2>
<h2 id="多码索引">多码索引</h2>
<ul>
<li>搜索码的属性可以不止一个，包含多个属性的搜索码称为复合搜索码</li>
</ul>
<h2 id="顺序索引的缺点">顺序索引的缺点</h2>
<ul>
<li>随着文件增大，<strong>索引查找</strong>的性能和数据<strong>顺序扫描</strong>的<strong>性能都会下降</strong></li>
</ul>
<h1 id="b树索引文件">B+树索引文件</h1>
<h2 id="b树的结构">B+树的结构</h2>
<ul>
<li><p>叶节点的结构</p>
<ul>
<li>最多包含n-1个搜索码值，和n个指针，指针<span class="math inline">\(P_i\)</span>指向具有搜索码值<span class="math inline">\(K_i\)</span>的一条文件记录<span class="math inline">\((1\leq i \leq n-1)\)</span></li>
<li>最多包含n-1个搜索码值，最少包含<span class="math inline">\(\lceil
(n-1)/2 \rceil\)</span>个搜索码值</li>
<li>节点内的搜索码值有序存放</li>
<li>如果两个叶节点<span class="math inline">\(L_i\)</span>和<span class="math inline">\(L_j\)</span>满足<span class="math inline">\(i \lt
j\)</span>，则<span class="math inline">\(L_i\)</span>内的每个搜索码值都小于<span class="math inline">\(L_j\)</span>内的每个搜索码值</li>
<li>指针<span class="math inline">\(P_n\)</span>指向按顺序排列的<strong>下一个叶节点</strong></li>
</ul></li>
<li><p>非叶节点的结构</p>
<ul>
<li>至多包含n个指针，至少包含<span class="math inline">\(\lceil n/2
\rceil\)</span>个指针</li>
<li>每个指针都指向另一个节点</li>
<li>一个节点中的指针数称为该节点的扇出 fanout</li>
<li>对于一个包含m个指针的非叶节点
<ul>
<li>指针<span class="math inline">\(P_i(2\leq i \leq
m-1)\)</span>指向的子树所包含的搜索码值均满足<span class="math inline">\(K_{i-1} \leq k \lt K_i\)</span></li>
<li>指针<span class="math inline">\(P_m\)</span>指向搜索码值大于等于<span class="math inline">\(K_i\)</span>的子树</li>
<li>指针<span class="math inline">\(P_1\)</span>指向搜索码值小于<span class="math inline">\(K_1\)</span>的子树</li>
</ul></li>
</ul></li>
<li><p>根节点的结构</p>
<ul>
<li>根节点包含的指针数可以小于<span class="math inline">\(\lceil n/2
\rceil\)</span></li>
<li>除非整棵树只有1个节点，否则根节点至少拥有2个指针</li>
</ul></li>
<li><p>B+树是<strong>平衡</strong>的</p>
<p>从<strong>根</strong>节点到每个<strong>叶</strong>节点的<strong>路径具有相同长度</strong></p></li>
<li><p>非唯一搜索码的处理</p>
<p>如果关系r的搜索码<span class="math inline">\(a_i\)</span>属性并非唯一，则建立索引时使用唯一复合搜索码<span class="math inline">\((a_i,A_p)\)</span>代替<span class="math inline">\(a_i\)</span>建立索引，其中<span class="math inline">\(A_p\)</span>是关系<span class="math inline">\(r\)</span>的主码或保证唯一性的任何一组属性</p></li>
</ul>
<h2 id="b树的查询">B+树的查询</h2>
<ul>
<li><p>单点查询</p></li>
<li><p>范围查询</p></li>
<li><p>查询时间复杂度 <span class="math display">\[
\lceil log_{\lceil n/2 \rceil }(N)\rceil
\]</span></p></li>
<li><p>节点规模</p>
<p>典型的节点规模选取为和磁盘块一样大，通常为4KB</p>
<p>假如搜索码大小为32字节，指针大小为8字节，则n可取100。当文件中包含100万个搜索码值时，只需要查找<span class="math inline">\(\lceil log_{\lceil n/2 \rceil
}(N)\rceil=4\)</span></p></li>
<li><p>非唯一搜索码</p>
<p>假设要在非唯一搜索码<span class="math inline">\(a_i\)</span>上建立索引，则我们会在唯一复合搜索码<span class="math inline">\((a_i,A_p)\)</span>上建立索引</p>
<p>如果我们想查找具有搜索码值<span class="math inline">\(v\)</span>的所有记录，则我们执行一个从<span class="math inline">\((v,-inf)\)</span>到<span class="math inline">\((v,inf)\)</span>的范围查询</p></li>
</ul>
<h2 id="b树的更新">B+树的更新</h2>
<ul>
<li>对记录的更新可建模为对旧纪录的删除，后接对新纪录的插入，因此仅考虑插入和删除的情况</li>
<li>假设<strong>没有节点拆分与合并</strong>
<ul>
<li><strong>插入</strong>：使用和查找同样的技术，找到搜索码出现的叶节点，在叶节点中插入一项，使得插入后搜索码仍然有序</li>
<li><strong>删除</strong>：使用和查找相同的技术，找到包含待删除搜索码的叶节点，如果包含多个相同搜索码值的项，则遍历直到找到指向待删除记录的项，移除该项，并将右边的所有项都左移一个位置，以便在删除后不留下空隙</li>
</ul></li>
</ul>
<h3 id="b树的插入">B+树的插入</h3>
<ul>
<li><p><strong>叶节点拆分</strong></p>
<p>假如待插入的叶节点已经具有n-1个搜索码，则必须进行拆分</p>
<p>前<span class="math inline">\(\lceil n / 2
\rceil\)</span>个搜索码保留在原来的节点，剩余节点加入新拆分的节点</p>
<p>将新拆分节点的第一个搜索码加入原叶节点的父节点</p>
<p>如果该父节点也满了，则需要进行拆分，该过程将从叶节点向根节点进行</p>
<p>最坏情况下，根节点也要拆分，则树的深度增加了</p></li>
<li><p><strong>非叶节点拆分</strong></p>
<p>加入非叶节点原来具有n-1个搜索码，则需要进行拆分</p>
<p>将前<span class="math inline">\(\lceil (n + 1)/2
\rceil\)</span>个指针及它们之间的搜索码插入节点P</p>
<p>将剩余指针及它们之间的搜索码插入新节点P'</p>
<p>令K‘’为P的最后一个指针，与P'第一个指针之间的搜索码值</p>
<p>将K''插入P的父节点中</p></li>
</ul>
<h3 id="b树的删除">B+树的删除</h3>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Young</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  




  <script src="/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
