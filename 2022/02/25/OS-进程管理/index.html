<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.11.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="OS进程管理章节总结">
<meta property="og:type" content="article">
<meta property="og:title" content="OS-进程管理">
<meta property="og:url" content="http://example.com/2022/02/25/OS-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="元朗食品">
<meta property="og:description" content="OS进程管理章节总结">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-02-25T14:40:13.000Z">
<meta property="article:modified_time" content="2022-04-08T12:08:32.861Z">
<meta property="article:author" content="Young">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2022/02/25/OS-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2022/02/25/OS-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/","path":"2022/02/25/OS-进程管理/","title":"OS-进程管理"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>OS-进程管理 | 元朗食品</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">元朗食品</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-text">第二章 进程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="nav-text">2.1 进程与线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">进程的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2"><span class="nav-text">进程状态的切换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-text">进程控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-text">进程通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">线程的概念</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">2.2 进程调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E5%B1%82%E6%AC%A1"><span class="nav-text">进程调度的层次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-text">进程调度的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="nav-text">批处理系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A4%E4%BA%92%E6%97%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">交互时系统</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-text">2.3 进程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%BA%92%E6%96%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="nav-text">实现临界区互斥的基本方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="nav-text">硬件实现方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-text">信号量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E7%A8%8B"><span class="nav-text">管程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="nav-text">2.4 经典同步问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-text">生产者-消费者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-text">读者-写者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="nav-text">哲学家进餐问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-text">2.5 死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-text">四个必要条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="nav-text">死锁的处理方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2"><span class="nav-text">死锁预防</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E4%B8%8E%E6%AD%BB%E9%94%81%E6%81%A2%E5%A4%8D"><span class="nav-text">死锁检测与死锁恢复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="nav-text">死锁避免——银行家算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A5%E5%85%85-%E9%94%81"><span class="nav-text">2.6 补充: 锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81spinlock%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">自旋锁spinlock的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep-locks"><span class="nav-text">sleep locks</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Young"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Young</p>
  <div class="site-description" itemprop="description">Talk is cheap, show me the code.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">127</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


<!-- require APlayer -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">

<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
<!-- require MetingJS-->

<script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script> 
<!--playlist外链地址-->   
<meting-js
  server="tencent"
  type="playlist" 
  id="8356942170"
  mini="false"
  fixed="false"
  list-folded="true"
  autoplay="false"
  volume="0.4"
  theme="#FADFA3"
  order="list"
  loop="all"
  preload="auto"
  lrc-type="1"
  mutex="true">
</meting-js>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/25/OS-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Young">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="元朗食品">
      <meta itemprop="description" content="Talk is cheap, show me the code.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="OS-进程管理 | 元朗食品">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          OS-进程管理
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-25 22:40:13" itemprop="dateCreated datePublished" datetime="2022-02-25T22:40:13+08:00">2022-02-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-08 20:08:32" itemprop="dateModified" datetime="2022-04-08T20:08:32+08:00">2022-04-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><strong>OS进程管理章节总结</strong></p>
<span id="more"></span>
<h1 id="第二章-进程管理">第二章 进程管理</h1>
<h2 id="进程与线程">2.1 进程与线程</h2>
<h3 id="进程的概念">进程的概念</h3>
<ul>
<li>进程是<strong>资源分配</strong>的基本单位</li>
<li>进程实体由<strong>程序段</strong>、<strong>数据段</strong>和<strong>PCB</strong>三部分构成</li>
<li><strong>进程控制块</strong> (Process Control Block,
<strong>PCB</strong>)
描述进程的基本信息和运行状态，所谓的<strong>创建</strong>进程和<strong>撤销</strong>进程，实则是指创建进程的PCB、撤销进程的PCB</li>
</ul>
<h3 id="进程状态的切换">进程状态的切换</h3>
<ul>
<li>进程状态包括：<strong>创建</strong>态、<strong>就绪</strong>态、<strong>运行</strong>态、<strong>阻塞</strong>态、<strong>结束</strong>态</li>
<li><strong>就绪</strong>态，进程已获得除了处理机以外的一切资源，等待被调度，通常以<strong>就绪队列</strong>的结构组织就绪态的进程</li>
<li><strong>运行</strong>态，进程正在处理机上运行</li>
<li><strong>阻塞</strong>态，进程正等待某一事件而暂停运行，如等待资源可用，或等待I/O事件</li>
<li><strong>创建</strong>态，申请空白的PCB，初始化，为进程<strong>分配所需资源</strong>，然后转入就绪态</li>
<li><strong>结束</strong>态，进程结束运行，进入结束态，完成<strong>资源释放和回收</strong>工作</li>
<li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过<strong>调度算法</strong>从而获得
CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU
时间片用完之后就会转为就绪状态，等待下一次调度</li>
<li>阻塞状态是<strong>缺少需要的资源</strong>从而由运行状态转换而来，但是该资源不包括
CPU 时间，缺少 CPU 时间会从运行态转换为就绪态</li>
</ul>
<h3 id="进程控制">进程控制</h3>
<ul>
<li>进程<strong>创建</strong>，父进程创建子进程，为子进程<strong>分配PID</strong>，子进程<strong>继承</strong>父进程的所有<strong>资源</strong></li>
<li>进程<strong>终止</strong>，正常结束/异常结束/外界干预，<strong>终止该进程及所有子孙进程</strong>执行，将所有<strong>资源归还</strong>给父进程或操作系统</li>
<li>进程<strong>阻塞</strong>，处于运行态的进程主动阻塞，进程PCB插入<strong>相应事件的等待队列</strong></li>
<li>进程<strong>唤醒</strong>，某个事件（如某资源释放）发生时，相关进程
（释放该资源的进程）<strong>唤醒等待该事件的进程</strong></li>
<li>进程<strong>切换</strong>，CPU从一个进程的运行转到另一个进程的运行
<ul>
<li><strong>保存旧进程的context</strong>，包括<strong>PC</strong>和<strong>其他寄存器</strong></li>
<li>更新旧进程的PCB信息</li>
<li>将旧进程的PCB放入相应队列，如就绪队列</li>
<li>选择新进程执行，更新其PCB</li>
<li>更新内存管理的数据结构</li>
<li>恢复处理机context</li>
</ul></li>
</ul>
<blockquote>
<p>xv6中的<strong>进程切换</strong></p>
<ul>
<li>从user进入kernel模式，从旧进程进入到其内核中的kernel thread</li>
<li>context switch，从旧进程的kernel thread切换到当前CPU的scheduler
thread</li>
<li>context switch，从CPU的scheduler thread切换到新进程的kernel
thread</li>
<li>trap return，返回user mode，运行新进程</li>
</ul>
<p>context switch时的操作</p>
<ul>
<li>保存旧线程的寄存器（包括pc、stack pointer等）</li>
<li>恢复新线程之前保存的寄存器值</li>
<li>由于stack
pointer和pc都会被保存或恢复，因此线程切换时CPU会切换stack及所执行的代码</li>
</ul>
</blockquote>
<h3 id="进程通信">进程通信</h3>
<ul>
<li>PV操作</li>
<li>共享存储：进程之间存在一块可直接访问的共享空间，通过对这片共享空间的读写操作实现进程之间的信息交换</li>
<li>消息传递</li>
<li>管道通信：管道指<strong>一个读进程、一个写进程</strong>及实现它们之间通信的一个<strong>共享文件</strong>。写进程以<strong>字符流</strong>形式将数据<strong>写入</strong>管道，读进程则从管道<strong>读出</strong>数据，管道是<strong>半双工通信</strong></li>
<li>Linux中的管道：
<ul>
<li>管道是一个固定大小的缓冲区，大小为4KB</li>
<li>当管道满了后，写进程调用<code>write()</code>将被阻塞，当管道空了，读进程调用<code>read()</code>将被<strong>阻塞</strong></li>
</ul></li>
</ul>
<h3 id="线程的概念">线程的概念</h3>
<ul>
<li>线程
<ul>
<li>线程是<strong>独立调度</strong>的基本单位</li>
<li><strong>一个进程</strong>可以有<strong>多个线程</strong>，它们<strong>共享进程资源</strong></li>
</ul></li>
<li>进程与线程的区别
<ul>
<li>进程是<strong>资源分配</strong>的基本单位，但是<strong>线程不拥有资源</strong>，线程可以访问隶属进程的资源</li>
<li>线程是<strong>独立调度</strong>的基本单位，在同一进程中，<strong>线程的切换不会引起进程切换</strong>，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换</li>
<li>由于<strong>创建或撤销进程时</strong>，系统都要为之<strong>分配或回收资源</strong>，如内存空间、I/O
设备等，所付出的开销<strong>远大于创建或撤销线程时的开销</strong>。类似地，在进行<strong>进程切换</strong>时，涉及当前执行<strong>进程
CPU 环境的保存</strong>及<strong>新调度进程 CPU
环境的设置</strong>，而<strong>线程切换</strong>时只需<strong>保存和设置少量寄存器内容</strong>，开销很小</li>
<li><strong>线程</strong>间可以通过直接<strong>读写同一进程中的数据</strong>进行通信，但是进程通信需要借助
<strong>进程间通信技术（IPC）</strong></li>
</ul></li>
<li>线程的实现方式
<ul>
<li><strong>用户级</strong>线程</li>
<li><strong>内核级</strong>线程</li>
<li><strong>组合方式</strong>实现多线程，线程创建在用户空间中完成，线程调度和同步也在应用程序进行，<strong>多个用户级线程</strong>被映射到<strong>一些内核级线程</strong>上
<ul>
<li>多对一模型，一个线程使用内核服务被阻塞时整个进程都会被阻塞</li>
<li>一对一模型，创建线程的开销较大</li>
<li>多对多模型，n个用户级线程映射到m个内核级线程，一般<span class="math inline">\(m \leq n\)</span></li>
</ul></li>
</ul></li>
</ul>
<h2 id="进程调度算法">2.2 进程调度算法</h2>
<h3 id="进程调度的层次">进程调度的层次</h3>
<ul>
<li>调度的三个层次：作业调度、中级调度、进程调度</li>
<li><strong>作业调度</strong>，<strong>内存</strong>与<strong>辅存</strong>之间的调度，按一定原则从外存上选择处于后备状态的作业，给它们分配内存、I/O设备等资源，并建立相应进程</li>
<li><strong>中级调度</strong>，又称内存调度，将暂时不能运行的进程调出外存等待，此时进程状态为挂起态，当它们具备运行条件时再将其重新调入内存，挂在就绪队列上等待</li>
<li><strong>进程调度</strong>，按一定方法和策略，从<strong>就绪队列</strong>上选取一个进程，分配<strong>CPU时间</strong></li>
</ul>
<h3 id="进程调度的方式">进程调度的方式</h3>
<ul>
<li><strong>非剥夺</strong>调度方式，当进程在CPU上运行时，优先级更高的进程到来，<strong>仍然让该进程继续运行</strong>直到时间片结束或阻塞</li>
<li><strong>剥夺</strong>调度方式，当进程在CPU上运行时，优先级更高的进程到来，<strong>立刻暂停正在执行的进程</strong>，将CPU分配给优先级更高的进程</li>
</ul>
<h3 id="调度算法">调度算法</h3>
<h4 id="批处理系统">批处理系统</h4>
<ul>
<li><strong>先来先服务（FCFS）</strong>，短作业不利</li>
<li><strong>短作业优先（SJF）</strong>，长作业不利（饥饿）</li>
<li><strong>最短剩余时间优先（SRTN）</strong>，最短作业优先的剥夺调度版本</li>
</ul>
<h4 id="交互时系统">交互时系统</h4>
<ul>
<li><strong>时间片轮转调度</strong>，按FCFS原则将就绪进程排成队列，每次调度时将CPU时间片分配给队首进程，执行一个时间片后该进程暂停执行并回到队尾，<strong>合适的时间片选取</strong>是关键</li>
<li><strong>优先级调度</strong>，优先级高的先执行，一般来说按以下原则设置优先级
<ul>
<li>系统进程 &gt; 用户进程</li>
<li>交互进程 &gt; 非交互进程</li>
<li>I/O型进程 &gt; 计算型进程</li>
<li>随着等待时间增加，提高进程的优先级，防止”饥饿“</li>
</ul></li>
</ul>
<blockquote>
<ul>
<li><strong>饥饿</strong>，在一定进程调度算法的作用下，进程长期分配不到CPU时间的现象</li>
</ul>
</blockquote>
<ul>
<li><strong>多级反馈队列</strong>
<ul>
<li>设置<strong>多个就绪队列</strong>，赋予<strong>不同的优先级和时间片</strong>，<strong>第1级</strong>队列<strong>优先级最高、时间片最小</strong>，<strong>最后一级</strong>队列<strong>优先级最低、时间片最长</strong></li>
<li>仅当<strong>第1-i级队列都为空</strong>时，才<strong>调度第i+1级队列</strong>中的进程</li>
<li>每级队列按<strong>时间片轮转调度</strong></li>
<li><strong>新进程加入第1级队列的队尾</strong>，当进程在<strong>第i级队列被调度后</strong>，<strong>加入第i+1级队列</strong>的队尾</li>
<li><strong>剥夺式</strong>优先级调度，如果运行第i级队列的进程时，有新进程加入就绪队列，它将位于优先级更高的第1级队列，此时立刻暂停当前进程执行，将CPU分配给新进程</li>
<li>综合了<strong>时间片轮转调度</strong>和<strong>优先级调度</strong>算法</li>
</ul></li>
</ul>
<h2 id="进程同步">2.3 进程同步</h2>
<h3 id="基本概念">基本概念</h3>
<ul>
<li>一次仅允许一个进程使用的资源为<strong>临界资源</strong></li>
<li><strong>访问</strong>临界资源的那段<strong>代码</strong>称为<strong>临界区</strong></li>
<li>对临界资源的访问过程分为4部分
<ul>
<li><strong>进入区</strong>，<strong>检查</strong>是否可以进入临界区，若可以则<strong>设置</strong>访问标志</li>
<li><strong>临界区</strong>，访问临界资源的代码</li>
<li><strong>退出区</strong>，<strong>清除</strong>访问标志</li>
<li><strong>剩余区</strong>，其余部分</li>
</ul></li>
<li><strong>同步</strong>：多个进程因为<strong>合作</strong>产生的<strong>直接制约关系</strong>，使得进程有一定的<strong>先后执行关系</strong></li>
<li><strong>互斥</strong>：多个进程在<strong>同一时刻只有一个进程能进入临界区</strong></li>
</ul>
<h3 id="实现临界区互斥的基本方法">实现临界区互斥的基本方法</h3>
<h4 id="硬件实现方法">硬件实现方法</h4>
<ul>
<li><p><strong>中断屏蔽</strong>方法：关中断、临界区、开中断</p></li>
<li><p><strong>Test-And-Set</strong>，读出指定标志后将其设置为真，原子操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">while</span> <span class="title">TestAndSet</span><span class="params">(&amp;lock)</span></span>;</span><br><span class="line"><span class="comment">// 临界区</span></span><br><span class="line">lock = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>读出lock的值，并将lock设置为true</li>
<li>假如临界资源<strong>被占有</strong>，则lock原来的值为true，因此<code>TestAndSet</code><strong>对lock其无影响</strong>，且返回值为true，因此<strong>继续循环</strong></li>
<li>假如临界资源<strong>不被占有</strong>，则lock原来的值为false，因此<code>TestAndSet</code><strong>将lock置为true</strong>，同时返回值为false，跳出while循环并<strong>进入临界区</strong></li>
</ul></li>
<li><p><strong>Swap</strong>，交换两个字节的内容，原子操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> key = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (key)</span><br><span class="line">    <span class="built_in">swap</span>(&amp;key, &amp;lock);</span><br><span class="line"><span class="comment">// 临界区</span></span><br><span class="line">lock = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>效果与Test-And-Set类似</li>
</ul></li>
</ul>
<h4 id="信号量">信号量</h4>
<ul>
<li><p><strong>信号量（Semaphore）</strong>是一个整型变量，<strong>P操作和V操作</strong></p></li>
<li><p><strong>P操作</strong>：如果信号量大于0
，将其减1；如果信号量等于0，<strong>进程睡眠</strong>，等待信号量大于0</p></li>
<li><p><strong>V操作</strong>：将信号量加1，<strong>唤醒睡眠的进程</strong>，让其完成P操作</p></li>
<li><p>P和V操作需要被设计成<strong>原语，不可分割</strong>，通常的做法是在执行这些操作的时候<strong>屏蔽中断</strong></p></li>
<li><p>如果信号量的取值<strong>只能为0或者1</strong>，那么就成为了<strong>互斥量（Mutex）</strong>
，0表示临界区已经加锁，1表示临界区解锁</p></li>
<li><p>信号量实现<strong>互斥</strong>：将信号量作为互斥量，设置<strong>临界区</strong>在<strong>P操作和V操作之间</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">P</span>(mutex);</span><br><span class="line"><span class="comment">// 临界区</span></span><br><span class="line"><span class="built_in">V</span>(mutex);</span><br></pre></td></tr></table></figure></li>
<li><p>信号量实现<strong>同步</strong>：两个进程的执行必须保证先后关系，为<strong>每对先后关系</strong>设置<strong>一个信号量</strong></p>
<ul>
<li>每个前操作后执行<code>V(S)</code></li>
<li>每个后操作后执行<code>P(S)</code></li>
</ul></li>
</ul>
<h3 id="管程">管程</h3>
<ul>
<li>利用<strong>共享数据结构</strong>表示系统的<strong>共享资源</strong>，以及由对该共享数据结构<strong>实施操作的一组过程</strong>所组成的<strong>资源管理程序</strong>，称为<strong>管程</strong></li>
<li>管程保证了<strong>进程互斥</strong>，即每次仅允许一个进程进入管程</li>
<li><strong>条件变量</strong>，管程需要阻塞时，将<strong>阻塞原因</strong>定义为条件变量
<ul>
<li><code>x.wait</code>，<code>x</code>对应的条件不满足时，调用管程的进程通过<code>x.wait</code>将自己插入<code>x</code>条件的等待队列中，并释放管程，此时其他进程可以使用该管程</li>
<li><code>x.signal</code>，<code>x</code>对应的条件发生变化，调用<code>x.signal</code>，唤醒一个<code>x</code>的等待队列中的进程</li>
</ul></li>
</ul>
<h2 id="经典同步问题">2.4 经典同步问题</h2>
<h3 id="生产者-消费者问题">生产者-消费者问题</h3>
<ul>
<li><p><strong>问题描述</strong>：使用一个<strong>缓冲区</strong>来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品</p></li>
<li><p><strong>信号量</strong>设置：一个<strong>互斥量</strong><code>mutex</code>用于控制<strong>对缓冲区的互斥访问</strong>，<strong>信号量</strong><code>empty</code>表示<strong>生产者可用的资源</strong>，<strong>信号量</strong><code>full</code>表示<strong>消费者可用的资源</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore empty = n;</span><br><span class="line">semaphore full = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>生产者模型</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">P</span>(empty);</span><br><span class="line">    <span class="built_in">P</span>(mutex);</span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    <span class="built_in">V</span>(mutex);</span><br><span class="line">    <span class="built_in">V</span>(full);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>消费者模型</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">P</span>(full);</span><br><span class="line">    <span class="built_in">P</span>(mutex);</span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    <span class="built_in">V</span>(mutex);</span><br><span class="line">    <span class="built_in">V</span>(empty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>不能先对<code>mutex</code>进行P操作，再对<code>empty</code>或<code>full</code>进行P操作。原因是如果缓存区已满，而生产者对<code>mutex</code>进行了P操作，再对<code>empty</code>进行P操作的时候会阻塞。此时，如果有消费者想读出数据，它对<code>mutex</code>进行P操作时也会阻塞，因而导致了<strong>死锁</strong></p></li>
</ul>
<h3 id="读者-写者问题">读者-写者问题</h3>
<ul>
<li><p>问题描述：一组读者进程和一组写者进程共享一个文件，两个或以上读进程可同时访问，写进程不能与其他任何进程同时访问</p></li>
<li><p>信号量设置：对文件资源的读写互斥访问设置一个互斥量<code>rw</code>，对<strong>读进程数量</strong>设置<strong>计数器</strong><code>counter</code>，读进程访问计数器是互斥的，设置互斥量<code>mutex</code>。读进程进入临界区和退出临界区都要更新计数器，特别地，进入时如果计数器为0，则该读进程需要确保读写互斥，因此对<code>rw</code>执行P操作；退出临界区时如果计数器为0，则需要释放读写互斥量，因此对<code>rw</code>执行V操作</p></li>
<li><p>读者模型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">P</span>(mutex);</span><br><span class="line"><span class="keyword">if</span> (counter == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">P</span>(rw);</span><br><span class="line">++counter;</span><br><span class="line"><span class="built_in">V</span>(mutex);</span><br><span class="line"><span class="comment">// read</span></span><br><span class="line"><span class="built_in">P</span>(mutex);</span><br><span class="line">--counter;</span><br><span class="line"><span class="keyword">if</span> (counter == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">V</span>(rw);</span><br><span class="line"><span class="built_in">V</span>(mutex);</span><br></pre></td></tr></table></figure></li>
<li><p>写者模型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">P</span>(rw);</span><br><span class="line"><span class="comment">// write</span></span><br><span class="line"><span class="built_in">V</span>(rw);</span><br></pre></td></tr></table></figure></li>
<li><p>上述程序，可能导致<strong>写进程的饥饿问题</strong>，因为只要有一个读进程在读，随后而来的读进程都会被允许访问，而写进程则会被阻塞</p></li>
</ul>
<h3 id="哲学家进餐问题">哲学家进餐问题</h3>
<ul>
<li><p>方法一：至多允许4名哲学家同时进餐</p></li>
<li><p>方法二：奇数哲学家先拿左边、再拿右边；偶数哲学家反之</p></li>
<li><p>实现，利用C++的<code>mutex</code>类、<code>unique_lock</code>类和<code>condition_variable</code>类实现<strong>信号量</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Semaphore</span>(<span class="keyword">int</span> c = <span class="number">1</span>): _cnt(c) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; _cnt = c; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_mtx)</span></span>;</span><br><span class="line">        ++_cnt;</span><br><span class="line">        _cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span>  () &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_mtx)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (_cnt &lt;= <span class="number">0</span>)</span><br><span class="line">            _cv.<span class="built_in">wait</span>(lock);</span><br><span class="line">        --cnt;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _cnt;</span><br><span class="line">    mutex _mtx;</span><br><span class="line">    condition_variable _cv;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="死锁">2.5 死锁</h2>
<h3 id="四个必要条件">四个必要条件</h3>
<ul>
<li><strong>互斥</strong>：每个资源要么已经分配给了一个进程，要么就是可用的</li>
<li><strong>占有和等待</strong>：已经得到了某个资源的进程可以再请求新的资源，如果该资源被其他进程占有，则请求进程被阻塞，但对自己已获得的资源保持不放</li>
<li><strong>不可抢占</strong>：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放</li>
<li><strong>环路等待</strong>：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源</li>
</ul>
<h3 id="死锁的处理方法">死锁的处理方法</h3>
<ul>
<li><strong>鸵鸟策略</strong>，忽略它</li>
<li><strong>死锁检测</strong>与<strong>死锁恢复</strong></li>
<li><strong>死锁预防</strong></li>
<li><strong>死锁避免</strong></li>
</ul>
<h3 id="死锁预防">死锁预防</h3>
<ul>
<li><p>死锁预防：在程序运行<strong>之前预防</strong>发生死锁，从死锁的四个必要条件入手</p></li>
<li><p><strong>破坏互斥条件</strong>，例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程</p></li>
<li><p><strong>破坏占有和等待条件</strong>，一种实现方式是规定所有进程在<strong>开始执行前请求所需要的全部资源</strong></p></li>
<li><p><strong>破坏不可抢占条件</strong></p></li>
<li><p><strong>破坏环路等待</strong>，给资源统一编号，进程只能<strong>按编号顺序</strong>来请求资源。</p></li>
</ul>
<h3 id="死锁检测与死锁恢复">死锁检测与死锁恢复</h3>
<ul>
<li><p>死锁<strong>检测</strong>：若<strong>资源分配图</strong>能够<strong>完全简化</strong>，则<strong>不会发生死锁</strong></p></li>
<li><p>死锁<strong>恢复</strong></p>
<ul>
<li>利用<strong>抢占</strong>恢复，挂起某些进程，抢占其资源并分配给其他进程</li>
<li>利用<strong>回滚</strong>恢复，让一或多个进程回退到足以避免死锁的地步，要求系统保持进程的历史信息并设置还原点</li>
<li>通过<strong>杀死进程</strong>恢复，撤销（部分或全部）死锁进程，回收其资源，撤销的原则可按<strong>进程优先级</strong>、撤销进程<strong>代价</strong>等进行</li>
</ul></li>
</ul>
<h3 id="死锁避免银行家算法">死锁避免——银行家算法</h3>
<ul>
<li>数据结构：<strong>可利用资源向量Available</strong>、<strong>最大需求矩阵Max</strong>、<strong>分配矩阵Allocation</strong>、<strong>需求矩阵Need</strong></li>
<li>算法描述
<ul>
<li>首先根据Max和Allocation计算<strong>Need矩阵</strong></li>
<li>收到进程P的<strong>请求向量Request</strong>时，首先检查Request中的元素是否小于等于Need矩阵中对应元素，若否则进程请求的资源超出了其声称的最大值，拒绝该请求</li>
<li>若没超过，则<strong>尝试</strong>把资源分配给进程P，更新Allocation、Available、Need矩阵</li>
<li>执行<strong>安全性算法</strong>，若通过检查则进行分配，否则拒绝该请求，并让进程P等待</li>
</ul></li>
<li>安全性算法
<ul>
<li>对于给定的Max、Allocation和Available，若存在一种<strong>安全序列</strong>可以让<strong>所有进程都执行完成</strong>，则系统处于<strong>安全状态</strong>，否则处于不安全状态</li>
</ul></li>
</ul>
<h2 id="补充-锁">2.6 补充: 锁</h2>
<ul>
<li><p>如果系统调用并行地运行在多个CPU上，则可能并行地访问内核中共享的数据结构，为了确保数据的一致性，需要使用锁来协调对于共享数据的更新</p></li>
<li><p>当一份共享数据同时被读写，而没有锁的保护，则可能出现race
condition</p></li>
<li><p>锁的使用</p>
<p><code>acquire</code>，获取锁，确保任何时间只有一个进程能够成功获取锁</p>
<p><code>release</code>，释放所持有的lock</p></li>
<li><p>死锁的预防，如果需要获取多个锁，则对锁进行排序，所有操作都必须<strong>按相同的顺序</strong>获取这些锁（打破死锁的<strong>环路等待</strong>条件）</p></li>
<li><p>锁限制了并发性，限制了性能。为了更好的性能，可以对数据结构和锁进行拆分，但者会带来较大工作量</p></li>
</ul>
<h3 id="自旋锁spinlock的实现">自旋锁spinlock的实现</h3>
<ul>
<li><p>使用特殊的<strong>硬件指令</strong>，保证一次test-and-set操作的<strong>原子性</strong>，xv6中，<code>amoswap</code>接收3个参数，分别是<strong>address、寄存器r1和寄存器r2</strong>，指令先锁住address，将address中的数据保存在临时变量中，然后将r1的数据写入address中，再将临时变量的数据写入r2中，然后对地址解锁</p></li>
<li><p>指令<code>while(__sync_lock_test_and_set(&amp;locked, 1) != 0)</code>，会将1写入<code>locked</code>，并且读出<code>locked</code>原来的值</p>
<ul>
<li><p>若原来的值为1说明该锁被占有，因此写入1无影响，继续执行while循环（因此称为<strong>自旋锁</strong>）</p></li>
<li><p>若原来的值为0说明该锁未被占有，因此写入1<strong>获取该锁</strong>，并退出while循环继续执行下面的代码</p></li>
</ul></li>
</ul>
<h3 id="sleep-locks">sleep locks</h3>
<ul>
<li><p>自旋锁的缺点</p>
<ul>
<li>有的进程会长期持有锁，如果其他进程一直自旋会<strong>浪费CPU资源</strong></li>
<li>持有自旋锁的进程<strong>不能让出CPU</strong>，否则调度至另一进程，它想获取该锁将会一直自旋，从而导致死锁</li>
</ul></li>
<li><p>需要一种锁，在锁被持有时允许让出CPU和允许中断，这就是sleep
locks</p>
<ul>
<li><strong>不能在interrupt
handler中使用睡眠锁</strong>，因为它允许中断</li>
<li><strong>不能在spinlock的临界区使用sleep lock</strong>，因为sleep
lock可能让出CP</li>
</ul>
<blockquote>
<p><strong>解释</strong></p>
<ul>
<li>interrupt
handler和临界区都具有原子性，它们不会让出CPU。假如进程A获取了sleep
lock，而由于sleeplock允许中断，当中断发生并进入interrupt
handler时执行到获取sleep lock的指令时将阻塞，
而由于中断处理程序不会让出CPU，因此它会一直阻塞，进程A也不可能获得CPU而释放sleep
lock，导致死锁</li>
<li>同样地，临界区也具有原子性。假如进程A获取了sleep
lock，此后进程调度使得A让出CPU，执行进程B，进程B在其临界区获取该sleep
lock，且不让出CPU，从而A也无法执行以释放该sleep lock，导致死锁</li>
</ul>
</blockquote></li>
<li><p>spinlock适合较短的临界区，而sleeplock适用于长时间的操作</p></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Young
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://example.com/2022/02/25/OS-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" title="OS-进程管理">http://example.com/2022/02/25/OS-进程管理/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
              <a href="/tags/OS/" rel="tag"># OS</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/02/24/%E8%AE%A1%E7%BD%91-%E8%BF%90%E8%BE%93%E5%B1%82/" rel="prev" title="计网-运输层">
                  <i class="fa fa-chevron-left"></i> 计网-运输层
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/02/25/C++-%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/" rel="next" title="C++ 信号量的实现">
                  C++ 信号量的实现 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Young</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  




  <script src="/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
