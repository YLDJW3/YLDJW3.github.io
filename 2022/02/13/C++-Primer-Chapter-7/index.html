<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.11.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="第七章 类7.1 定义抽象数据类型实现Sales_data类接口 isbn成员函数，用于返回对象的ISBN编号 combine成员函数，用于将一个Sales_data对象加到另一个对象上 add函数，执行两个Sales_data对象的加法 read函数，从istream中读取数据到Sales_data对象中 print函数，将Sales_data对象的值输出到ostream  定义成员函数 成员函">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Primer Chapter 7">
<meta property="og:url" content="http://example.com/2022/02/13/C++-Primer-Chapter-7/index.html">
<meta property="og:site_name" content="小羊的笔记本">
<meta property="og:description" content="第七章 类7.1 定义抽象数据类型实现Sales_data类接口 isbn成员函数，用于返回对象的ISBN编号 combine成员函数，用于将一个Sales_data对象加到另一个对象上 add函数，执行两个Sales_data对象的加法 read函数，从istream中读取数据到Sales_data对象中 print函数，将Sales_data对象的值输出到ostream  定义成员函数 成员函">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-02-13T14:11:23.000Z">
<meta property="article:modified_time" content="2024-02-26T14:22:39.817Z">
<meta property="article:author" content="Young">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2022/02/13/C++-Primer-Chapter-7/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2022/02/13/C++-Primer-Chapter-7/","path":"2022/02/13/C++-Primer-Chapter-7/","title":"C++ Primer Chapter 7"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C++ Primer Chapter 7 | 小羊的笔记本</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">小羊的笔记本</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB"><span class="nav-text">第七章 类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-%E5%AE%9A%E4%B9%89%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">7.1 定义抽象数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0Sales-data%E7%B1%BB"><span class="nav-text">实现Sales_data类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-text">接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">定义成员函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%9C%A8%E7%B1%BB%E5%86%85%E9%83%A8%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E6%98%AFinline%E7%9A%84"><span class="nav-text">定义在类内部的成员函数默认是inline的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#isbn%E5%87%BD%E6%95%B0"><span class="nav-text">isbn函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#this"><span class="nav-text">this</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">const成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">类作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E7%B1%BB%E5%A4%96%E9%83%A8%E5%AE%9A%E4%B9%89%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">在类外部定义的成员函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#avg-price%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">avg_price成员函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E8%BF%94%E5%9B%9Ethis%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-text">定义一个返回this对象的函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#combine%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">combine成员函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9B%B8%E5%85%B3%E7%9A%84%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">定义类相关的非成员函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89read%E5%87%BD%E6%95%B0%E5%92%8Cprint%E5%87%BD%E6%95%B0"><span class="nav-text">定义read函数和print函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89add%E5%87%BD%E6%95%B0"><span class="nav-text">定义add函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E6%88%90%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">合成的默认构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E8%83%BD%E4%BE%9D%E8%B5%96%E4%BA%8E%E5%90%88%E6%88%90%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">不能依赖于合成的默认构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%99Sales-data%E5%AE%9A%E4%B9%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">给Sales_data定义构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#default%E7%9A%84%E5%90%AB%E4%B9%89"><span class="nav-text">&#x3D;default的含义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%80%BC%E5%88%97%E8%A1%A8"><span class="nav-text">构造函数初始值列表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E7%B1%BB%E5%A4%96%E5%AE%9A%E4%B9%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">在类外定义构造函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E3%80%81%E8%B5%8B%E5%80%BC%E3%80%81%E6%9E%90%E6%9E%84"><span class="nav-text">拷贝、赋值、析构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%90%E4%BA%9B%E7%B1%BB%E4%B8%8D%E8%83%BD%E4%BE%9D%E8%B5%96%E4%BA%8E%E5%90%88%E6%88%90%E7%9A%84%E7%89%88%E6%9C%AC"><span class="nav-text">某些类不能依赖于合成的版本</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B0%81%E8%A3%85"><span class="nav-text">7.2 访问控制与封装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%81%E8%A3%85%EF%BC%9F%E5%B0%81%E8%A3%85%E6%9C%89%E4%BD%95%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="nav-text">什么是封装？封装有何优点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="nav-text">访问说明符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#class%E5%92%8Cstruct%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">class和struct的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8B%E5%85%83"><span class="nav-text">友元</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%8A%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%8B%E5%85%83"><span class="nav-text">把函数作为友元</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E5%A3%B0%E6%98%8E%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-text">友元声明的位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E5%A3%B0%E6%98%8E"><span class="nav-text">友元声明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-%E7%B1%BB%E5%92%8C%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7"><span class="nav-text">7.3 类和其他特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%88%90%E5%91%98"><span class="nav-text">定义类型成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A4%E6%88%90%E5%91%98%E4%BD%9C%E4%B8%BA%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-text">令成员作为内联函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">重载成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="nav-text">可变数据成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="nav-text">类数据成员的初始值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E-this%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">返回*this的成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%B1%BB%E5%9E%8B"><span class="nav-text">类类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="nav-text">类的声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%AE%8C%E5%85%A8%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="nav-text">不完全类型可使用的场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E7%B1%BB%E5%9E%8B%E4%B8%8D%E8%83%BD%E6%98%AF%E8%AF%A5%E7%B1%BB%E8%87%AA%E5%B7%B1"><span class="nav-text">类的成员类型不能是该类自己</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8B%E5%85%83-1"><span class="nav-text">友元</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8F%8B%E5%85%83%E5%85%B3%E7%B3%BB"><span class="nav-text">类之间的友元关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%8B%E5%85%83"><span class="nav-text">令成员函数作为友元</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%8B%E5%85%83%E7%9A%84%E5%AE%9A%E4%B9%89%E6%AD%A5%E9%AA%A4"><span class="nav-text">令成员函数作为友元的定义步骤</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E4%B8%8E%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0"><span class="nav-text">友元与重载函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E5%A3%B0%E6%98%8E%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">友元声明与作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%9C%A8%E4%BA%8E%EF%BC%8C%E5%8F%8B%E5%85%83%E5%A3%B0%E6%98%8E%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%AA%E6%94%B9%E5%8F%98%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%EF%BC%8C%E5%AE%83%E6%97%A0%E6%B3%95%E5%8F%96%E4%BB%A3%E6%99%AE%E9%80%9A%E6%84%8F%E4%B9%89%E4%B8%8A%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="nav-text">关键在于，友元声明的作用只改变访问权限，它无法取代普通意义上的声明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">7.4 类的作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%AE%9A%E4%B9%89%E5%9C%A8%E7%B1%BB%E5%A4%96%E9%83%A8%E7%9A%84%E6%88%90%E5%91%98"><span class="nav-text">作用域和定义在类外部的成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE%E4%B8%8E%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">名字查找与类的作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%88%86%E4%B8%A4%E6%AD%A5%E5%A4%84%E7%90%86"><span class="nav-text">类的定义分两步处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%90%8D%E7%9A%84%E7%89%B9%E6%AE%8A%E4%B9%8B%E5%A4%84"><span class="nav-text">类型名的特殊之处</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E6%99%AE%E9%80%9A%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE"><span class="nav-text">成员定义中的普通块作用域的名字查找</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%B7%B1%E5%85%A5"><span class="nav-text">7.5 构造函数深入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E8%B5%8B%E5%80%BC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">初始化与赋值的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="nav-text">成员初始化的顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82"><span class="nav-text">构造函数的默认实参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">委托构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">默认构造函数的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E7%9A%84%E7%B1%BB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">隐式的类类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%81%9A%E7%9A%84%E4%BA%8B"><span class="nav-text">编译器做的事</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AA%E5%85%81%E8%AE%B8%E4%B8%80%E6%AD%A5%E7%B1%BB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">只允许一步类类型转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%B9%B6%E9%9D%9E%E6%80%BB%E6%98%AF%E6%9C%89%E6%95%88%E7%9A%84"><span class="nav-text">类类型转换并非总是有效的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%91%E5%88%B6%E9%9A%90%E5%BC%8F%E7%9A%84%E7%B1%BB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">抑制隐式的类类型转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#explicit%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%AA%E8%83%BD%E7%94%A8%E4%BA%8E%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E4%B8%8D%E8%83%BD%E6%8B%B7%E8%B4%9D%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">explicit构造函数只能用于直接初始化，不能拷贝初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#static-cast%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8explicit%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">static_cast可以使用explicit构造函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E5%90%AB%E6%9C%89explicit%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB"><span class="nav-text">标准库中含有explicit构造函数的类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%9A%E5%90%88%E7%B1%BB"><span class="nav-text">聚合类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B8%B8%E9%87%8F%E7%B1%BB%EF%BC%88skip%EF%BC%89"><span class="nav-text">字面值常量类（skip）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-6-%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-text">7.6 类的静态成员</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-text">静态成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-text">声明静态成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-text">使用静态成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-text">定义静态成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E7%B1%BB%E5%86%85%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">静态成员的类内初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%92%8C%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">静态成员和普通成员的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%A0%E9%A2%98"><span class="nav-text">习题</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Young"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Young</p>
  <div class="site-description" itemprop="description">技术, 哲学, 音乐, 生活</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">133</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


<!-- require APlayer -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">

<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
<!-- require MetingJS-->

<script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script> 
<!--playlist外链地址-->   
<meting-js
  server="netease"
  type="playlist" 
  id="7284638401"
  mini="false"
  fixed="false"
  list-folded="true"
  autoplay="true"
  volume="0.4"
  theme="#FADFA3"
  order="list"
  loop="all"
  preload="auto"
  lrc-type="1"
  mutex="true">
</meting-js>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/13/C++-Primer-Chapter-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Young">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小羊的笔记本">
      <meta itemprop="description" content="技术, 哲学, 音乐, 生活">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C++ Primer Chapter 7 | 小羊的笔记本">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++ Primer Chapter 7
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-13 22:11:23" itemprop="dateCreated datePublished" datetime="2022-02-13T22:11:23+08:00">2022-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-26 22:22:39" itemprop="dateModified" datetime="2024-02-26T22:22:39+08:00">2024-02-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="第七章-类"><a href="#第七章-类" class="headerlink" title="第七章 类"></a>第七章 类</h1><h2 id="7-1-定义抽象数据类型"><a href="#7-1-定义抽象数据类型" class="headerlink" title="7.1 定义抽象数据类型"></a>7.1 定义抽象数据类型</h2><h3 id="实现Sales-data类"><a href="#实现Sales-data类" class="headerlink" title="实现Sales_data类"></a>实现Sales_data类</h3><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ul>
<li><code>isbn</code>成员函数，用于返回对象的ISBN编号</li>
<li><code>combine</code>成员函数，用于将一个Sales_data对象加到另一个对象上</li>
<li><code>add</code>函数，执行两个Sales_data对象的加法</li>
<li><code>read</code>函数，从<code>istream</code>中读取数据到Sales_data对象中</li>
<li><code>print</code>函数，将Sales_data对象的值输出到<code>ostream</code></li>
</ul>
<h4 id="定义成员函数"><a href="#定义成员函数" class="headerlink" title="定义成员函数"></a>定义成员函数</h4><ul>
<li><strong>成员函数的声明必须在类的内部，定义则既可在类的内部，也可在类的外部</strong></li>
</ul>
<h5 id="定义在类内部的成员函数默认是inline的"><a href="#定义在类内部的成员函数默认是inline的" class="headerlink" title="定义在类内部的成员函数默认是inline的"></a>定义在类内部的成员函数默认是inline的</h5><h5 id="isbn函数"><a href="#isbn函数" class="headerlink" title="isbn函数"></a><code>isbn</code>函数</h5><ul>
<li>返回<code>Sales_data</code>的书本编号</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookno; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><ul>
<li>成员函数通过<strong>一个名为<code>this</code>的额外的隐式参数访问调用它的那个对象</strong>，当我们调用成员函数时，用请求该函数的对象的地址初始化<code>this</code></li>
<li>在成员函数内部，我们可以直接使用调用该函数的对象的成员。<strong>任何对类成员的直接访问，都被看做this的隐式引用</strong>，所以当<code>isbn</code>使用<code>bookno</code>时，就像我们使用了<code>this-&gt;bookno</code>一样</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookno; &#125;</span><br><span class="line"><span class="comment">// 尽管没必要, 但isbn可如上定义</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>this</code>是一个<strong>常量指针</strong>，不允许改变<code>this</code>的地址，任何自定义名为<code>this</code>的参数或变量的行为都是非法的</li>
</ul>
<h4 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h4><ul>
<li><code>isbn</code>函数形参列表后紧跟着<code>const</code>，这里<strong>const的作用是修改隐式<code>this</code>指针的类型</strong></li>
<li>形参列表的const表明<code>this</code>是一个指向常量的指针，因此<code>this</code>是<strong>一个指向常量的常量指针</strong></li>
<li>使用const的成员函数称为<strong>常量成员函数</strong></li>
</ul>
<h4 id="类作用域"><a href="#类作用域" class="headerlink" title="类作用域"></a>类作用域</h4><ul>
<li>类本身是一个作用域</li>
<li>编译器分两步处理类，先编译成员的声明，再处理成员函数体。因此<strong>成员函数体可随意使用类中的其他成员</strong>，无需在意声明次序</li>
</ul>
<h4 id="在类外部定义的成员函数"><a href="#在类外部定义的成员函数" class="headerlink" title="在类外部定义的成员函数"></a>在类外部定义的成员函数</h4><ul>
<li>成员函数必须在类内声明，但允许在类外进行定义</li>
<li>类外部定义的成员函数必须<strong>包含它所属的类名</strong></li>
</ul>
<h5 id="avg-price成员函数"><a href="#avg-price成员函数" class="headerlink" title="avg_price成员函数"></a><code>avg_price</code>成员函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Sales_data::avg_price</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (units_sold == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> revenue / units_sold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h4 id="定义一个返回this对象的函数"><a href="#定义一个返回this对象的函数" class="headerlink" title="定义一个返回this对象的函数"></a>定义一个返回this对象的函数</h4><h5 id="combine成员函数"><a href="#combine成员函数" class="headerlink" title="combine成员函数"></a><code>combine</code>成员函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data&amp; <span class="title">Sales_data::combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp; rhs)</span> </span>&#123;</span><br><span class="line">    units_sold += rhs.units_sold;</span><br><span class="line">    revenue += rhs.revenue;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>combine</code>应该返回指向调用该函数的对象的引用，而<code>this</code>存放了该对象的地址，因此对其解引用即可得到指向该对象的引用</li>
</ul>
<h4 id="定义类相关的非成员函数"><a href="#定义类相关的非成员函数" class="headerlink" title="定义类相关的非成员函数"></a>定义类相关的非成员函数</h4><ul>
<li>如果函数在概念上属于类，但不是类的成员函数，那么<strong>一般也和类在同一个头文件中声明</strong>，这样用户使用类接口的任何部分都只需引入一个头文件</li>
</ul>
<h5 id="定义read函数和print函数"><a href="#定义read函数和print函数" class="headerlink" title="定义read函数和print函数"></a>定义<code>read</code>函数和<code>print</code>函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::ostream &amp;<span class="title">print</span><span class="params">(std::ostream&amp; os, <span class="keyword">const</span> Sales_data&amp; item)</span> </span>&#123;</span><br><span class="line">    os &lt;&lt; item.<span class="built_in">isbn</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.revenue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.<span class="built_in">avg_price</span>();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::istream &amp;<span class="title">read</span><span class="params">(std::istream&amp; is, Sales_data&amp; item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">0</span>;</span><br><span class="line">    is &gt;&gt; item.bookno &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    item.revenue = price * item.units_sold;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>read</code>和<code>print</code>接收的都是IO类型的引用，这是因为IO类不能被拷贝，只能通过引用传递</li>
<li>此外，输入输出会改变流的内容，因此无法声明为对常量的引用，只能是普通引用</li>
</ul>
<h5 id="定义add函数"><a href="#定义add函数" class="headerlink" title="定义add函数"></a>定义<code>add</code>函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data&amp; item1, <span class="keyword">const</span> Sales_data&amp; item2)</span> </span>&#123;</span><br><span class="line">    Sales_data item = item1;</span><br><span class="line">    item.<span class="built_in">combine</span>(item2);</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul>
<li>类定义了其对象被初始化的方式，通过一个或几个特殊的成员函数控制其对象初始化的过程，这些函数称为<strong>构造函数</strong></li>
<li><p>构造函数用于<strong>初始化类对象的数据成员</strong>，只要类的对象被创建，就会执行构造函数</p>
</li>
<li><p>构造函数的基本特点</p>
<ul>
<li><p>构造函数<strong>没有返回类型</strong></p>
</li>
<li><p>函数名<strong>与类名相同</strong></p>
</li>
<li><strong>可以有多个构造函数</strong>，与其他重载函数类似</li>
<li>构造函数<strong>不能声明为const</strong>，即使是const对象在初始化过程也可以向其写值</li>
</ul>
</li>
</ul>
<h4 id="合成的默认构造函数"><a href="#合成的默认构造函数" class="headerlink" title="合成的默认构造函数"></a>合成的默认构造函数</h4><ul>
<li>如果类<strong>没有显式地定义任何构造函数</strong>，则<strong>编译器会隐式地定义一个默认构造函数，称为合成的默认构造函数</strong></li>
<li>默认构造函数的行为<ul>
<li>如果没有<strong>类内初始值</strong>，就执行<strong>默认初始化</strong></li>
</ul>
</li>
</ul>
<h4 id="不能依赖于合成的默认构造函数"><a href="#不能依赖于合成的默认构造函数" class="headerlink" title="不能依赖于合成的默认构造函数"></a>不能依赖于合成的默认构造函数</h4><ul>
<li>只有类没有定义任何构造函数时，编译器才会隐式地定义合成的默认构造函数</li>
<li>对于<strong>内置类型或复合类型</strong>，若没有提供类内初始值，将执行<strong>默认初始化</strong>，<strong>其值是未定义的</strong></li>
<li><p>有时候编译器不能为某些类合成默认的构造函数</p>
</li>
<li><p>因此，定义了其他构造函数后，应该<strong>自定义一个默认构造函数（形参列表为空）</strong></p>
</li>
</ul>
<h4 id="给Sales-data定义构造函数"><a href="#给Sales-data定义构造函数" class="headerlink" title="给Sales_data定义构造函数"></a>给<code>Sales_data</code>定义构造函数</h4><ul>
<li><p>默认构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="default的含义"><a href="#default的含义" class="headerlink" title="=default的含义"></a><code>=default</code>的含义</h5><ul>
<li>C++11规定如果需要默认行为，可以通过在参数列表后写上<code>=default</code>来要求编译器生成构造函数</li>
<li><code>=default</code>既可以与声明一起出现在类的内部，也可以作为定义出现在类的外部</li>
<li>这时候，编译器生成构造函数会执行默认初始化，因此<strong>只有保证数据成员的值不会是未定义时，才使用<code>=default</code></strong></li>
</ul>
<h5 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Sales_data</span>(<span class="keyword">const</span> std::string&amp; b, <span class="keyword">unsigned</span> u, <span class="keyword">double</span> p): <span class="built_in">bookno</span>(b), <span class="built_in">units_sold</span>(u), <span class="built_in">revenue</span>(p*u) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Sales_data</span>(<span class="keyword">const</span> std::string&amp; b): <span class="built_in">bookno</span>(b) &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>构造函数初始值列表，用于为新创建对象的一个或几个数据成员赋初值</li>
<li><p>数据成员<strong>名字后面紧跟括号括起来的成员初始值</strong>，不同成员的初始化通过<strong>逗号隔开</strong></p>
</li>
<li><p>若某个数据成员被构造函数初始值列表忽略时，它将以合成默认构造函数相同的方式进行初始化，及若有类内初始值则初始化为该值，否则默认初始化。因此没有提供类内初始值的内置类型，不应被构造函数初始值列表忽略</p>
</li>
</ul>
<h5 id="在类外定义构造函数"><a href="#在类外定义构造函数" class="headerlink" title="在类外定义构造函数"></a>在类外定义构造函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sales_data::<span class="built_in">Sales_data</span>(std::istream&amp; is) &#123;</span><br><span class="line">    <span class="built_in">read</span>(is, *<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拷贝、赋值、析构"><a href="#拷贝、赋值、析构" class="headerlink" title="拷贝、赋值、析构"></a>拷贝、赋值、析构</h3><ul>
<li>类还需要控制拷贝、赋值和销毁对象时发生的行为</li>
<li>若不主动定义，则编译器将替我们合成。</li>
</ul>
<h4 id="某些类不能依赖于合成的版本"><a href="#某些类不能依赖于合成的版本" class="headerlink" title="某些类不能依赖于合成的版本"></a>某些类不能依赖于合成的版本</h4><ul>
<li>某些类中合成的版本无法正常工作，特别是<strong>类需要分配对象之外的资源时</strong></li>
</ul>
<h2 id="7-2-访问控制与封装"><a href="#7-2-访问控制与封装" class="headerlink" title="7.2 访问控制与封装"></a>7.2 访问控制与封装</h2><h3 id="什么是封装？封装有何优点？"><a href="#什么是封装？封装有何优点？" class="headerlink" title="什么是封装？封装有何优点？"></a>什么是封装？封装有何优点？</h3><ul>
<li>实现了类的接口与实现的分离，类对外隐藏了其实现细节，类的用户只需使用接口即可，无法访问实现部分</li>
<li>封装的优点是<ul>
<li>确保用户代码<strong>不会无意间破坏封装对象的状态</strong></li>
<li>被封装的类的具体实现细节可随时改变，而<strong>无需调整用户级别的代码</strong></li>
</ul>
</li>
</ul>
<h3 id="访问说明符"><a href="#访问说明符" class="headerlink" title="访问说明符"></a>访问说明符</h3><ul>
<li><p>C++通过<strong>访问说明符</strong>加强类的封装性</p>
</li>
<li><p><strong>public说明符</strong>后的成员在整个成员内可以被访问</p>
</li>
<li><p><strong>private说明符</strong>后的成员只能被类的成员函数访问</p>
</li>
<li><p>一个类可以包含0或多个访问说明符，每个访问说明符的出现次数也没有限制</p>
</li>
</ul>
<h3 id="class和struct的区别"><a href="#class和struct的区别" class="headerlink" title="class和struct的区别"></a>class和struct的区别</h3><ul>
<li>class和struct都可用于定义类</li>
<li>唯一区别是默认访问权限<ul>
<li>struct在第一个访问说明符前的成员是public的</li>
<li>class在第一个访问说明符前的成员是private的</li>
</ul>
</li>
</ul>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><ul>
<li>想让其他类或非成员函数访问类的非公有成员，则可以<strong>让其他类或函数成为自己的友元（friend）</strong></li>
</ul>
<h4 id="把函数作为友元"><a href="#把函数作为友元" class="headerlink" title="把函数作为友元"></a>把函数作为友元</h4><ul>
<li>在类定义中<strong>增加一条以<code>friend</code>关键字开头的函数声明</strong></li>
</ul>
<h4 id="友元声明的位置"><a href="#友元声明的位置" class="headerlink" title="友元声明的位置"></a>友元声明的位置</h4><ul>
<li>友元声明必须在类定义内部，但在哪个位置不限，它不是类成员，不受访问说明符的约束</li>
<li>但最好把友元声明<strong>集中在类定义的开始，或类定义的结束位置</strong></li>
</ul>
<h4 id="友元声明"><a href="#友元声明" class="headerlink" title="友元声明"></a>友元声明</h4><ul>
<li>友元声明并非通常意义上的函数声明，因此除了在类内部进行友元声明，<strong>使用该函数前还需要有该函数本身的声明</strong></li>
<li>一般将该函数本身的声明与类定义放在同一个头文件中</li>
</ul>
<h2 id="7-3-类和其他特性"><a href="#7-3-类和其他特性" class="headerlink" title="7.3 类和其他特性"></a>7.3 类和其他特性</h2><h3 id="定义类型成员"><a href="#定义类型成员" class="headerlink" title="定义类型成员"></a>定义类型成员</h3><ul>
<li>类可以自定义某种类型在类中的别名，该<strong>类型名字也是类的成员，存在访问限制</strong>，可以是public或private中的一种</li>
<li>定义类型的成员<strong>必须先定义后使用</strong>，这与普通成员不一样</li>
</ul>
<h3 id="令成员作为内联函数"><a href="#令成员作为内联函数" class="headerlink" title="令成员作为内联函数"></a>令成员作为内联函数</h3><ul>
<li>定义在类内部的成员函数自动inline</li>
<li>在<strong>类内部声明函数时</strong>，通过inline声明该成员函数为内联</li>
<li>还可以<strong>在类外部定义时</strong>，通过inline声明该成员函数为内流</li>
</ul>
<h3 id="重载成员函数"><a href="#重载成员函数" class="headerlink" title="重载成员函数"></a>重载成员函数</h3><ul>
<li>与非成员函数类似</li>
</ul>
<h3 id="可变数据成员"><a href="#可变数据成员" class="headerlink" title="可变数据成员"></a>可变数据成员</h3><ul>
<li>通过在变量声明中假如<code>mutable</code>关键字，使得该成员为可变数据成员</li>
<li><strong>可变数据成员永远不会是const的，即使它是const对象的成员</strong></li>
<li><strong>可以通过const成员函数，改变可变数据成员的值</strong></li>
</ul>
<h3 id="类数据成员的初始值"><a href="#类数据成员的初始值" class="headerlink" title="类数据成员的初始值"></a>类数据成员的初始值</h3><ul>
<li>当我们提供类内初始值时，<strong>必须用<code>=</code>的初始化形式，或者<code>&#123;&#125;</code>括起的直接初始化形式</strong></li>
</ul>
<h3 id="返回-this的成员函数"><a href="#返回-this的成员函数" class="headerlink" title="返回*this的成员函数"></a>返回<code>*this</code>的成员函数</h3><ul>
<li><p>对于普通成员函数，返回<code>*this</code>就是返回指向本类型对象的引用</p>
</li>
<li><p>对于<strong>const成员函数</strong>，返回<code>*this</code>意味着返回<strong>指向本类型常量对象的引用</strong>。也就是说从const成员函数返回<code>*this</code>，得到的是常量引用</p>
</li>
<li><p>基于const的重载，有时候我们希望得到的是普通引用，而非常量引用，因此对于返回<code>*this</code>的成员函数，假如它不修改对象，那么可以定义重载函数，一个是const成员函数，另一个是普通成员函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Screen&amp; <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; reutrn *<span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="function">Screen&amp; <span class="title">display</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="comment">// 如上所示, const对象调用将匹配第一行版本, 非常量对象调用将匹配第二行版本</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><ul>
<li><strong>每个类定义了唯一的类型</strong>，即使两个类的成员完全一样，这两个类也是不同的类型</li>
</ul>
<h4 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h4><ul>
<li>类可以仅声明而先不定义它</li>
<li>在类声明后、定义前，它是一种<strong>不完全类型</strong></li>
</ul>
<h4 id="不完全类型可使用的场景"><a href="#不完全类型可使用的场景" class="headerlink" title="不完全类型可使用的场景"></a>不完全类型可使用的场景</h4><ul>
<li>定义指向该类型的指针或引用</li>
<li>声明（但不能定义）以该类型作为参数或返回类型的函数</li>
</ul>
<h4 id="类的成员类型不能是该类自己"><a href="#类的成员类型不能是该类自己" class="headerlink" title="类的成员类型不能是该类自己"></a>类的成员类型不能是该类自己</h4><ul>
<li>由于上述不完全类型的原因，<strong>类的成员类型不能是类自己</strong></li>
<li>但类的成员可以是指向该类的指针或引用</li>
</ul>
<h3 id="友元-1"><a href="#友元-1" class="headerlink" title="友元"></a>友元</h3><ul>
<li>除了把普通函数定义为友元外，还可以<strong>把其他类定义为友元，还可以把其他类的成员函数定义为友元</strong></li>
</ul>
<h4 id="类之间的友元关系"><a href="#类之间的友元关系" class="headerlink" title="类之间的友元关系"></a>类之间的友元关系</h4><ul>
<li><p>指定友元类，可在类定义的开头位置添加以下友元声明，则类C成为友元类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span>;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果一个指定了友元类，则友元类的成员函数可以访问此类的private和public成员</p>
</li>
<li>友元不具有传递性。每个类负责控制自己的友元类或友元函数。</li>
</ul>
<h4 id="令成员函数作为友元"><a href="#令成员函数作为友元" class="headerlink" title="令成员函数作为友元"></a>令成员函数作为友元</h4><ul>
<li><p>将某个类的某个成员函数声明为友元，则该类的该成员函数能否访问此类的private和public成员</p>
</li>
<li><p>需要明确指出该成员函数属于哪个类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">int</span> <span class="title">C::func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// 该友元是C类的成员函数func</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="令成员函数作为友元的定义步骤"><a href="#令成员函数作为友元的定义步骤" class="headerlink" title="令成员函数作为友元的定义步骤"></a>令成员函数作为友元的定义步骤</h5><ul>
<li>假设<strong>想要令类A的成员函数f作为类B的友元</strong>，必须按照以下方式设计程序<ul>
<li>定义类A，声明函数f，但不能定义它</li>
<li>定义类B，包含对<code>A::f</code>的友元声明</li>
<li>定义类A的成员函数f，此时它才可以使用类B的成员</li>
</ul>
</li>
</ul>
<h4 id="友元与重载函数"><a href="#友元与重载函数" class="headerlink" title="友元与重载函数"></a>友元与重载函数</h4><ul>
<li>假如类想要让一组重载函数成为自己的友元，则必须<strong>对其中的每个函数分别声明</strong></li>
</ul>
<h4 id="友元声明与作用域"><a href="#友元声明与作用域" class="headerlink" title="友元声明与作用域"></a>友元声明与作用域</h4><ul>
<li>类和非成员函数的声明不一定在它们的友元声明之前</li>
<li>因此，我们在调用友元函数前需要确保它已经被声明</li>
<li>即使友元函数的定义连同友元声明，出现在了类的内部，它也需要在声明后才能使用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="comment">/* 友元函数定义在类的内部*/</span> &#125;</span><br><span class="line">    <span class="built_in">X</span>() &#123; <span class="built_in">f</span>(); &#125;	<span class="comment">// 非法, 友元函数并未声明</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">X::g</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">f</span>(); &#125;	<span class="comment">// 非法, 友元函数并未声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;			<span class="comment">// 这是函数f第一次被声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">X::h</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">f</span>(); &#125;	<span class="comment">// 合法, 该友元函数已经被声明</span></span><br></pre></td></tr></table></figure>
<h4 id="关键在于，友元声明的作用只改变访问权限，它无法取代普通意义上的声明"><a href="#关键在于，友元声明的作用只改变访问权限，它无法取代普通意义上的声明" class="headerlink" title="关键在于，友元声明的作用只改变访问权限，它无法取代普通意义上的声明"></a>关键在于，友元声明的作用只改变访问权限，它无法取代普通意义上的声明</h4><h2 id="7-4-类的作用域"><a href="#7-4-类的作用域" class="headerlink" title="7.4 类的作用域"></a>7.4 类的作用域</h2><h3 id="作用域和定义在类外部的成员"><a href="#作用域和定义在类外部的成员" class="headerlink" title="作用域和定义在类外部的成员"></a>作用域和定义在类外部的成员</h3><ul>
<li>一个类就是一个作用域，因此定义在类外部的成员函数，必须通过<code>类名::函数名</code>的形式定义</li>
<li><p><strong>一旦遇到类名，定义的剩余部分（函数形参列表、函数体）就位于类作用域之内了</strong>，可以直接使用类的其他成员，无需再次通过作用域运算符取得</p>
</li>
<li><p>特别地，返回类型出现在类名前，因此<strong>如果返回类型是类成员，需要通过作用域运算符取得授权</strong></p>
</li>
</ul>
<h3 id="名字查找与类的作用域"><a href="#名字查找与类的作用域" class="headerlink" title="名字查找与类的作用域"></a>名字查找与类的作用域</h3><h4 id="类的定义分两步处理"><a href="#类的定义分两步处理" class="headerlink" title="类的定义分两步处理"></a>类的定义分两步处理</h4><ul>
<li>先编译成员的声明</li>
<li>直到类全部可见后，才编译函数体</li>
<li>因此，成员函数体可以使用类中声明或定义的任何名字，不管声明或定义的次序</li>
</ul>
<h4 id="类型名的特殊之处"><a href="#类型名的特殊之处" class="headerlink" title="类型名的特殊之处"></a>类型名的特殊之处</h4><ul>
<li>一般地，假如内层作用域使用了外层作用域的名字，该名字仍可以在内层作用域中重新定义</li>
<li>在<strong>类中</strong>，假如<strong>使用了外层作用域中的某个类型名，则不能重新定义该名字</strong></li>
<li>最好在类的开始处，进行类型名的定义</li>
</ul>
<h3 id="成员定义中的普通块作用域的名字查找"><a href="#成员定义中的普通块作用域的名字查找" class="headerlink" title="成员定义中的普通块作用域的名字查找"></a>成员定义中的普通块作用域的名字查找</h3><ul>
<li>成员函数中使用的名字按以下方式解析<ul>
<li>首先，在<strong>成员函数内</strong>查找该名字的声明，只查找该名字使用前的部分</li>
<li>然后，在<strong>类内</strong>继续查找，所有成员都将考虑</li>
<li>最后，在<strong>成员函数定义之前的作用域内</strong>继续查找</li>
</ul>
</li>
</ul>
<h2 id="7-5-构造函数深入"><a href="#7-5-构造函数深入" class="headerlink" title="7.5 构造函数深入"></a>7.5 构造函数深入</h2><h3 id="初始化与赋值的区别"><a href="#初始化与赋值的区别" class="headerlink" title="初始化与赋值的区别"></a>初始化与赋值的区别</h3><ul>
<li><p>考虑以下构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="built_in">A</span> (<span class="keyword">const</span> string &amp;s, <span class="keyword">unsigned</span> cnt, <span class="keyword">double</span> price): <span class="built_in">bookno</span>(s), <span class="built_in">units_soldj</span>(cnt), <span class="built_in">revenue</span>(price*cnt) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>该构造函数使用了构造函数的初始值列表为数据成员初始化，考虑以下构造函数，在构造函数将初始值赋给了各个数据成员，两者看似拥有一样的效果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="built_in">A</span> (<span class="keyword">const</span> string &amp;s, <span class="keyword">unsigned</span> cnt, <span class="keyword">double</span> price) &#123;</span><br><span class="line">      bookno = s;</span><br><span class="line">      units_sold = cnt;</span><br><span class="line">      revenue = price * cnt;</span><br><span class="line">  &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>但实则是有区别的，对于<strong>const成员、引用类型和未提供默认构造函数的类成员</strong>，必须通过构造函数初始值列表对其初始化，而非赋值。如下例所示</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span> (<span class="keyword">int</span> i) &#123;</span><br><span class="line">			cnt = i;		<span class="comment">// 非法, cnt是const int, 无法对其赋值</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">const</span> <span class="keyword">int</span> cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="成员初始化的顺序"><a href="#成员初始化的顺序" class="headerlink" title="成员初始化的顺序"></a>成员初始化的顺序</h3><ul>
<li>构造函数初始值列表只说明用于初始化成员的值，不限定初始化的具体执行顺序</li>
<li><strong>成员的初始化顺序与它们在类中定义的顺序一致</strong></li>
<li>因此，尽量<strong>避免使用某些成员初始化其他成员</strong></li>
</ul>
<h3 id="构造函数的默认实参"><a href="#构造函数的默认实参" class="headerlink" title="构造函数的默认实参"></a>构造函数的默认实参</h3><ul>
<li>假如一个构造函数<strong>为所有数据成员都提供了默认实参</strong>，那么它实际上定义了<strong>默认构造函数</strong></li>
</ul>
<h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><ul>
<li><p>C++11允许我们定义<strong>委托构造函数</strong>，它使用其所属类的其他构造函数执行自己的初始化过程</p>
</li>
<li><p>成员初始值列表只有一个唯一入口，就是<strong>类名本身，紧跟圆括号括起的参数列表</strong>，该列表必须与类中另外一个构造函数匹配</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">X</span>(<span class="keyword">int</span> i, <span class="keyword">double</span> j): <span class="built_in">v1</span>(i), <span class="built_in">v2</span>(j) &#123;&#125;</span><br><span class="line"><span class="built_in">X</span>(): <span class="built_in">X</span>(<span class="number">0</span>, <span class="number">0</span>) &#123;&#125;			<span class="comment">// 委托给第一个构造函数</span></span><br><span class="line"><span class="built_in">X</span>(<span class="keyword">int</span> i): <span class="built_in">X</span>(i, <span class="number">0</span>) &#123;&#125;	<span class="comment">// 委托给第一个构造函数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>委托构造函数初始化时，<strong>被委托的构造函数的初始值列表和函数体依次被执行</strong></p>
</li>
</ul>
<h3 id="默认构造函数的作用"><a href="#默认构造函数的作用" class="headerlink" title="默认构造函数的作用"></a>默认构造函数的作用</h3><ul>
<li>当对象被默认初始化或值初始化时，自动执行默认构造函数</li>
<li>默认初始化发生的场景<ul>
<li>块作用域内，不使用任何初始值定义一个非静态变量，或数组时</li>
<li>当一个类含有类类型成员，且使用了合成的默认构造函数时</li>
<li>类类型的成员没有在构造函数初始值列表中显式地初始化时</li>
</ul>
</li>
<li>值初始化发生的场景<ul>
<li>数组初始化时，提供的初始值数量少于数组大小</li>
<li>不使用初始值定义一个局部静态变量时</li>
<li>通过形如<code>T()</code>表达式显式地请求值初始化时，其中T是类型名</li>
</ul>
</li>
</ul>
<h3 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h3><ul>
<li><p>如果<strong>构造函数只接受一个实参</strong>，则它实际上定义了转换为此类类型的隐式转换机制，这种构造函数可称为<strong>转换构造函数</strong></p>
</li>
<li><p>如Sales_data类有接受一个string的构造函数，则<strong>在需要使用Sales_data的地方可以通过一个string替代</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string book = <span class="string">&quot;123-145-1839&quot;</span>;</span><br><span class="line">item.<span class="built_in">combine</span>(book);</span><br></pre></td></tr></table></figure>
<ul>
<li>item是一个Sales_data对象, 其combine函数应该接受一个Sales_data对象, 此处传入string也能成功调用</li>
</ul>
</li>
</ul>
<h4 id="编译器做的事"><a href="#编译器做的事" class="headerlink" title="编译器做的事"></a>编译器做的事</h4><ul>
<li>此处编译器用给定的string自动创建了一个<code>Sales_data</code>对象，这个临时的<code>Sales_data</code>对象被传递给<code>combine</code></li>
</ul>
<h4 id="只允许一步类类型转换"><a href="#只允许一步类类型转换" class="headerlink" title="只允许一步类类型转换"></a>只允许一步类类型转换</h4><ul>
<li>编译器<strong>只会自动地执行一步类型转换</strong>，假如我们想用一个字符串字面值代替Sales_data对象，那么编译器要先将其转换为string对象，再转为Sales_data对象，这是编译器无法完成的，因此会错误</li>
</ul>
<h4 id="类类型转换并非总是有效的"><a href="#类类型转换并非总是有效的" class="headerlink" title="类类型转换并非总是有效的"></a>类类型转换并非总是有效的</h4><h4 id="抑制隐式的类类型转换"><a href="#抑制隐式的类类型转换" class="headerlink" title="抑制隐式的类类型转换"></a>抑制隐式的类类型转换</h4><ul>
<li>这种类类型转换可能并非我们想要的，想要阻止编译器的自动转换，可以<strong>通过在构造函数声明时加上<code>explicit</code>加以阻止</strong></li>
<li><code>explicit</code><strong>只对接受一个实参的构造函数有效</strong></li>
<li>只需在类内部声明构造函数时指定<code>explicit</code>，<strong>在内外定义时无需指定</strong></li>
</ul>
<h4 id="explicit构造函数只能用于直接初始化，不能拷贝初始化"><a href="#explicit构造函数只能用于直接初始化，不能拷贝初始化" class="headerlink" title="explicit构造函数只能用于直接初始化，不能拷贝初始化"></a>explicit构造函数只能用于直接初始化，不能拷贝初始化</h4><ul>
<li>当我们执行拷贝初始化时（使用<code>=</code>），也会发生隐式转换</li>
<li>当构造函数被指定为explicit时，将无法使用拷贝初始化，只能直接初始化</li>
</ul>
<h4 id="static-cast可以使用explicit构造函数"><a href="#static-cast可以使用explicit构造函数" class="headerlink" title="static_cast可以使用explicit构造函数"></a>static_cast可以使用explicit构造函数</h4><ul>
<li><p>尽管explicit阻止了编译器的隐式转换，当可以通过显式转换的形式进行强制转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string book = <span class="string">&quot;123-145-1839&quot;</span>;</span><br><span class="line">item.<span class="built_in">combine</span>(<span class="keyword">static_cast</span>&lt;Sales_data&gt;(book));</span><br></pre></td></tr></table></figure>
</li>
<li><p>此外，还可通过该构造函数创建一个临时对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string book = <span class="string">&quot;123-145-1839&quot;</span>;</span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">Sales_data</span>(book));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="标准库中含有explicit构造函数的类"><a href="#标准库中含有explicit构造函数的类" class="headerlink" title="标准库中含有explicit构造函数的类"></a>标准库中含有explicit构造函数的类</h3><ul>
<li>接受一个单参数的<code>const char*</code>的string构造函数不是explicit的</li>
<li>接受一个单参数的vector构造函数是explicit的</li>
<li>原因是，一般地，我们可以用字符串字面值代替string，这种隐式转换是合理的；但是，我们不能用一个整数代替vector，因此单参数的vector构造函数是explicit的</li>
</ul>
<h3 id="聚合类"><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h3><ul>
<li><strong>聚合类</strong>的条件<ul>
<li><strong>所有成员都是public的</strong></li>
<li><strong>没有定义任何构造函数</strong></li>
<li><strong>没有类内初始值</strong></li>
<li><strong>没有基类，没有virtual函数</strong></li>
</ul>
</li>
<li>聚合类使得用户可以直接访问其成员，并且具有特殊的初始化语法形式</li>
<li>聚合类的初始化<ul>
<li>使用<strong>列表初始化</strong>，初始值的顺序必须与声明的顺序一致</li>
<li>如果列表的元素个数少于类的成员变量，则靠后的成员变量被<strong>值初始化</strong></li>
</ul>
</li>
</ul>
<h3 id="字面值常量类（skip）"><a href="#字面值常量类（skip）" class="headerlink" title="字面值常量类（skip）"></a>字面值常量类（skip）</h3><h2 id="7-6-类的静态成员"><a href="#7-6-类的静态成员" class="headerlink" title="7.6 类的静态成员"></a>7.6 类的静态成员</h2><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><ul>
<li>当我们需要成员与类本身直接相关，而不是与类的各个对象关联时，需要使用类的静态成员</li>
<li><strong>类的静态成员存在于任何对象之外</strong>，类的对象不包含任何与静态数据成员有关的数据</li>
</ul>
<h3 id="声明静态成员"><a href="#声明静态成员" class="headerlink" title="声明静态成员"></a>声明静态成员</h3><ul>
<li>成员声明前加上<code>static</code>关键字</li>
<li>静态成员可以是public或private的，可以是常量、引用、指针、类类型等</li>
<li><strong>类的静态数据成员只有一个，被所有该类的对象共享</strong></li>
<li><strong>类的静态成员函数</strong>不与任何对象绑定在一起，<strong>不含有this指针，也不能声明成const的</strong></li>
</ul>
<h3 id="使用静态成员"><a href="#使用静态成员" class="headerlink" title="使用静态成员"></a>使用静态成员</h3><ul>
<li><p>可使用<strong>作用域运算符</strong>直接访问静态成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> r = Account::<span class="built_in">rate</span>();		<span class="comment">// rate()是Account类的静态成员函数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>虽然静态成员不属于任何一个对象，但仍<strong>可以通过类的对象、引用或指针访问静态成员</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Account ac1;</span><br><span class="line">r = ac1.<span class="built_in">rate</span>();		<span class="comment">// 通过Account类的对象访问静态成员</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>类的成员函数</strong>不需要使用作用域运算符，<strong>可直接访问静态成员</strong></p>
</li>
</ul>
<h3 id="定义静态成员"><a href="#定义静态成员" class="headerlink" title="定义静态成员"></a>定义静态成员</h3><ul>
<li>既可以在类的内部、也可以在外部定义静态成员函数，在外部定义时，<strong>不能重复static关键字</strong>，它只出现在类内的成员函数声明</li>
<li><strong>一般地，在类的外部定义并初始化每个静态成员</strong></li>
</ul>
<h3 id="静态成员的类内初始化"><a href="#静态成员的类内初始化" class="headerlink" title="静态成员的类内初始化"></a>静态成员的类内初始化</h3><ul>
<li>应该在类外定义并初始化静态成员。但也可以<strong>在类内声明静态成员时，提供类内初始值</strong>，要求初始值必须是<strong>字面值常量类型的<code>constexpr</code></strong></li>
<li>如果提供了类内初始值，那么在类外定义该静态成员时不能再指定一个初始值了</li>
<li><strong>即使提供了类内初始值，最好也在类外定义该初始值</strong></li>
</ul>
<h3 id="静态成员和普通成员的区别"><a href="#静态成员和普通成员的区别" class="headerlink" title="静态成员和普通成员的区别"></a>静态成员和普通成员的区别</h3><ul>
<li>静态成员可以是不完全类型的，特别地，<strong>静态成员可以是它所属的类类型的</strong>。而普通成员不能时它所属的类类型的</li>
<li>我们<strong>可以使用静态成员作为默认实参</strong>，而不能使用普通成员作为默认实参</li>
</ul>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><ul>
<li><p>定义类A和类B，其中函数f是B的成员，是A的友元</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">B::f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">   		<span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">B::f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    cout &lt;&lt; a.i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>先定义类B，声明f但不定义它</li>
<li>然后定义类A，友元声明</li>
<li>最后在类B外定义成员f，可以使用类A的private和public成员</li>
</ul>
</li>
<li><p>说明以下代码的<code>Type</code>和<code>initVal</code>分别使用了哪个定义，代码存在错误吗?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> string Type;</span><br><span class="line"><span class="function">Type <span class="title">initVal</span><span class="params">()</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exercise</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">typedef</span> <span class="keyword">double</span> Type;</span><br><span class="line">    	<span class="function">Type <span class="title">setVal</span><span class="params">(Type)</span></span>;</span><br><span class="line">    	<span class="function">Type <span class="title">initVal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这里返回类型的Type指string, 形参的Type指double</span></span><br><span class="line"><span class="comment">// 应该将返回类型修改为Exercise::Type</span></span><br><span class="line"><span class="function">Type <span class="title">Exercise::setVal</span><span class="params">(Type parm)</span> </span>&#123;</span><br><span class="line">    val = parm + <span class="built_in">initVal</span>();</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为什么接受单参数的string构造函数不是explicit的，而接受单参数的vector构造函数是explicit的</p>
</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Young
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://example.com/2022/02/13/C++-Primer-Chapter-7/" title="C++ Primer Chapter 7">http://example.com/2022/02/13/C++-Primer-Chapter-7/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/02/13/C++-Primer-%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%E9%9B%86/" rel="prev" title="C++ Primer 关键问题集">
                  <i class="fa fa-chevron-left"></i> C++ Primer 关键问题集
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/02/15/C++-Primer-Chapter-8/" rel="next" title="C++ Primer Chapter 8">
                  C++ Primer Chapter 8 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Young</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  




  <script src="/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
