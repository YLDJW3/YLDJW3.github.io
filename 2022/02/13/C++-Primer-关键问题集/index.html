<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.11.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="C++ Primer各章节关键问题总结">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Primer 关键问题集">
<meta property="og:url" content="http://example.com/2022/02/13/C++-Primer-%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%E9%9B%86/index.html">
<meta property="og:site_name" content="元朗食品">
<meta property="og:description" content="C++ Primer各章节关键问题总结">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-02-13T13:39:36.000Z">
<meta property="article:modified_time" content="2022-04-08T12:08:32.853Z">
<meta property="article:author" content="Young">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2022/02/13/C++-Primer-%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%E9%9B%86/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2022/02/13/C++-Primer-%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%E9%9B%86/","path":"2022/02/13/C++-Primer-关键问题集/","title":"C++ Primer 关键问题集"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C++ Primer 关键问题集 | 元朗食品</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">元朗食品</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC6%E7%AB%A0-%E5%87%BD%E6%95%B0"><span class="nav-text">第6章 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80"><span class="nav-text">函数基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-text">函数传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%92%8Creturn%E8%AF%AD%E5%8F%A5"><span class="nav-text">返回类型和return语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="nav-text">函数重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E7%94%A8%E9%80%94%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7"><span class="nav-text">特殊用途语言特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8C%B9%E9%85%8D"><span class="nav-text">函数匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-text">函数指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%A0%E9%A2%98"><span class="nav-text">习题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC7%E7%AB%A0-%E7%B1%BB"><span class="nav-text">第7章 类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">定义抽象数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E6%9E%90%E6%9E%84"><span class="nav-text">拷贝、赋值、析构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B0%81%E8%A3%85"><span class="nav-text">访问控制与封装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-text">封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="nav-text">访问说明符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8B%E5%85%83"><span class="nav-text">友元</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7"><span class="nav-text">类和其他特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E6%88%90%E5%91%98"><span class="nav-text">类成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9Ethis%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">返回*this的成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%B1%BB%E5%9E%8B"><span class="nav-text">类类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8B%E5%85%83-1"><span class="nav-text">友元</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">类的作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%86%8D%E8%B0%88"><span class="nav-text">构造函数再谈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%80%BC%E5%88%97%E8%A1%A8"><span class="nav-text">构造函数初始值列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">委托构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">默认构造函数的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E7%9A%84%E7%B1%BB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">隐式的类类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%9A%E5%90%88%E7%B1%BB"><span class="nav-text">聚合类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-text">类的静态成员</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC8%E7%AB%A0-io%E5%BA%93"><span class="nav-text">第8章 IO库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#io%E7%B1%BB"><span class="nav-text">IO类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E7%8A%B6%E6%80%81"><span class="nav-text">条件状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2"><span class="nav-text">管理输出缓冲</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E8%BE%93%E5%85%A5%E6%B5%81%E5%92%8C%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-text">关联输入流和输出流</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-text">文件输入输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%96%87%E4%BB%B6%E6%B5%81%E5%AF%B9%E8%B1%A1"><span class="nav-text">使用文件流对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%A8%A1%E5%BC%8F"><span class="nav-text">文件模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string%E7%B1%BB"><span class="nav-text">string类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC9%E7%AB%A0-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="nav-text">第9章 顺序容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="nav-text">顺序容器概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%9E%8B%E9%80%89%E6%8B%A9"><span class="nav-text">顺序容器类型选择</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E5%BA%93%E6%A6%82%E8%A7%88"><span class="nav-text">容器库概览</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%9E%8B%E6%88%90%E5%91%98"><span class="nav-text">容器类型成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#begin%E5%92%8Cend%E6%88%90%E5%91%98"><span class="nav-text">begin和end成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">容器定义和初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E5%92%8Cswap"><span class="nav-text">赋值和swap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8assign"><span class="nav-text">使用assign</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8swap"><span class="nav-text">使用swap</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C"><span class="nav-text">容器大小操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">关系运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C"><span class="nav-text">顺序容器操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="nav-text">添加元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0"><span class="nav-text">访问元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-text">删除元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84forward_list%E6%93%8D%E4%BD%9C"><span class="nav-text">特殊的forward_list操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E5%8F%98%E5%AE%B9%E5%99%A8%E5%A4%A7%E5%B0%8F"><span class="nav-text">改变容器大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C%E5%8F%AF%E8%83%BD%E4%BD%BF%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88"><span class="nav-text">容器操作可能使迭代器失效</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vector%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A2%9E%E9%95%BF"><span class="nav-text">vector对象的增长</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%9D%E5%A4%96%E7%9A%84string%E6%93%8D%E4%BD%9C"><span class="nav-text">额外的string操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E6%93%8D%E4%BD%9C"><span class="nav-text">搜索操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E8%BD%AC%E6%8D%A2"><span class="nav-text">数值转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="nav-text">容器适配器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95"><span class="nav-text">第十章 泛型算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-text">10.1 概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">10.2 泛型算法的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AA%E8%AF%BB%E7%AE%97%E6%B3%95"><span class="nav-text">只读算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-text">写容器元素的算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%8E%92%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-text">重排容器元素的算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E5%88%B6%E6%93%8D%E4%BD%9C"><span class="nav-text">10.3 定制操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%91%E7%AE%97%E6%B3%95%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0"><span class="nav-text">10.3.1 向算法传递函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">10.3.2 lambda表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda%E6%8D%95%E8%8E%B7%E5%92%8C%E8%BF%94%E5%9B%9E"><span class="nav-text">10.3.3 lambda捕获和返回</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A"><span class="nav-text">10.3.4 参数绑定</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%8D%E6%8E%A2%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">10.4 再探迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">插入迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">流迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">反向迭代器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%84"><span class="nav-text">10.5 泛型算法结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E5%AE%9A%E5%AE%B9%E5%99%A8%E7%AE%97%E6%B3%95list%E5%92%8Cforward_list"><span class="nav-text">10.6
特定容器算法（list和forward_list）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93"><span class="nav-text">10.7 泛型算法总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC11%E7%AB%A0-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="nav-text">第11章 关联容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="nav-text">11.2 关联容器概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pair%E7%B1%BB%E5%9E%8B"><span class="nav-text">pair类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C"><span class="nav-text">11.3 关联容器操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0-1"><span class="nav-text">添加元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0-1"><span class="nav-text">删除元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map%E7%9A%84%E4%B8%8B%E6%A0%87%E6%93%8D%E4%BD%9C"><span class="nav-text">map的下标操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0-1"><span class="nav-text">访问元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="nav-text">11.4 无序容器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC12%E7%AB%A0-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98"><span class="nav-text">第12章 动态内存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-text">12.1 动态内存与智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#shared_ptr%E7%B1%BB"><span class="nav-text">shared_ptr类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#shared_ptr%E7%9A%84%E6%8B%B7%E8%B4%9D%E5%92%8C%E8%B5%8B%E5%80%BC"><span class="nav-text">shared_ptr的拷贝和赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shared_ptr%E8%87%AA%E5%8A%A8%E9%94%80%E6%AF%81%E6%89%80%E7%AE%A1%E7%90%86%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-text">shared_ptr自动销毁所管理的对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E7%94%9F%E5%AD%98%E6%9C%9F%E8%B5%84%E6%BA%90%E7%9A%84%E7%B1%BB"><span class="nav-text">使用动态生存期资源的类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8new%E5%92%8Cdelete%E7%9B%B4%E6%8E%A5%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98"><span class="nav-text">使用new和delete直接管理内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#new"><span class="nav-text">new</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#delete"><span class="nav-text">delete</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF"><span class="nav-text">动态内存管理的常见错误</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shared_ptr%E5%92%8Cnew%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8"><span class="nav-text">shared_ptr和new结合使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#shared_ptr%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">shared_ptr的初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E8%A6%81%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8%E6%99%AE%E9%80%9A%E6%8C%87%E9%92%88%E5%92%8C%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-text">不要混合使用普通指针和智能指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E8%A6%81%E7%94%A8get%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%88%96%E4%B8%BA%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%B5%8B%E5%80%BC"><span class="nav-text">不要用get初始化另一个智能指针，或为智能指针赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reset%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">reset成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unique%E5%92%8Cuse_count%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">unique和use_count成员函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="nav-text">智能指针和异常</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E9%87%8A%E6%94%BE%E6%93%8D%E4%BD%9C"><span class="nav-text">使用自定义的释放操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%BD%BF%E7%94%A8%E7%9A%84%E6%A0%87%E5%87%86%E8%A7%84%E8%8C%83"><span class="nav-text">智能指针使用的标准规范</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unique_ptr%E7%B1%BB"><span class="nav-text">unique_ptr类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#unique_ptr%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">unique_ptr的定义和初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#release%E5%92%8Creset%E8%BD%AC%E7%A7%BB%E6%8C%87%E9%92%88%E6%89%80%E6%9C%89%E6%9D%83"><span class="nav-text">release和reset转移指针所有权</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%94%E5%9B%9Eunique_ptr"><span class="nav-text">返回unique_ptr</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91unique_ptr%E4%BC%A0%E9%80%92%E5%88%A0%E9%99%A4%E5%99%A8"><span class="nav-text">向unique_ptr传递删除器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#weak_ptr%E7%B1%BB"><span class="nav-text">weak_ptr类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="nav-text">12.2 动态数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#new%E5%92%8C%E6%95%B0%E7%BB%84"><span class="nav-text">new和数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#allocator%E7%B1%BB"><span class="nav-text">allocator类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC13%E7%AB%A0-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6"><span class="nav-text">第13章 拷贝控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E4%B8%8E%E9%94%80%E6%AF%81"><span class="nav-text">13.1 拷贝、赋值与销毁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">拷贝构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E6%88%90%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">合成拷贝构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">拷贝初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-text">参数和返回值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">拷贝赋值运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E6%88%90%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">合成拷贝赋值运算符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-text">析构函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E6%88%90%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-text">合成析构函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E4%BA%94%E6%B3%95%E5%88%99"><span class="nav-text">三&#x2F;五法则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8default"><span class="nav-text">使用&#x3D;default</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E6%AD%A2%E6%8B%B7%E8%B4%9D"><span class="nav-text">阻止拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%88%A0%E9%99%A4%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-text">定义删除的函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E6%98%AF%E5%88%A0%E9%99%A4%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-text">析构函数不能是删除的函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E6%88%90%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E6%88%90%E5%91%98%E5%8F%AF%E8%83%BD%E6%98%AF%E5%88%A0%E9%99%A4%E7%9A%84"><span class="nav-text">合成的拷贝控制成员可能是删除的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#private%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6"><span class="nav-text">private拷贝控制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E5%92%8C%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="nav-text">13.2 拷贝控制和资源管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E6%93%8D%E4%BD%9C"><span class="nav-text">13.3 交换操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%AD%E4%BD%BF%E7%94%A8swap"><span class="nav-text">在赋值运算符中使用swap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%A7%BB%E5%8A%A8"><span class="nav-text">13.6 对象移动</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-text">13.6.1 右值引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A6%E5%80%BC%E6%8C%81%E4%B9%85%E5%8F%B3%E5%80%BC%E7%9F%AD%E6%9A%82"><span class="nav-text">左值持久、右值短暂</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%BA%93move%E5%87%BD%E6%95%B0"><span class="nav-text">标准库move函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">13.6.2
移动构造函数和移动赋值运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E6%93%8D%E4%BD%9C%E6%A0%87%E5%87%86%E5%BA%93%E5%AE%B9%E5%99%A8%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="nav-text">移动操作、标准库容器和异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">移动赋值运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E5%90%8E%E6%BA%90%E5%AF%B9%E8%B1%A1"><span class="nav-text">移后源对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E6%88%90%E7%9A%84%E7%A7%BB%E5%8A%A8%E6%93%8D%E4%BD%9C"><span class="nav-text">合成的移动操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E5%B7%A6%E5%80%BC%E6%8B%B7%E8%B4%9D%E5%8F%B3%E5%80%BC"><span class="nav-text">移动左值、拷贝右值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E4%BA%94%E6%B3%95%E5%88%99-1"><span class="nav-text">三&#x2F;五法则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">移动迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E8%A6%81%E8%BD%BB%E6%98%93%E4%BD%BF%E7%94%A8%E7%A7%BB%E5%8A%A8%E6%93%8D%E4%BD%9C"><span class="nav-text">不要轻易使用移动操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">13.6.3 右值引用和成员函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC14%E7%AB%A0-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">第14章 重载运算与类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">14.1 基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">14.2 输入和输出关系运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E5%92%8C%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">14.3 算术和关系运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">算术运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">相等运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6-1"><span class="nav-text">关系运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">14.4 赋值运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%90%88%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">复合赋值运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8B%E6%A0%87%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">14.5 下标运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%A2%9E%E5%92%8C%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">14.6 递增和递减运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E7%BD%AE%E7%89%88%E6%9C%AC"><span class="nav-text">前置版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E7%BD%AE%E7%89%88%E6%9C%AC"><span class="nav-text">后置版本</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">14.7 成员访问运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%AD%E5%A4%B4%E8%BF%90%E7%AE%97%E7%AC%A6%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E9%99%90%E5%AE%9A"><span class="nav-text">箭头运算符返回值的限定</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">14.8 函数调用运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda%E6%98%AF%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="nav-text">lambda是函数对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E7%A4%BAlambda%E5%8F%8A%E7%9B%B8%E5%BA%94%E6%8D%95%E8%8E%B7%E8%A1%8C%E4%B8%BA%E7%9A%84%E7%B1%BB"><span class="nav-text">表示lambda及相应捕获行为的类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E4%B8%8Efunction"><span class="nav-text">可调用对象与function</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%BA%93function%E7%B1%BB%E5%9E%8B"><span class="nav-text">标准库function类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">14.9 重载、类型转换与运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">类型转换运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">显式的类型转换运算符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E6%9C%89%E4%BA%8C%E4%B9%89%E6%80%A7%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">避免有二义性的类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8C%B9%E9%85%8D%E4%B8%8E%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">函数匹配与重载运算符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC15%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-text">第15章 面向对象程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#oop%E6%A6%82%E8%BF%B0"><span class="nav-text">15.1 OOP概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="nav-text">15.2 定义基类和派生类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%9F%BA%E7%B1%BB"><span class="nav-text">定义基类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="nav-text">定义派生类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="nav-text">类型转换与继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-text">15.3 虚函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="nav-text">15.4 抽象基类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="nav-text">15.5 访问控制与继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#protected"><span class="nav-text">protected</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#publicprivateprotected%E7%BB%A7%E6%89%BF"><span class="nav-text">public、private、protected继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%90%91%E5%9F%BA%E7%B1%BB%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7"><span class="nav-text">派生类向基类转换的可访问性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E5%8F%98%E4%B8%AA%E5%88%AB%E5%90%8D%E5%AD%97%E7%9A%84%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7"><span class="nav-text">改变个别名字的可访问性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">15.6 继承中的类作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6"><span class="nav-text">15.7 构造函数与拷贝控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-text">虚析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E6%88%90%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="nav-text">合成拷贝控制与继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E6%88%90%E5%91%98"><span class="nav-text">派生类的拷贝控制成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">继承的构造函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="nav-text">15.8 容器与继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A5%E5%85%85-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="nav-text">补充 虚函数表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC18%E7%AB%A0-%E7%94%A8%E4%BA%8E%E5%A4%A7%E5%9E%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="nav-text">第18章 用于大型程序的工具</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">18.1 异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="nav-text">抛出异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="nav-text">捕获异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E5%8C%B9%E9%85%8D%E7%9A%84%E5%A4%84%E7%90%86%E4%BB%A3%E7%A0%81"><span class="nav-text">查找匹配的处理代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0try%E8%AF%AD%E5%8F%A5%E5%9D%97%E4%B8%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">函数try语句块与构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#noexcept%E5%BC%82%E5%B8%B8%E8%AF%B4%E6%98%8E"><span class="nav-text">noexcept异常说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1"><span class="nav-text">异常类层次</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-text">18.2 命名空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="nav-text">18.3 多重继承</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC19%E7%AB%A0-%E7%89%B9%E6%AE%8A%E5%B7%A5%E5%85%B7%E4%B8%8E%E6%8A%80%E6%9C%AF"><span class="nav-text">第19章 特殊工具与技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-text">19.1 控制内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BDnew%E5%92%8Cdelete"><span class="nav-text">重载new和delete</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%BD%8Dnew%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">定位new表达式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB"><span class="nav-text">19.2 运行时类型识别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dynamic_cast%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">dynamic_cast运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#typeid%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">typeid运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rtti%E4%BD%BF%E7%94%A8"><span class="nav-text">RTTI使用</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Young"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Young</p>
  <div class="site-description" itemprop="description">Talk is cheap, show me the code.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">131</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


<!-- require APlayer -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">

<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
<!-- require MetingJS-->

<script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script> 
<!--playlist外链地址-->   
<meting-js
  server="tencent"
  type="playlist" 
  id="8356942170"
  mini="false"
  fixed="false"
  list-folded="true"
  autoplay="false"
  volume="0.4"
  theme="#FADFA3"
  order="list"
  loop="all"
  preload="auto"
  lrc-type="1"
  mutex="true">
</meting-js>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/13/C++-Primer-%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Young">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="元朗食品">
      <meta itemprop="description" content="Talk is cheap, show me the code.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C++ Primer 关键问题集 | 元朗食品">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++ Primer 关键问题集
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-13 21:39:36" itemprop="dateCreated datePublished" datetime="2022-02-13T21:39:36+08:00">2022-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-08 20:08:32" itemprop="dateModified" datetime="2022-04-08T20:08:32+08:00">2022-04-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><strong>C++ Primer各章节关键问题总结</strong></p>
<span id="more"></span>
<h1 id="第6章-函数">第6章 函数</h1>
<h2 id="函数基础">函数基础</h2>
<ul>
<li>函数调用表达式的类型是什么？</li>
<li>函数的返回类型有什么要求？</li>
<li>函数的局部变量初始化是怎样的？</li>
<li>局部静态对象是什么？其初始化是怎样的？其生命周期如何？</li>
</ul>
<h2 id="函数传递">函数传递</h2>
<ul>
<li>函数的两种参数传递方式是什么？区别是什么？</li>
<li>如何选择函数参数传递的方式？</li>
<li>顶层const和底层const在形参中是怎样的？</li>
<li>形参应尽量使用常量引用，为什么？若在应该使用常量引用的地方，使用了普通引用，会造成什么影响？</li>
<li>数组如何作为形参？</li>
</ul>
<h2 id="返回类型和return语句">返回类型和return语句</h2>
<ul>
<li>返回局部对象的引用或指针会导致什么后果？</li>
<li>函数返回值是左值还是右值？</li>
<li>数组类型无法作为函数的返回类型，若返回值像包含数组的信息该怎么办？</li>
<li>如何定义返回数组指针的函数？有几种方式？</li>
</ul>
<h2 id="函数重载">函数重载</h2>
<ul>
<li><p>什么是函数重载？</p></li>
<li><p>如何区分两个函数声明是等价的，还是重载函数？</p></li>
<li><p>const_cast在重载函数中是怎样运用的？</p></li>
<li><p>调用重载函数时，会进行函数匹配，函数匹配的结果有多少种可能？</p></li>
</ul>
<h2 id="特殊用途语言特性">特殊用途语言特性</h2>
<ul>
<li><p>什么是默认实参？</p></li>
<li><p>如何对默认实参的函数进行声明？</p></li>
<li><p>什么是内联函数？</p></li>
<li><p>什么是constexpr函数？</p></li>
<li><p>assert是什么？它有何作用？</p></li>
<li><p>NDEBUG是什么？它有何作用？</p></li>
</ul>
<h2 id="函数匹配">函数匹配</h2>
<ul>
<li>什么是候选函数？</li>
<li>什么是可行函数？</li>
<li>什么是最佳匹配？</li>
<li>函数调用时，实参类型转换有多少种等级？</li>
<li>函数匹配在底层const形参中有何特别之处？</li>
</ul>
<h2 id="函数指针">函数指针</h2>
<ul>
<li>什么是函数类型？</li>
<li>什么是函数指针？</li>
<li>函数指针类型作为形参是怎样的？</li>
<li>返回函数指针类型的函数是怎样定义的？有多少种方式？</li>
</ul>
<h2 id="习题">习题</h2>
<ul>
<li><p>说明形参、局部变量、局部静态变量的区别</p></li>
<li><p>指出下列函数中可能存在的问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a[<span class="number">10</span>])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="第7章-类">第7章 类</h1>
<h2 id="定义抽象数据类型">定义抽象数据类型</h2>
<h3 id="成员函数">成员函数</h3>
<ul>
<li><p>什么是成员函数？其声明和定义有何特点？</p></li>
<li><p>什么是<code>this</code>，有何特点？</p></li>
<li><p>什么是const成员函数？</p></li>
<li><p>在类内定义的成员函数，和在类外定义的成员函数有何区别？</p></li>
<li><p>什么时候需要返回<code>this</code>对象？应该如何返回？</p></li>
</ul>
<h3 id="构造函数">构造函数</h3>
<ul>
<li>什么是构造函数？作用是什么？</li>
<li>构造函数有哪些特点？</li>
<li>什么是合成的默认构造函数，其初始化是怎样的？</li>
<li>为什么说不能依赖于合成的默认构造函数？</li>
<li>什么是<code>=default</code>？其使用有何需要注意的地方？</li>
<li>什么是构造函数初始值列表？使用有何需要注意的地方？</li>
</ul>
<h3 id="拷贝赋值析构">拷贝、赋值、析构</h3>
<ul>
<li>类需要控制拷贝、赋值、析构时发生的行为</li>
<li>若不主动定义拷贝、赋值、析构时的行为，会怎样？</li>
</ul>
<h2 id="访问控制与封装">访问控制与封装</h2>
<h3 id="封装">封装</h3>
<ul>
<li>什么是封装？封装有何优点？</li>
</ul>
<h3 id="访问说明符">访问说明符</h3>
<ul>
<li>C++有哪些访问说明符？有何作用？</li>
<li>class和struct都可以定义类，有何区别？</li>
</ul>
<h3 id="友元">友元</h3>
<ul>
<li>什么是友元？什么可以声明为友元？</li>
<li>友元声明与函数声明有何区别？</li>
</ul>
<h2 id="类和其他特性">类和其他特性</h2>
<h3 id="类成员">类成员</h3>
<ul>
<li>类型成员有何特殊之处？</li>
<li>如何把成员函数定义为内联函数？</li>
<li>什么是可变数据成员？有何特殊之处？</li>
<li>mutable关键字有什么作用？</li>
<li>提供类内初始值有哪两种方式？</li>
</ul>
<h3 id="返回this的成员函数">返回<code>*this</code>的成员函数</h3>
<ul>
<li>普通成员函数返回<code>*this</code>，与const成员函数返回<code>*this</code>有何区别</li>
<li>返回<code>*this</code>的成员函数一般会定义基于const的重载，为什么？</li>
</ul>
<h3 id="类类型">类类型</h3>
<ul>
<li>什么是类的声明？什么是不完全类型？</li>
<li>不完全类型可以在哪些场景使用？</li>
<li>类的成员类型有何限制？</li>
</ul>
<h3 id="友元-1">友元</h3>
<ul>
<li><p>如何把其他类声明为友元？作用是什么？</p></li>
<li><p>如何把其他类的成员函数声明为友元？此时这两个类的定义有何要求？</p></li>
<li><p>友元的声明与函数的声明有何区别？试分析以下代码有何问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="comment">/* 友元函数定义在类的内部*/</span> &#125;</span><br><span class="line">    <span class="built_in">X</span>() &#123; <span class="built_in">f</span>(); &#125;	<span class="comment">// 非法, 友元函数并未声明</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">X::g</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">f</span>(); &#125;	<span class="comment">// 非法, 友元函数并未声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;			<span class="comment">// 这是函数f第一次被声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">X::h</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">f</span>(); &#125;	<span class="comment">// 合法, 该友元函数已经被声明</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="类的作用域">类的作用域</h2>
<ul>
<li>什么是类的作用域？</li>
<li>在类外部定义的成员函数有何需要注意的地方？</li>
<li>编译器在处理类的定义时会分为两步，具体是怎样的？</li>
<li>相对于普通成员，类型名有何特殊之处？</li>
<li>成员函数中的名字查找是怎样进行的？</li>
</ul>
<h2 id="构造函数再谈">构造函数再谈</h2>
<h3 id="构造函数初始值列表">构造函数初始值列表</h3>
<ul>
<li>构造函数的初始化与赋值效果有何区别？什么时候只能使用初始化？</li>
<li>构造函数初始化成员的顺序是怎样的？</li>
<li>构造函数可以提供默认实参，若为所有成员都提供了默认实参会发生什么？</li>
</ul>
<h3 id="委托构造函数">委托构造函数</h3>
<ul>
<li>什么是委托构造函数？</li>
</ul>
<h3 id="默认构造函数的作用">默认构造函数的作用</h3>
<ul>
<li>当对象被默认初始化，或值初始化时将会自动执行默认构造函数
<ul>
<li>对象什么时候会被默认初始化</li>
<li>对象什么时候会被值初始化</li>
</ul></li>
</ul>
<h3 id="隐式的类类型转换">隐式的类类型转换</h3>
<ul>
<li><p>什么是转换构造函数？</p></li>
<li><p>什么时候会发生隐式类类型转换？此时编译器做了什么？</p></li>
<li><p>隐式类类型转换有何特点？</p></li>
<li><p>如何抑制构造函数定义的隐式转换？</p></li>
<li><p>什么是explicit关键字？explicit构造函数有何特点？</p></li>
<li><p>可以让explicit构造函数显示转换吗？是怎样进行的？</p></li>
<li><p>标准库中含有显式构造函数的类是什么？试举两个例子</p></li>
<li><p>string对象和vector对象都有一个接受单个参数的构造函数，它们有何区别？为何这么设计？</p></li>
</ul>
<h3 id="聚合类">聚合类</h3>
<ul>
<li>什么是聚合类？</li>
<li>如何初始化聚合类的成员</li>
</ul>
<h2 id="类的静态成员">类的静态成员</h2>
<ul>
<li>什么是类的静态成员？有何特点？</li>
<li>如何声明静态成员？</li>
<li>类的静态成员是每个对象都有的吗？</li>
<li>类的静态成员函数与普通的成员函数有何区别？</li>
<li>如何使用静态成员？访问静态成员的方式有哪几种？</li>
<li>类的静态成员声明，与定义应该如何进行？</li>
<li>类的静态成员声明时，可以提供类内初始值吗？有何要求？</li>
<li>类的静态成员和普通成员有何区别？</li>
</ul>
<h1 id="第8章-io库">第8章 IO库</h1>
<h2 id="io类">IO类</h2>
<ul>
<li><p>IO类型可以分为哪三类？它们分别在什么时候使用？</p></li>
<li><p>IO类型之间的关系是怎样的？</p></li>
<li><p>可以给IO类型拷贝或赋值吗？IO类型如何传参？</p></li>
</ul>
<h3 id="条件状态">条件状态</h3>
<ul>
<li>IO类型有哪几个标志位？分别是什么含义？</li>
<li>如何判断IO类型是否处于有效状态？</li>
<li>采用IO类型的哪两个方法可以查询流的状态？</li>
<li>如何管理条件状态？</li>
<li>如何获取IO类型的完整条件状态？</li>
<li>什么是<code>strm::iostate</code>类型？</li>
</ul>
<h3 id="管理输出缓冲">管理输出缓冲</h3>
<ul>
<li>为什么输出流有缓冲区？每个输出流都有缓冲区吗？</li>
<li>缓冲刷新是什么意思？什么时候发生缓冲刷新？</li>
<li>哪些操纵符可以显式地刷新输出流缓冲区？它们有何区别？</li>
<li>程序崩溃时，输出流缓冲区会刷新吗？这会造成什么影响?</li>
</ul>
<h3 id="关联输入流和输出流">关联输入流和输出流</h3>
<ul>
<li>举例说明C++中关联输入流和输出流？</li>
<li>为什么要关联输入流和输出流？</li>
<li>如何关联输入流和输出流？</li>
<li>一个输出流可以被多个流关联吗？一个流可以关联到多个输出流吗？</li>
</ul>
<h2 id="文件输入输出">文件输入输出</h2>
<ul>
<li>文件IO类型有哪些？</li>
</ul>
<h3 id="使用文件流对象">使用文件流对象</h3>
<ul>
<li>相比于普通的IO类型，文件流对象有何特殊操作？</li>
<li>文件流对象是如何打开文件的？</li>
<li>文件流对象如何关闭文件？</li>
<li>什么时候打开文件会失败？有什么需要注意的地方？</li>
<li>什么是<code>is_open</code>方法，它的返回值是什么？</li>
<li>文件流对象的自动构造和析构是怎样的？</li>
</ul>
<h3 id="文件模式">文件模式</h3>
<ul>
<li>每个文件流对象都有关联的文件模式吗？</li>
<li>文件模式都有哪些？分别是什么含义？</li>
<li>如何指定文件流对象的文件模式？</li>
<li>文件模式是任意指定的吗？有何限制？</li>
<li>文件流类型的默认文件模式是怎样的？</li>
<li>使用<code>ofstream</code>打开文件有什么要注意的地方？</li>
<li>如何同时指定多个文件模式？</li>
</ul>
<h2 id="string类">string类</h2>
<ul>
<li>暂略</li>
</ul>
<h1 id="第9章-顺序容器">第9章 顺序容器</h1>
<h2 id="顺序容器概述">顺序容器概述</h2>
<ul>
<li>有哪些类型的顺序容器？分别有何特点？</li>
<li><code>list</code>和<code>forward_list</code>有何区别？为什么C++11需要新增<code>forward_list</code>？</li>
<li><code>array</code>类型有何特点？</li>
<li>每个容器都有<code>size()</code>成员吗？它的时间复杂度如何？</li>
</ul>
<h3 id="顺序容器类型选择">顺序容器类型选择</h3>
<ul>
<li>如何选择顺序容器类型？</li>
</ul>
<h2 id="容器库概览">容器库概览</h2>
<ul>
<li>容器类型操作的层次是怎样的？</li>
<li>容器定义在哪些头文件中？使用前如何引入?</li>
<li>容器类型有何特别之处？</li>
<li>容器可以保存的元素类型有何限制？</li>
</ul>
<h3 id="迭代器">迭代器</h3>
<ul>
<li>哪些容器类型支持迭代器的算术运算？</li>
<li><code>forward_list</code>的迭代器有何特点？</li>
<li>什么是迭代器范围？</li>
<li>什么是迭代器对？有何要求？</li>
<li>什么时候迭代器范围为空？</li>
</ul>
<h3 id="容器类型成员">容器类型成员</h3>
<ul>
<li>容器的类型成员都有哪些？</li>
<li>什么是反向迭代器？</li>
</ul>
<h3 id="begin和end成员">begin和end成员</h3>
<ul>
<li><code>begin</code>和<code>end</code>成员返回什么？</li>
<li><code>cbegin</code>和<code>cend</code>返回什么？</li>
<li><code>rbegin</code>和<code>rend</code>返回什么？</li>
<li><code>begin</code>成员和<code>end</code>成员的重载是怎样的？</li>
<li>使用迭代器时，我们应该如何选择这几个成员？</li>
</ul>
<h3 id="容器定义和初始化">容器定义和初始化</h3>
<ul>
<li>将一个容器初始化为另一个容器的拷贝有两种形式，分别是什么？这两种形式有何区别？</li>
<li>与容器大小相关的构造函数是怎样的？其初始化有何特点？</li>
<li>标准库<code>array</code>类型有何特点？其初始化是怎样的？</li>
<li><code>array</code>类型可以拷贝吗？内置数组可以拷贝吗?</li>
</ul>
<h3 id="赋值和swap">赋值和swap</h3>
<ul>
<li>赋值运算符的作用是什么？</li>
<li>如果两个容器原来大小不同，赋值后怎样？</li>
<li><code>array</code>类型的赋值有何特别之处？</li>
<li>赋值运算后，左侧运算对象的迭代器、指针、引用还有效吗？</li>
</ul>
<h4 id="使用assign">使用assign</h4>
<ul>
<li>如何使用<code>assign</code>成员？有几种形式?</li>
<li>传入<code>assign</code>的迭代器有何要求？</li>
<li>所有顺序容器都有<code>assign</code>成员吗？</li>
<li><code>assign</code>后，左侧运算对象的迭代器、指针、引用还有效吗？</li>
</ul>
<h4 id="使用swap">使用swap</h4>
<ul>
<li>如何使用<code>swap</code>成员？它对两个运算对象的类型有何要求？</li>
<li><code>swap</code>操作的时间复杂度如何？它的实现方式是怎样的？</li>
<li><code>swap</code>后，两个运算对象的迭代器、指针、引用还有效吗?</li>
<li><code>swap</code>两个<code>array</code>有何特别之处？其时间复杂度如何？迭代器、指针、引用如何？</li>
<li>C++11提供了非成员版本和成员版本的swap，应该如何选择？</li>
</ul>
<h3 id="容器大小操作">容器大小操作</h3>
<ul>
<li>有三个成员函数与容器大小有关，分别是什么？</li>
<li><code>forward_list</code>的容器大小成员函数都有哪些？</li>
</ul>
<h3 id="关系运算符">关系运算符</h3>
<ul>
<li>每个容器类型都支持的关系运算符是什么，它们是怎么工作的？</li>
<li>哪些容器支持运算符<code>&gt;</code>，<code>&gt;=</code>，<code>&lt;</code>，<code>&lt;=</code>？</li>
<li>关系运算符对两侧的运算对象有何要求？</li>
<li>容器的关系运算符是怎样执行运算的？对容器的元素类型有何要求？</li>
</ul>
<h2 id="顺序容器操作">顺序容器操作</h2>
<h3 id="添加元素">添加元素</h3>
<ul>
<li><code>push_back</code>和<code>push_front</code>是如何执行的？</li>
<li>哪些容器类型支持<code>insert</code>操作？有多少种版本？返回值是什么？</li>
<li><code>emplace</code>操作是怎样的？</li>
</ul>
<h3 id="访问元素">访问元素</h3>
<ul>
<li><code>back</code>和<code>front</code>成员返回值是什么？容器为空时会发生什么？</li>
<li>下标访问与<code>at</code>成员函数有何区别？</li>
<li>这些访问元素的函数返回值是什么？</li>
</ul>
<h3 id="删除元素">删除元素</h3>
<ul>
<li><p><code>pop_back</code>和<code>pop_front</code>是如何执行的？</p></li>
<li><p><code>erase</code>有多少种版本？返回值是什么？</p></li>
<li><p><code>clear</code>的作用是什么？</p></li>
<li><p>请总结以上各种操作的返回值？</p></li>
</ul>
<h3 id="特殊的forward_list操作">特殊的forward_list操作</h3>
<ul>
<li>forward_list有哪些操作？</li>
<li><code>before_begin()</code>成员返回什么？</li>
</ul>
<h3 id="改变容器大小">改变容器大小</h3>
<ul>
<li>什么成员函数可以改变大小？</li>
<li>如果大小扩大了会怎样?</li>
<li>如果大小缩小了会怎样？</li>
</ul>
<h3 id="容器操作可能使迭代器失效">容器操作可能使迭代器失效</h3>
<ul>
<li>容器添加元素操作对迭代器、引用、指针的影响是怎样的？</li>
<li>容器删除元素操作对迭代器、引用、指针的影响是怎样的？</li>
<li>在循环中添加/删除元素，有何需要注意的地方？</li>
<li>为什么不能在for范围循环中增加/删除元素？</li>
</ul>
<h2 id="vector对象的增长">vector对象的增长</h2>
<ul>
<li><p>C++规定vector和string是连续存储的，vector是如何实现高效增长的？</p></li>
<li><p>管理容量的成员函数有哪几个？</p></li>
<li><p><code>capacity()</code>和<code>size()</code>的概念有何区别？</p></li>
<li><p><code>reverse()</code>执行的结果可能是怎样的？</p></li>
<li><p><code>shrink_to_fit()</code>成员有何作用？结果可能是怎样的？</p></li>
<li><p>vector会在还有容量的情况下，重新分配内存空间吗？</p></li>
</ul>
<h2 id="额外的string操作">额外的string操作</h2>
<ul>
<li>从数组或string构造string的方法是怎样的？</li>
<li><code>substr</code>操作是怎样的？</li>
</ul>
<h3 id="搜索操作">搜索操作</h3>
<ul>
<li><code>string</code>有哪几个搜索操作？其返回值有何特点？</li>
</ul>
<h3 id="数值转换">数值转换</h3>
<ul>
<li><p>如何将算术类型转换为string？</p></li>
<li><p>如何将string转化为算术类型？</p></li>
</ul>
<h2 id="容器适配器">容器适配器</h2>
<ul>
<li>什么是适配器？</li>
<li>顺序容器适配器有哪些？</li>
<li>如何定义一个适配器？</li>
<li>栈适配器有哪些特殊操作？</li>
<li>队列适配器 有哪些特殊操作？</li>
</ul>
<h1 id="第十章-泛型算法">第十章 泛型算法</h1>
<h2 id="概述">10.1 概述</h2>
<ul>
<li>泛型算法的概念是什么？<strong>泛型</strong>是什么含义？</li>
<li>通过<strong>迭代器</strong>表示输入范围有何优点？</li>
<li>算法<code>find</code>是如何使用的？</li>
<li>泛型算法有何特点？它依赖于容器类型吗？依赖于元素类型吗？</li>
</ul>
<h2 id="泛型算法的分类">10.2 泛型算法的分类</h2>
<ul>
<li><p>泛型算法可分为哪几类？</p>
<p><strong>只读算法、写容器元素的算法、重排容器元素的算法</strong></p></li>
<li><p>什么是算法的<strong>输入范围</strong>？</p></li>
</ul>
<h3 id="只读算法">只读算法</h3>
<ul>
<li>什么是只读算法？</li>
<li><code>accumulate</code>算法的参数是什么？作用是什么？定义在哪个头文件？</li>
<li><code>equal</code>算法的参数是什么？作用是什么？有何特殊之处？</li>
</ul>
<h3 id="写容器元素的算法">写容器元素的算法</h3>
<ul>
<li><p><code>fill</code>算法的参数是什么？作用是什么？</p></li>
<li><p><code>fill_n</code>算法的参数是什么？作用是什么？有何需要注意的地方？</p></li>
<li><p>算法<strong>不执行写检查</strong>是什么意思？</p></li>
<li><p><strong>插入迭代器</strong>是什么？<code>back_inserter</code>是怎样使用的？</p></li>
<li><p><code>copy</code>算法的参数是什么？作用是什么？返回值是什么？</p></li>
<li><p>算法的拷贝版本是什么？</p></li>
<li><p><code>replace</code>算法的参数是什么？作用是什么？</p></li>
<li><p><code>replace_copy</code>算法的参数是什么？作用是什么？</p></li>
</ul>
<h3 id="重排容器元素的算法">重排容器元素的算法</h3>
<ul>
<li><code>sort</code>算法的参数是什么？作用是什么？</li>
<li><code>unique</code>算法的参数是什么？作用是什么？返回值是什么？</li>
<li><code>unique</code>算法的返回值有何特殊之处？这与泛型算法的什么特点有关？</li>
</ul>
<h2 id="定制操作">10.3 定制操作</h2>
<h3 id="向算法传递函数">10.3.1 向算法传递函数</h3>
<ul>
<li><p>什么是<strong>谓词</strong>？</p></li>
<li><p>什么是<strong>一元谓词</strong>？什么是<strong>二元谓词</strong>？</p></li>
<li><p>接受谓词参数的算法如何使用谓词？</p></li>
<li><p><code>sort</code>的重载版本接受几个参数？作用是什么？</p></li>
<li><p><code>stable_sort</code>算法的作用是什么？</p></li>
<li><p><code>partition</code>算法的参数是什么？作用是什么？返回值是什么？</p></li>
</ul>
<h3 id="lambda表达式">10.3.2 lambda表达式</h3>
<ul>
<li><p>谓词有什么限制？</p></li>
<li><p>什么是可调用对象？C++有哪几种<strong>可调用对象</strong>？</p></li>
<li><p>lambda表达式是什么？其形式是怎样的？其中的哪几部分是可以忽略的？</p></li>
<li><p>如何<strong>定义</strong>lambda表达式？</p></li>
<li><p>如何<strong>调用</strong>lambda表达式？</p></li>
<li><p>捕获列表的作用是什么？如何捕获多个变量？被捕获的变量有哪些要求？</p></li>
<li><p><code>find_if</code>算法的参数是什么？作用是什么？其第三个参数有何特点？</p></li>
<li><p><code>for_each</code>算法的参数是什么？作用是什么？</p></li>
</ul>
<h3 id="lambda捕获和返回">10.3.3 lambda捕获和返回</h3>
<ul>
<li>lambda表达式的类型是什么？</li>
<li>什么时候会创建这种类型的对象？</li>
<li>lambda表达式的变量捕获有哪两种方式？有何特点？</li>
<li>lambda表达式的引用捕获有何特点？对被捕获的变量有何要求？</li>
<li>什么是lambda表达式的隐式捕获，如何使用隐式捕获？</li>
<li>什么是lambda表达式的混合捕获，如何使用？</li>
<li>什么是可变lambda？</li>
<li>lambda表达式的返回类型是什么？如何指定返回类型？</li>
<li>能否将lambda作为函数的返回类型？若可以，有何要求？</li>
</ul>
<h3 id="参数绑定">10.3.4 参数绑定</h3>
<ul>
<li><p>标准库<code>bind</code>函数是什么？其参数是什么？返回值是什么？作用是什么？</p></li>
<li><p><code>bind</code>函数的第二个参数是什么意思？其中的占位符是什么意思？</p></li>
<li><p>上述占位符定义在哪个命名空间中？如何使用？</p></li>
<li><p><code>bind</code>调用其可调用对象时，是如何传参的？如果想要通过引用传递，该如何操作？</p></li>
<li><p><code>bind</code>有何应用？</p></li>
</ul>
<h2 id="再探迭代器">10.4 再探迭代器</h2>
<ul>
<li>除了容器定义的迭代器外，标准库在<code>iterator</code>头文件中定义了哪几种特殊迭代器？</li>
</ul>
<h3 id="插入迭代器">插入迭代器</h3>
<ul>
<li>什么是插入迭代器？有哪几种类型？有何区别？</li>
<li>通过插入迭代器赋值时，将发生什么？</li>
</ul>
<h3 id="流迭代器">流迭代器</h3>
<ul>
<li>什么是<code>iostream</code>迭代器？有哪几种类型？</li>
<li><code>istream_iterator</code>的两种构造方式有何区别？</li>
<li>如何使用<code>istream_iterator</code>？</li>
<li><code>istream_iterator</code>的懒惰求值是什么？</li>
<li><code>ostream_iterator</code>的两种构造方式有何区别？<code>ostream_iterator</code>是否必须绑定到一个输出流？</li>
</ul>
<h3 id="反向迭代器">反向迭代器</h3>
<ul>
<li>什么是反向迭代器？哪些容器没有反向迭代器？</li>
<li>如何将反向迭代器转换为迭代器？转换前后的迭代器指向同一个元素吗？为何这样设计？</li>
</ul>
<h2 id="泛型算法结构">10.5 泛型算法结构</h2>
<ul>
<li>算法的最基本特性是什么？</li>
<li>五类迭代器是什么？分别有什么特点？</li>
<li>常见容器定义的迭代器分别属于哪类迭代器？</li>
<li>算法的形参模式是什么？接受第二个输入序列的算法可以通过哪两种方式接受？</li>
<li>算法的命名规范有哪些？</li>
</ul>
<h2 id="特定容器算法list和forward_list">10.6
特定容器算法（<code>list</code>和<code>forward_list</code>）</h2>
<p>暂略</p>
<h2 id="泛型算法总结">10.7 泛型算法总结</h2>
<ul>
<li><code>find</code></li>
<li><code>accumulate</code></li>
<li><code>equal</code></li>
<li><code>fill</code></li>
<li><code>fill_n</code></li>
<li><code>copy</code></li>
<li><code>copy_if</code></li>
<li><code>find_if</code></li>
<li><code>replace</code></li>
<li><code>replace_copy</code></li>
<li><code>sort</code></li>
<li><code>unique</code></li>
<li><code>stable_sort</code></li>
<li><code>partition</code></li>
<li><code>for_each</code></li>
</ul>
<h1 id="第11章-关联容器">第11章 关联容器</h1>
<ul>
<li>C++标准库定义了8个关联容器，分别是什么？</li>
</ul>
<h2 id="关联容器概述">11.2 关联容器概述</h2>
<ul>
<li>关联容器的构造函数有哪几种？</li>
<li>有序容器对关键字类型有什么要求？</li>
<li>如何自定义比较操作？</li>
</ul>
<h3 id="pair类型"><code>pair</code>类型</h3>
<ul>
<li>什么是<code>pair</code>类型？定义在哪个头文件？</li>
<li><code>pair</code>的数据成员有哪些？</li>
<li><code>pair</code>的初始化方式有哪些？</li>
<li><code>make_pair</code>函数如何使用？</li>
<li>从一个函数返回一个<code>pair</code>有哪两种方式？</li>
</ul>
<h2 id="关联容器操作">11.3 关联容器操作</h2>
<ul>
<li>关联容器的类型别名有哪些？对于<code>set</code>和<code>map</code>它们分别是什么？</li>
<li>通常不对关联容器使用泛型算法，为什么？</li>
</ul>
<h3 id="添加元素-1">添加元素</h3>
<ul>
<li>如何使用<code>insert</code>向关联容器添加元素？</li>
<li><code>insert(v)</code>的返回值是什么？<code>set</code>和<code>multiset</code>有何区别？</li>
<li>如何使用<code>emplace</code>向关联容器添加元素？</li>
</ul>
<h3 id="删除元素-1">删除元素</h3>
<ul>
<li><code>erase</code>的三个版本分别是什么？</li>
<li><code>erase(k)</code>作用是什么？返回值是什么?</li>
<li>删除元素时有何需要注意的地方?</li>
</ul>
<h3 id="map的下标操作">map的下标操作</h3>
<ul>
<li>哪些容器支持下标操作？</li>
<li>下标运算符和<code>at</code>成员函数都能执行下标操作，有何区别？</li>
<li>下标操作的返回值是什么？请与解引用map迭代器进行对比？</li>
</ul>
<h3 id="访问元素-1">访问元素</h3>
<ul>
<li><code>find</code>如何使用？</li>
<li><code>count</code>如何使用</li>
<li><code>lower_bound</code>如何使用？</li>
<li><code>upper_bound</code>如何使用？</li>
<li><code>equal_range</code>如何使用？</li>
</ul>
<h2 id="无序容器">11.4 无序容器</h2>
<ul>
<li>无序容器对关键字类型的要求是怎样的？</li>
<li>如何使用自定义类型的无序容器？</li>
<li>如何提供自定义的哈希计算函数，和相等性判断运算符？</li>
<li>无序容器是如何存储元素的？具有相同哈希值的所有元素会被存储在一起吗？</li>
<li>无序容器相对于有序容器，有何优点？有何缺点？</li>
</ul>
<h1 id="第12章-动态内存">第12章 动态内存</h1>
<ul>
<li><strong>全局对象、局部自动对象、局部static对象</strong>的生存期分别是怎样的</li>
<li><strong>静态内存、栈内存、堆内存</strong>分别保存哪种对象？</li>
</ul>
<h2 id="动态内存与智能指针">12.1 动态内存与智能指针</h2>
<ul>
<li>C++通过哪对运算符对动态内存进行管理？</li>
<li>C++为什么要用智能指针管理动态对象？动态内存的使用容易造成哪些问题？</li>
</ul>
<h3 id="shared_ptr类"><code>shared_ptr</code>类</h3>
<ul>
<li>智能指针定义在哪个头文件中？</li>
<li><code>shared_ptr</code>类的默认初始化是怎样的？</li>
<li>若<code>p</code>是智能指针，<code>p.get()</code>返回什么？</li>
<li><code>make_shared</code>函数有何作用？</li>
<li>使用<code>make_shared</code>分配动态对象时，若不传递任何参数，对象将如何初始化？</li>
</ul>
<h4 id="shared_ptr的拷贝和赋值"><code>shared_ptr</code>的拷贝和赋值</h4>
<ul>
<li><code>shared_ptr</code>的<strong>引用计数</strong>是什么？</li>
<li>什么时候<code>shared_ptr</code>的引用计数会<strong>递增</strong>？</li>
<li>什么时候<code>shared_ptr</code>的引用计数会<strong>递减</strong>？</li>
<li>拷贝<code>shared_ptr</code>的操作有哪些？</li>
</ul>
<h4 id="shared_ptr自动销毁所管理的对象"><code>shared_ptr</code>自动销毁所管理的对象</h4>
<ul>
<li>智能指针指向的对象在什么时候被释放?</li>
<li><code>shared_ptr</code>类的<strong>析构函数</strong>会进行什么操作？</li>
</ul>
<h4 id="使用动态生存期资源的类">使用动态生存期资源的类</h4>
<ul>
<li>程序<strong>使用动态内存的原因</strong>一般是哪三种？</li>
<li>程序需要<strong>在多个对象间共享数据</strong>时，一般使用动态内存，这种类对象销毁时能直接销毁该共享数据吗？应该如何管理？</li>
</ul>
<h3 id="使用new和delete直接管理内存">使用<code>new</code>和<code>delete</code>直接管理内存</h3>
<h4 id="new"><code>new</code></h4>
<ul>
<li>运算符<code>new</code>和<code>delete</code>的作用分别是什么？</li>
<li>使用<code>new</code>动态分配对象，有几种<strong>初始化</strong>方法？</li>
<li>可以使用<code>new</code>动态分配<code>const</code>对象吗，初始化有什么要求？</li>
<li>若<strong>内存耗尽</strong>，<code>new</code>表达式会如何？</li>
<li>什么是<code>placement new</code>？什么是<code>nothrow</code>？</li>
</ul>
<h4 id="delete"><code>delete</code></h4>
<ul>
<li><code>delete</code>的作用是什么？<code>delete</code>在什么情况下的行为是<strong>未定义</strong>的？</li>
</ul>
<h4 id="动态内存管理的常见错误">动态内存管理的常见错误</h4>
<ul>
<li>动态内存管理的常见错误有哪几种？</li>
<li>什么是<strong>空悬指针</strong>？</li>
<li>为什么要在<code>delete</code>后<strong>重置指针值</strong>？为什么这样做仍然无法防止出错？</li>
</ul>
<h3 id="shared_ptr和new结合使用"><code>shared_ptr</code>和<code>new</code>结合使用</h3>
<h4 id="shared_ptr的初始化"><code>shared_ptr</code>的初始化</h4>
<ul>
<li><code>shared_ptr</code>的构造函数是<code>explict</code>的，这给它的使用带来了哪些限制？</li>
<li>如何用<code>new</code>返回的指针初始化<code>shared_ptr</code>智能指针？</li>
<li>假如初始化智能指针的内置指针并非指向动态内存，会发生什么？</li>
</ul>
<h4 id="不要混合使用普通指针和智能指针">不要混合使用普通指针和智能指针</h4>
<ul>
<li>为什么？</li>
</ul>
<h4 id="不要用get初始化另一个智能指针或为智能指针赋值">不要用<code>get</code>初始化另一个智能指针，或为智能指针赋值</h4>
<ul>
<li><code>get()</code>返回值是什么？</li>
<li><code>get()</code>设计的目的是什么？</li>
<li>使用<code>get()</code>返回的指针的代码有何要求？</li>
<li>不要用<code>get</code>初始化另一个智能指针或为另一个智能指针赋值，为什么？</li>
</ul>
<h4 id="reset成员函数"><code>reset</code>成员函数</h4>
<ul>
<li><code>reset</code>成员函数有多少个版本？其作用是什么？</li>
</ul>
<h4 id="unique和use_count成员函数"><code>unique</code>和<code>use_count</code>成员函数</h4>
<ul>
<li><code>use_count()</code>的返回值是什么?</li>
<li><code>unique()</code>的返回值是什么？</li>
</ul>
<h3 id="智能指针和异常">智能指针和异常</h3>
<ul>
<li>使用异常处理的程序，若采用<code>new</code>和<code>delete</code>直接管理动态内存，有何问题？</li>
<li>在异常处理程序中采用智能指针有什么好处？</li>
</ul>
<h4 id="使用自定义的释放操作">使用自定义的释放操作</h4>
<ul>
<li>默认情况下，<code>shared_ptr</code>释放其所指对象时将执行什么操作？</li>
<li>如何使用自定义的释放操作？</li>
<li>什么是删除器？</li>
</ul>
<h4 id="智能指针使用的标准规范">智能指针使用的标准规范</h4>
<ul>
<li>请说出四点<code>shared_ptr</code>使用的标准规范？</li>
</ul>
<h3 id="unique_ptr类"><code>unique_ptr</code>类</h3>
<h4 id="unique_ptr的定义和初始化"><code>unique_ptr</code>的定义和初始化</h4>
<ul>
<li><code>unique_ptr</code>的类型与<code>shared_ptr</code>的类型有何区别？</li>
<li>为什么说<code>unique_ptr</code>拥有其所指向的对象？</li>
<li>如何初始化<code>unique_ptr</code>？</li>
<li>可以拷贝或赋值一个<code>unique_ptr</code>吗?</li>
</ul>
<h4 id="release和reset转移指针所有权"><code>release</code>和<code>reset</code>转移指针所有权</h4>
<ul>
<li><code>release()</code>的作用是什么？返回值是什么？为什么<code>shared_ptr</code>没有<code>release()</code>成员</li>
<li><code>reset</code>有多少种版本？作用是什么？</li>
<li>若<code>p</code>是一个<code>unique_ptr</code>，<code>p=nullptr</code>的作用是什么？</li>
</ul>
<h4 id="返回unique_ptr">返回<code>unique_ptr</code></h4>
<ul>
<li>不能拷贝和赋值<code>unique_ptr</code>有一种例外，是什么？</li>
</ul>
<h4 id="向unique_ptr传递删除器">向<code>unique_ptr</code>传递删除器</h4>
<ul>
<li>向<code>unique_ptr</code>传递删除器会改变什么？</li>
</ul>
<h3 id="weak_ptr类"><code>weak_ptr</code>类</h3>
<ul>
<li><code>weak_ptr</code>指向的对象是什么？</li>
<li><code>weak_ptr</code>有何特点？</li>
<li>如何初始化一个<code>weak_ptr</code>？</li>
<li>如何访问<code>weak_ptr</code>指向的对象？为什么要采取这种访问方式？</li>
<li><code>weak_ptr</code>的<code>use_count</code>成员、<code>expired</code>成员、<code>lock</code>成员分别有何作用？</li>
</ul>
<h2 id="动态数组">12.2 动态数组</h2>
<h3 id="new和数组"><code>new</code>和数组</h3>
<ul>
<li>如何使用<code>new</code>分配动态数组？</li>
<li><code>new</code>分配动态数组需要指明要分配的对象的数目，该数目必须是常量吗?</li>
<li>使用<code>new</code>分配数组返回值是什么？这意味着什么限制？</li>
<li>如何初始化动态分配对象的数组？有哪几种方式？</li>
<li>如果动态分配数组中，对象的数目为0会发生什么?</li>
<li>如何释放动态数组？</li>
<li>如果<code>delete[]</code>一个指向单一对象的指针，或<code>delete</code>一个指向动态数组的指针，会发生什么？</li>
<li>如何使用<code>unique_ptr</code>管理动态数组？</li>
<li>如何使用<code>shared_ptr</code>管理动态数组？</li>
</ul>
<h3 id="allocator类"><code>allocator</code>类</h3>
<ul>
<li><code>allocator</code>相对于<code>new</code>有何优点？</li>
<li><code>allocator</code>分配的内存有何特点？</li>
<li><code>allocator</code><strong>分配内存</strong>的成员是什么？如何使用？</li>
<li><code>allocator</code><strong>构造对象</strong>的成员是什么？如何使用？</li>
<li><code>allocator</code><strong>销毁对象</strong>的成员是什么?
如何使用？</li>
<li><code>allocator</code><strong>释放内存</strong>的成员是什么？如何使用？</li>
<li><code>allocator</code>的两个<strong>伴随算法</strong>，可以在未初始化内存中创建对象，它们是怎么使用的？</li>
</ul>
<h1 id="第13章-拷贝控制">第13章 拷贝控制</h1>
<h2 id="拷贝赋值与销毁">13.1 拷贝、赋值与销毁</h2>
<h3 id="拷贝构造函数">拷贝构造函数</h3>
<ul>
<li>什么是拷贝构造函数？</li>
<li>拷贝构造函数的第一个参数有何特点？</li>
<li>拷贝构造函数是<code>explict</code>的吗？</li>
</ul>
<h4 id="合成拷贝构造函数">合成拷贝构造函数</h4>
<ul>
<li>如果没有类没有定义拷贝构造函数，编译器会如何处理？</li>
<li>合成拷贝构造函数会进行什么操作？拷贝数据成员时有何特点？</li>
</ul>
<h4 id="拷贝初始化">拷贝初始化</h4>
<ul>
<li>直接初始化与拷贝初始化的区别是什么？</li>
<li>什么时候进行拷贝初始化？</li>
</ul>
<h4 id="参数和返回值">参数和返回值</h4>
<ul>
<li><p>为什么拷贝构造函数必须接受引用类型</p></li>
<li><p>编译器可以绕过拷贝构造函数吗？此时编译器会如何操作？</p></li>
</ul>
<h3 id="拷贝赋值运算符">拷贝赋值运算符</h3>
<ul>
<li>什么是重载赋值运算符？</li>
<li>重载运算符本质是什么？名字有何特点？参数有何特点？</li>
<li>重载赋值运算符参数是什么？返回值是什么？</li>
</ul>
<h4 id="合成拷贝赋值运算符">合成拷贝赋值运算符</h4>
<ul>
<li>若类未定义自己的拷贝赋值运算符，编译器会做什么？</li>
<li>合成拷贝赋值运算符会做什么？对于不同类型的成员会做什么？</li>
</ul>
<h3 id="析构函数">析构函数</h3>
<ul>
<li><p>什么是析构函数？名字是什么？参数是什么？返回值是什么？</p></li>
<li><p>一个类可以有几个析构函数？</p></li>
<li><p>析构函数由哪两部分组成？</p></li>
<li><p>析构函数如何销毁数据成员？有何特点？</p></li>
<li><p>析构函数在处理内置指针成员，与智能指针成员时有何区别？</p></li>
<li><p>什么时候调用析构函数？</p></li>
<li><p>对象的引用或指针离开作用域时，会调用析构函数吗？</p></li>
</ul>
<h4 id="合成析构函数">合成析构函数</h4>
<ul>
<li>合成析构函数是什么？它会销毁数据成员吗？</li>
</ul>
<h3 id="三五法则">三/五法则</h3>
<ul>
<li>类的拷贝控制成员定义，有哪两个原则？</li>
</ul>
<h3 id="使用default">使用<code>=default</code></h3>
<ul>
<li>将拷贝控制成员定义为<code>=default</code>意味着什么?</li>
</ul>
<h3 id="阻止拷贝">阻止拷贝</h3>
<ul>
<li>什么时候需要阻止拷贝？已学过的哪些类阻止了拷贝？</li>
</ul>
<h4 id="定义删除的函数">定义删除的函数</h4>
<ul>
<li>什么是删除的函数？</li>
<li>如何定义删除的函数？</li>
</ul>
<h4 id="析构函数不能是删除的函数">析构函数不能是删除的函数</h4>
<ul>
<li>如果一个类删除了析构函数，会发生什么?</li>
<li>如果一个类的某个成员类型的析构函数删除了，会发生什么？</li>
<li>对于这种类，我们可以动态分配该类型的对象吗？如果可以，我们可以销毁该对象吗？</li>
</ul>
<h4 id="合成的拷贝控制成员可能是删除的">合成的拷贝控制成员可能是删除的</h4>
<ul>
<li>如果类的某个成员的析构函数是删除或不可访问的，类哪些的合成拷贝控制成员是删除的？为什么？</li>
<li>如果类的某个成员的合成拷贝构造函数是删除或不可访问的，类的哪些合成拷贝控制成员是删除的？为什么？</li>
<li>什么情况下类的合成拷贝赋值运算符是删除的？为什么?</li>
<li>什么情况下类的默认构造函数是删除的？为什么？</li>
</ul>
<h4 id="private拷贝控制"><code>private</code>拷贝控制</h4>
<ul>
<li>如何将拷贝控制成员声明为<code>private</code>以阻止拷贝？</li>
<li>试图拷贝对象的用户代码会发生什么错误？试图拷贝对象的友元或成员函数会发生什么错误？</li>
</ul>
<h2 id="拷贝控制和资源管理">13.2 拷贝控制和资源管理</h2>
<ul>
<li>什么是行为像值的类？</li>
<li>什么是行为像指针的类？</li>
<li>类如何定义某种共享资源的引用计数？</li>
</ul>
<h2 id="交换操作">13.3 交换操作</h2>
<ul>
<li>什么时候会调用<code>swap</code>？</li>
<li>定义了自己的<code>swap</code>，与没定义自己的<code>swap</code>的类，在进行排序时有何区别？</li>
<li>为什么管理资源的类最好自定义一个名为<code>swap</code>的函数？</li>
<li>类自定义的<code>swap</code>一般如何编写</li>
</ul>
<h3 id="在赋值运算符中使用swap">在赋值运算符中使用<code>swap</code></h3>
<ul>
<li>什么是<code>copy and swap</code>技术？</li>
<li><code>copy and swap</code>技术相对于普通的赋值运算符有何优点？</li>
</ul>
<h2 id="对象移动">13.6 对象移动</h2>
<ul>
<li>什么情况下移动而非拷贝对象能大幅提升性能？</li>
</ul>
<h3 id="右值引用">13.6.1 右值引用</h3>
<ul>
<li>什么是<strong>右值引用</strong>？它能指向什么对象？</li>
<li>右值引用有何重要<strong>性质</strong>？</li>
<li>左值引用可以绑定到返回左值的表达式，<strong>返回左值的表达式有哪些</strong>？</li>
<li>右值引用可以绑定到返回右值的表达式，<strong>返回右值的表达式有哪些</strong>？</li>
</ul>
<h4 id="左值持久右值短暂">左值持久、右值短暂</h4>
<ul>
<li><p>为什么右值引用可以<strong>自由地接管</strong>所引用的对象的<strong>资源</strong>？</p></li>
<li><p>变量是左值还是右值？</p></li>
</ul>
<h4 id="标准库move函数">标准库<code>move</code>函数</h4>
<ul>
<li>标准库<code>move</code>函数的作用是什么？</li>
<li>定义在哪个头文件？</li>
<li>对<code>std::move</code>的调用有何需要注意的地方？</li>
<li>移后源对象有何特点？</li>
<li>请总结左值引用和右值引用的区别？</li>
</ul>
<h3 id="移动构造函数和移动赋值运算符">13.6.2
移动构造函数和移动赋值运算符</h3>
<ul>
<li>移动构造函数的参数有何特点？</li>
<li>移动构造函数应该如何处理移后源对象？</li>
</ul>
<h4 id="移动操作标准库容器和异常">移动操作、标准库容器和异常</h4>
<ul>
<li>以<code>vector</code>为例，说明如果移动构造函数会抛出异常，标准库容器会做什么额外操作？</li>
<li>如何告诉标准库移动构造函数不会抛出异常？</li>
</ul>
<h4 id="移动赋值运算符">移动赋值运算符</h4>
<ul>
<li>移动赋值运算符进行什么操作？</li>
<li>移动赋值运算符如何保证自赋值的正确性？</li>
</ul>
<h4 id="移后源对象">移后源对象</h4>
<ul>
<li>移动构造函数和移动赋值运算符应该保证移后源对象的哪些要求？</li>
</ul>
<h4 id="合成的移动操作">合成的移动操作</h4>
<ul>
<li>什么时候编译器会合成移动构造函数或移动赋值运算符？</li>
<li>什么时候合成的移动操作会被定义为删除的？</li>
</ul>
<h4 id="移动左值拷贝右值">移动左值、拷贝右值</h4>
<ul>
<li>如果类既定义了拷贝构造函数，又定义了移动构造函数，在对该类型进行拷贝初始化时，将调用哪个函数？</li>
<li>如果类只定义了拷贝构造函数，没有定义移动构造函数，在对该类型进行拷贝初始化时，将发生什么？会引发错误吗？</li>
</ul>
<h4 id="三五法则-1">三/五法则</h4>
<ul>
<li>请阐述三/五法则</li>
</ul>
<h4 id="移动迭代器">移动迭代器</h4>
<ul>
<li>什么是<strong>移动迭代器</strong>？它与普通迭代器有何区别？</li>
<li>如何将<strong>普通迭代器转换为移动迭代器</strong>？</li>
<li>移动迭代器有何应用？可以以<code>StrVec</code>类的<code>reallocate</code>成员举例说明？</li>
</ul>
<h4 id="不要轻易使用移动操作">不要轻易使用移动操作</h4>
<ul>
<li>什么时候调用<code>move</code>？</li>
</ul>
<h3 id="右值引用和成员函数">13.6.3 右值引用和成员函数</h3>
<ul>
<li><p>对于普通的成员函数，如何定义其<strong>拷贝和移动</strong>版本？</p></li>
<li><p>在对象上调用成员函数时，该对象一定是左值吗？以下语句合法吗？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;Hello&quot;</span>, s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">cout &lt;&lt; (s1 + s2).<span class="built_in">size</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li>
<li><p>如何限制调用成员函数的<strong>对象必须为左值或必须为右值</strong>？</p></li>
<li><p>什么是<strong><code>const</code>限定符</strong>？什么是<strong>引用限定符</strong>？可以<strong>混合使用</strong>吗？</p></li>
<li><p>引用限定符可以区分重载版本吗？使用时有何需要注意的地方？</p></li>
</ul>
<h1 id="第14章-重载运算与类型转换">第14章 重载运算与类型转换</h1>
<h2 id="基本概念">14.1 基本概念</h2>
<ul>
<li><p>重载运算符本质是什么？</p></li>
<li><p>重载运算符的名字是怎样的？其参数是怎样的？</p></li>
<li><p>重载运算符一定是成员函数吗？重载运算符中的<code>this</code>指针指向什么？</p></li>
<li><p>为什么我们无法改变内置类型运算符的含义</p></li>
<li><p>可以发明新的运算符号吗？</p></li>
<li><p>C++有多少个符号既是一元运算符，又是二元运算符？重载这些运算符该如何区分？</p></li>
<li><p>重载运算符的优先级、结合律、求值顺序是怎样的？</p></li>
<li><p>我们可以直接调用重载的运算符函数吗？</p></li>
<li><p>什么运算符不能被重载？</p></li>
<li><p>什么运算符最好不要重载？</p></li>
<li><p>重载运算符的返回类型是怎样的？</p></li>
<li><p>重载运算符时，应该将定义为成员函数，还是非成员函数？</p></li>
</ul>
<h2 id="输入和输出关系运算符">14.2 输入和输出关系运算符</h2>
<ul>
<li>重载输出运算符<code>&lt;&lt;</code>的第一个参数是什么？第二个参数是什么？返回值是什么？</li>
<li>重载输入运算符<code>&gt;&gt;</code>的第一个参数是什么？第二个参数是什么？返回值是什么？</li>
<li>重载输入输出运算符是成员还是非成员？为什么？</li>
<li>重载输入运算符，相对于重载输出运算符，做了什么额外的操作？</li>
<li>执行输入运算符可能遇到什么错误？此时应该进行什么操作？</li>
<li>执行输入运算符若没有遇到IO错误，但读入的数据有问题，该如何标识错误？</li>
</ul>
<h2 id="算术和关系运算符">14.3 算术和关系运算符</h2>
<ul>
<li>算术和关系运算符是成员还是非成员？为什么？</li>
<li>算术和关系运算符的形参通常是什么类型的？</li>
</ul>
<h3 id="算术运算符">算术运算符</h3>
<ul>
<li>算术运算符进行什么操作？返回值是什么？</li>
<li>定义了算术运算符的类，通常也应该定义什么运算符？它们的实现上有何联系？</li>
</ul>
<h3 id="相等运算符">相等运算符</h3>
<ul>
<li>定义相等运算符时，通常如何对比两个对象是否相等？</li>
<li>相等运算符应该具有什么性质？</li>
<li>定义了<code>operator==</code>的类，通常也应该定义什么运算符？两者的实现上有何联系？</li>
</ul>
<h3 id="关系运算符-1">关系运算符</h3>
<ul>
<li>什么时候需要定义<code>operator&lt;</code>运算符？</li>
<li>如果类存在<code>==</code>运算符，则<code>&lt;</code>的定义有何要求？</li>
</ul>
<h2 id="赋值运算符">14.4 赋值运算符</h2>
<ul>
<li>我们已学过的赋值运算符有哪两种？</li>
<li>接受花括号列表作为参数的赋值运算符是怎样的？它需要考虑自赋值问题吗？</li>
<li>赋值运算符是成员还是非成员？</li>
<li>赋值运算符的返回值是什么？</li>
</ul>
<h3 id="复合赋值运算符">复合赋值运算符</h3>
<ul>
<li>复合赋值运算符是成员还是非成员？</li>
<li>复合赋值运算符返回值是什么？</li>
</ul>
<h2 id="下标运算符">14.5 下标运算符</h2>
<ul>
<li>什么类通常会定义下标运算符<code>operator[]</code></li>
<li>下标运算符是成员还是非成员？</li>
<li>下标运算符返回值是什么？</li>
<li>下标运算符通常会重载，为什么？</li>
</ul>
<h2 id="递增和递减运算符">14.6 递增和递减运算符</h2>
<ul>
<li>什么类通常定义递增和递减运算符？</li>
<li>递增和递减运算符是成员还是非成员？</li>
</ul>
<h3 id="前置版本">前置版本</h3>
<ul>
<li>如何定义递增递减运算符的前置版本？</li>
<li>其返回值是什么？</li>
</ul>
<h3 id="后置版本">后置版本</h3>
<ul>
<li>如何定义后置版本？它和前置版本是如何区分的？</li>
<li>编译器调用后置版本的递增和递减运算符时，会作什么处理？</li>
<li>其返回值是什么？</li>
<li>如果显式调用后置版本呢，即通过<code>opreator++</code>调用，应怎么做？</li>
</ul>
<h2 id="成员访问运算符">14.7 成员访问运算符</h2>
<ul>
<li>成员访问运算符包含哪两个运算符？</li>
<li>解引用运算符是成员还是非成员？返回值是什么？</li>
<li>箭头运算符是成员还是非成员？返回值是什么？</li>
<li>为什么箭头运算符、解引用运算符通常定义为<code>const</code>成员？</li>
</ul>
<h3 id="箭头运算符返回值的限定">箭头运算符返回值的限定</h3>
<ul>
<li>箭头运算符返回值是什么？</li>
<li>当使用<code>pointer-&gt;mem</code>表达式时，会发生什么？</li>
</ul>
<h2 id="函数调用运算符">14.8 函数调用运算符</h2>
<ul>
<li>请列举C++的可调用对象？</li>
<li>什么是函数对象？</li>
<li>函数调用运算符是成员还是非成员？</li>
<li>函数调用运算符可以重载吗？</li>
</ul>
<h3 id="lambda是函数对象">lambda是函数对象</h3>
<ul>
<li>为什么说lambda是函数对象？编译器如何处理lambda表达式？</li>
<li>没有捕获变量的lambda表达式等价于什么形式的类？其函数调用运算符是怎样的？</li>
</ul>
<h4 id="表示lambda及相应捕获行为的类">表示lambda及相应捕获行为的类</h4>
<ul>
<li>如果lambda通过值捕获变量，它对应的类的函数调用运算符可以直接使用这些变量吗？应该如何处理？</li>
<li>如果lambda通过引用捕获变量，它可以直接使用这些变量吗？</li>
</ul>
<h3 id="可调用对象与function">可调用对象与function</h3>
<ul>
<li><p>函数和函数指针类型是什么？</p></li>
<li><p><code>lambda</code>的类型是什么？</p></li>
<li><p>什么是调用形式？不同类型的可调用对象可以有相同的调用形式吗？</p></li>
<li><p>什么是函数表？它有什么作用？它的使用有何问题？</p></li>
</ul>
<h4 id="标准库function类型">标准库function类型</h4>
<ul>
<li>什么是标准库<code>function</code>类型？如何定义<code>function</code>类型？</li>
<li>如何通过<code>function</code>类型解决上述函数表的问题？</li>
<li>可以用重载函数的名字初始化<code>function</code>类型对象吗？如何解决该问题？</li>
</ul>
<h2 id="重载类型转换与运算符">14.9 重载、类型转换与运算符</h2>
<ul>
<li>什么是类类型转换？</li>
<li>什么是转换构造函数？什么是类型转换运算符？</li>
</ul>
<h3 id="类型转换运算符">类型转换运算符</h3>
<ul>
<li><p>类型转换运算符的作用是什么？</p></li>
<li><p>如何定义类型转换运算符？可以转换的目的类型有哪些？</p></li>
<li><p>类型转换运算符是成员还是非成员？返回类型是什么？参数是什么？是<code>const</code>成员吗？</p></li>
<li><p>以下代码是正确的吗？这体现了类型转换的什么特点？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">SmallInt</span>(<span class="keyword">int</span> i = <span class="number">0</span>): <span class="built_in">val</span>(i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; <span class="number">255</span>) </span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;Bad SmallInt val&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">size_t</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SmallInt si = <span class="number">3.14</span>;	<span class="comment">// 内置类型转换将double转换成int, 再调用转换构造函数</span></span><br><span class="line">si + <span class="number">3.14</span>;			<span class="comment">// SmallInt类型转换运算符将si转为int, 再由内置类型转换继续转换为double</span></span><br></pre></td></tr></table></figure></li>
<li><p>类型转换运算符<strong>可能产生意外结果</strong>，特别是定义向<code>bool</code>的转换时，请举例说明？</p></li>
</ul>
<h4 id="显式的类型转换运算符">显式的类型转换运算符</h4>
<ul>
<li>什么是显式的类型转换运算符？它是如何防止类型转换运算符产生意外结果的？</li>
<li>定义了显式的类型转换运算符，我们应该如何进行类型转换？</li>
<li>显式的类型转换运算符有何例外？</li>
<li>为什么向<code>bool</code>类型的转换通常指定<code>explicit</code>？</li>
</ul>
<h3 id="避免有二义性的类型转换">避免有二义性的类型转换</h3>
<ul>
<li><p>什么情况下可能出现二义性的类型转换？</p></li>
<li><p>定义类型转换运算符时，如何避免二义性的出现？</p></li>
</ul>
<h3 id="函数匹配与重载运算符">函数匹配与重载运算符</h3>
<ul>
<li>什么时候会出现重载运算符与内置运算符的二义性问题？请举例说明</li>
</ul>
<h1 id="第15章-面向对象程序设计">第15章 面向对象程序设计</h1>
<h2 id="oop概述">15.1 OOP概述</h2>
<ul>
<li><p>面向对象程序设计的三个概念是什么？分别是什么意思？</p></li>
<li><p>什么是基类？什么是派生类？</p></li>
<li><p>基类一般将成员函数分为哪两类？如何区分？</p></li>
<li><p>什么是类派生列表？</p></li>
<li><p>什么是虚函数？派生类重新定义虚函数时需要加上<code>virtual</code>关键字吗？需要加上<code>override</code>关键字吗?</p></li>
<li><p>什么是动态绑定？什么时候会发生动态绑定？</p></li>
</ul>
<h2 id="定义基类和派生类">15.2 定义基类和派生类</h2>
<h3 id="定义基类">定义基类</h3>
<ul>
<li>基类将哪些成员定义为虚函数？</li>
<li>对虚函数的调用有何特点？</li>
<li>派生类能访问基类的哪些成员？</li>
<li>什么是<code>protected</code>关键字？有何作用？</li>
</ul>
<h3 id="定义派生类">定义派生类</h3>
<ul>
<li><p>类派生列表中的访问说明符有何作用？</p></li>
<li><p>如果派生类不覆盖虚函数，会发生什么？</p></li>
<li><p><code>override</code>关键字的作用是什么？</p></li>
<li><p>派生类对象包含多个组成部分是什么意思？</p></li>
<li><p>什么是派生类向基类的转换？举出派生类向基类转换的例子</p></li>
<li><p>派生类的构造函数如何初始化基类部分？初始化顺序是怎样的？</p></li>
<li><p>派生类可以访问基类的哪些成员？</p></li>
<li><p>如果基类定义了<code>public</code>的静态成员，派生类访问该静态成员有哪些方式？</p></li>
<li><p>基类可以派生它本身吗？为什么？</p></li>
<li><p>什么是直接基类？什么是间接基类？</p></li>
<li><p>如何使一个类不能被继承？</p></li>
</ul>
<h3 id="类型转换与继承">类型转换与继承</h3>
<ul>
<li>把引用或指针绑定到一个对象上时，引用或指针的类型与对象类型有何要求？</li>
<li>什么是静态类型？什么是动态类型？</li>
<li>什么是派生类向基类转换？什么是基类向派生类转换？</li>
<li>有时候，我们可以向基类的拷贝/移动操作传递派生类对象，此处是将派生类对象转换为基类对象吗？还是什么原理？</li>
</ul>
<h2 id="虚函数">15.3 虚函数</h2>
<ul>
<li>虚函数的调用有时候在编译时解析，有时在运行时解析，请解释？</li>
<li><code>override</code>说明符的作用是什么？</li>
<li>如果我们在派生类定义了与虚函数同名，但形参列表不同的函数，会发生什么？</li>
<li>把函数指定为<code>final</code>会发生什么？</li>
<li>虚函数可以有默认实参吗？此时虚函数的调用有何特别之处？</li>
<li>为什么虚函数的默认实参在基类和派生类中最好一致？</li>
<li>如果我们希望对虚函数的调用不进行动态绑定，而是执行某个特定版本，应该怎么做？</li>
</ul>
<h2 id="抽象基类">15.4 抽象基类</h2>
<ul>
<li><p>什么是纯虚函数？为什么要声明纯虚函数？如何定义纯虚函数？</p></li>
<li><p>含有纯虚函数的类有何特别？</p></li>
</ul>
<h2 id="访问控制与继承">15.5 访问控制与继承</h2>
<ul>
<li>当我们提及类的用户时，“用户”可能有三种含义，请解释？</li>
</ul>
<h3 id="protected"><code>protected</code></h3>
<ul>
<li><code>protected</code>成员是怎样的？派生类的成员或友元可以访问基类的<code>protected</code>成员吗，派生类的普通用户可以访问基类的<code>protected</code>成员吗？</li>
<li>派生类的成员或友元可以通过派生类对象访问基类的<code>protected</code>成员吗？可以通过基类对象访问基类的<code>protected</code>成员吗？</li>
</ul>
<h3 id="publicprivateprotected继承"><code>public</code>、<code>private</code>、<code>protected</code>继承</h3>
<ul>
<li>派生访问说明符有何作用？解释<code>public</code>、<code>private</code>、<code>protected</code>继承之间的区别？</li>
<li><code>public</code>继承，派生类对于基类成员的访问权限是怎样的？</li>
<li><code>private</code>继承，派生类对于基类成员的访问权限是怎样的？</li>
<li><code>protected</code>继承，派生类对于基类成员的访问权限是怎样的？</li>
</ul>
<h3 id="派生类向基类转换的可访问性">派生类向基类转换的可访问性</h3>
<ul>
<li>假设<code>D</code>派生自<code>B</code></li>
<li>什么时候用户代码可以使用派生类向基类的转换？</li>
<li>什么时候<code>D</code>的成员函数和友元可以使用派生类向基类的转换？</li>
<li>什么时候<code>D</code>的派生类的成员和友元可以使用<code>D</code>向<code>B</code>的转换？</li>
</ul>
<h3 id="改变个别名字的可访问性">改变个别名字的可访问性</h3>
<ul>
<li>如何改变个别成员的可访问性？</li>
</ul>
<h2 id="继承中的类作用域">15.6 继承中的类作用域</h2>
<ul>
<li><p>类作用域是怎样的？继承关系中的类作用域是怎样的？</p></li>
<li><p>对象、引用或指针的静态类型决定了对象的哪些成员是可见的，请解释这句话</p></li>
<li><p>什么是隐藏？</p></li>
<li><p>派生类的名字与基类相同的名字之间的关系是怎样的？</p></li>
<li><p>如果想在派生类中访问被隐藏的基类成员，应该怎么做？</p></li>
<li><p>在继承关系中调用<code>p-&gt;mem()</code>会发生什么？请详细说明</p></li>
<li><p>派生类的函数与基类的同名函数之间的关系是怎样的？请解释重载、隐藏、覆盖之间的区别？</p></li>
<li><p>如果基类定义了虚函数，而派生类定义了与其同名但形参列表不同的函数，将发生什么？</p></li>
<li><p>请分析以下代码是否存在错误？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Base b; Derived d;</span><br><span class="line">Base* bp1 = &amp;b, bp2 = &amp;d;</span><br><span class="line">bp1-&gt;<span class="built_in">fcn</span>();</span><br><span class="line">bp2-&gt;<span class="built_in">fcn</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="构造函数与拷贝控制">15.7 构造函数与拷贝控制</h2>
<h3 id="虚析构函数">虚析构函数</h3>
<ul>
<li>为什么基类需要定义<strong>虚析构函数</strong>？</li>
<li><strong>三/五法则</strong>是什么？该法则的一个<strong>例外</strong>是什么？</li>
</ul>
<h3 id="合成拷贝控制与继承">合成拷贝控制与继承</h3>
<ul>
<li>继承体系中的合成拷贝控制成员有何特别之处？</li>
<li>类定义了析构函数，对其移动操作有何影响?</li>
<li>如果基类的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是删除或不可访问的
，派生类的对应成员是怎样的？为什么？</li>
<li>如果基类的析构函数是删除或不可访问的，派生类的合成默认构造函数、拷贝构造函数是怎样的？为什么？</li>
<li>如果基类的移动操作是删除的或不可访问的，则派生类的合成移动操作是怎样的？为什么？</li>
<li>因此，如果我们想要在<strong>派生类中进行移动操作</strong>，应该<strong>怎么做</strong>？</li>
</ul>
<h3 id="派生类的拷贝控制成员">派生类的拷贝控制成员</h3>
<ul>
<li>派生类的拷贝或移动操作会进行什么操作？</li>
<li>派生类的析构函数会进行什么操作？</li>
<li>定义派生类的拷贝或移动操作时，有什么要求？</li>
<li>定义派生类的赋值运算符时，有什么要求？</li>
<li>定义派生类的析构函数时，有什么要求？</li>
<li>继承体系中，派生类对象的构造函数或析构函数的执行有何特点？顺序是怎样的？</li>
<li>在构造函数或析构函数中调用虚函数有何需要注意的地方?</li>
</ul>
<h3 id="继承的构造函数">继承的构造函数</h3>
<ul>
<li>派生类可以“继承”基类的构造函数，是怎么做的？</li>
<li>编译器如何处理继承构造函数时的<code>using</code>声明？</li>
<li>继承构造函数如何处理派生类自定义的数据成员？</li>
<li>如果派生类通过<code>using</code>声明继承了基类的构造函数，有什么例外？哪些构造函数不会被继承？</li>
</ul>
<h2 id="容器与继承">15.8 容器与继承</h2>
<ul>
<li>容器存放的元素类型应该一致，因此想要将继承关系中的对象放入容器时，应该如何处理？</li>
</ul>
<h2 id="补充-虚函数表">补充 虚函数表</h2>
<ul>
<li>什么是类的虚表？哪些类有虚表？</li>
<li>虚表本质是什么，其元素是什么?</li>
<li>类的每个对象都有虚表吗？</li>
<li>虚表的构造发生在什么时候？</li>
<li>什么是虚表指针，每个对象都有虚表指针吗？</li>
<li>请说明类是如何通过虚表调用虚函数的？</li>
<li>动态绑定的三个条件是什么？</li>
</ul>
<h1 id="第18章-用于大型程序的工具">第18章 用于大型程序的工具</h1>
<ul>
<li>大规模应用程序开发有何特殊要求，分别用什么工具解决？</li>
</ul>
<h2 id="异常处理">18.1 异常处理</h2>
<h3 id="抛出异常">抛出异常</h3>
<ul>
<li><p>程序如何抛出异常？</p></li>
<li><p>什么是栈展开，其过程是怎样的？</p></li>
<li><p>如果栈展开，最终也没找到匹配的<code>catch</code>子句，会怎样？</p></li>
<li><p>栈展开过程中伴随着什么的发生？</p></li>
<li><p>为什么析构函数不应该抛出异常？</p></li>
<li><p>抛出一个指向局部对象的指针，会发生什么？</p></li>
</ul>
<h3 id="捕获异常">捕获异常</h3>
<ul>
<li>catch子句的参数类型是值类型或引用类型有何区别？</li>
<li>如果catch的参数是基类类型，而使用了派生类类型的异常对象初始化，会发生什么？</li>
</ul>
<h3 id="查找匹配的处理代码">查找匹配的处理代码</h3>
<ul>
<li>catch子句的顺序会造成什么影响？为此，应该如何设计catch子句的顺序？</li>
<li>catch子句的类型匹配规则是怎样的？</li>
<li>什么是重新抛出？</li>
<li>如何捕获所有异常？</li>
</ul>
<h3 id="函数try语句块与构造函数">函数try语句块与构造函数</h3>
<ul>
<li>如果在构造函数体中使用try语句块，有何问题？</li>
<li>什么是函数try语句块，有何作用？</li>
</ul>
<h3 id="noexcept异常说明">noexcept异常说明</h3>
<ul>
<li>noexcept有哪两种含义？</li>
<li>它作为异常说明符时有何作用？</li>
<li>它作为运算符时有何作用？</li>
</ul>
<h3 id="异常类层次">异常类层次</h3>
<ul>
<li><code>exception</code>包含哪4个派生类</li>
<li>异常类的<code>what()</code>成员有什么作用？</li>
</ul>
<h2 id="命名空间">18.2 命名空间</h2>
<ul>
<li>命名空间有何作用？</li>
<li>命名空间如何<strong>定义</strong>？</li>
<li>命名空间与<strong>作用域</strong>是什么关系？</li>
<li>命名空间可以<strong>不连续</strong>是什么意思？</li>
<li>命名空间可以<strong>嵌套</strong>吗？</li>
<li><strong>未命名的命名空间</strong>有何特殊之处？</li>
<li>什么是命名空间<strong>别名</strong>？</li>
<li>什么是<strong>using声明</strong>？</li>
<li>什么是<strong>using指示</strong>？</li>
</ul>
<h2 id="多重继承">18.3 多重继承</h2>
<ul>
<li>待补充</li>
</ul>
<h1 id="第19章-特殊工具与技术">第19章 特殊工具与技术</h1>
<h2 id="控制内存分配">19.1 控制内存分配</h2>
<h3 id="重载new和delete">重载new和delete</h3>
<ul>
<li><p>分别阐述new表达式和delete表达式的工作原理？</p></li>
<li><p>当执行new或delete表达式时，会调用相应的operator函数，编译器是如何进行解析的？</p></li>
<li><p>重载operator new或operator delete的作用是什么？</p></li>
<li><p>operator new的返回类型是什么？第一个形参类型是什么？</p></li>
<li><p>operator new有一个版本无法重载，是什么？它的作用是什么？</p></li>
<li><p>operator delete的返回类型是什么？第一个形参类型是什么？</p></li>
<li><p>operator delete不抛出异常，为什么？</p></li>
<li><p>operator new和operator
delete作为类成员时，为什么是隐式静态的？</p></li>
<li><p>malloc和free函数的作用分别是什么?</p></li>
</ul>
<h3 id="定位new表达式">定位new表达式</h3>
<ul>
<li>什么是定位new表达式？</li>
<li>接受单一地址参数的定位new表达式有何特殊之处？它的作用是什么？</li>
<li>接受单一地址参数的定位new表达式和allocator类的construct成员有何异同？</li>
</ul>
<h2 id="运行时类型识别">19.2 运行时类型识别</h2>
<ul>
<li>运行时类型识别的英文全称和简称是什么？它由哪两个运算符组成？</li>
<li>什么时候我们需要使用运行时类型识别？</li>
</ul>
<h3 id="dynamic_cast运算符">dynamic_cast运算符</h3>
<ul>
<li>dynamic_cast的三种形式分别是什么？对参数有何要求？</li>
<li>dynamic_cast对<strong>表达式类型</strong>和<strong>目标类型</strong>有何要求？</li>
<li>dynamic_cast的引用类型和指针类型有何区别？如何使用？</li>
</ul>
<h3 id="typeid运算符">typeid运算符</h3>
<ul>
<li>typeid运算符作用是什么？</li>
<li>typeid运算符作用于引用时会怎样？作用于指针时会怎样？</li>
<li>typeid运算符的结果在编译时求得还是在运行时求得？</li>
<li>typeid常用于什么场景？</li>
</ul>
<h3 id="rtti使用">RTTI使用</h3>
<ul>
<li>具有继承关系的类实现相等运算符，是RTTI的典型使用场景，试阐述其具体实现</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Young
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://example.com/2022/02/13/C++-Primer-%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%E9%9B%86/" title="C++ Primer 关键问题集">http://example.com/2022/02/13/C++-Primer-关键问题集/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/02/13/C++-Primer-Chapter-6/" rel="prev" title="C++ Primer Chapter 6">
                  <i class="fa fa-chevron-left"></i> C++ Primer Chapter 6
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/02/13/C++-Primer-Chapter-7/" rel="next" title="C++ Primer Chapter 7">
                  C++ Primer Chapter 7 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Young</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  




  <script src="/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
