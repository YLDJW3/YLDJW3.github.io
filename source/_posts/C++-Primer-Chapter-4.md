---
title: C++ Primer Chapter 4
date: 2022-02-12 20:13:26
tags: C++
categories: C++
mathjax: true  
---

# 第四章 表达式

## 4.1 基础

### 重载运算符

- 运算符作用于类类型的对象时，类可以自行定义其含义，称为**重载运算符**
- 如IO库的`>>`和`<<`，string和vector对象 的运算符等

### 左值和右值

- 表达式要么是左值，要么是右值
- **左值表达式的结果是一个对象或一个函数**
- 当一个对象用作右值时，用的是对象的值；当一个对象用作左值时，用的是对象的身份（在内存中的位置）
- 需要右值的地方可用左值代替，此时使用的是左值的内容（值）；但需要左值的地方不能用右值代替

### 求值顺序、优先级、结合律

- 运算对象的求值顺序与优先级、结合律无关，如`f() + g() * h() + j()`中，这**四个函数的调用顺序是不确定的**
- 因此当函数的调用顺序会对结果造成影响时，应该先调用函数获取返回值，再将其用于运算中

<!--more-->

## 4.2 算术运算符

### 算术运算异常

- 数学性质导致的异常，如除以0
- 溢出导致的异常（编译器一般不会报错）

### 整除

- C++11新标准规定**商一律向0取整**，即直接切除小数部分

### 取余

- `m%n`的结果符号和`m`一致



## 4.3 逻辑和关系运算符

- 比较运算时，除非比较对象为布尔类型，否则不要使用布尔字面值true和false

### 短路求值

- 先求逻辑与/或都会先求左侧运算对象的值，**若其无法确定表达式的值时，才计算右侧运算对象的值**

## 4.4 赋值运算符

### 左值

- 赋值运算符的左侧必须是一个可修改的左值

### 赋值运算的结果

- 结果是它的左侧运算对象，并且是一个左值

### 花括号括起的初始值列表

- 若左侧运算对象是内置类型，那么初始值列表最多只能包含一个值，而且**该值即使转换的话其所占空间也不应该大于目标类型的空间**

### 赋值运算符满足右结合律

```c++
int i, j;
i = j = 1;
```



## 4.5 递增运算符和递减运算符

### 前置版本

```c++
++i;
```

- 首先将运算对象加1，然后**将改变后的对象作为求值结果**
- 其**返回值是对象本身，是左值**

### 后置版本

```c++
i++;
```

- 将运算对象加1，并将对象加1前的**值作为求值结果**
- 其**返回值是对象原本的值，是右值**

### 非必须不要使用后置版本

- 因为它相当于保存了运算对象的值的副本作为返回值，然后再对运算对象加1，造成了浪费

### 使用后置版本的场景：混用解引用和递增运算符`*it++`

- 以下代码，`*it++`效果是将迭代器`it`指向的元素值输出，然后让其指向下一位置
- 但实际上，它是先对递增运算符进行运算，此时`it`指向下一位置，并将指向下一位置前的值作为副本返回，此时解引用符得到的`it`递增前指向的位置，因此能够将`it`本来指向的元素值输出

```c++
auto it = v.begin();
while (it != v.end()) {
    cout << *it++ << " ";
}
```

## 4.6 成员访问运算符

### 点运算符、箭头运算符都可用于访问成员

- `ptr->mem`等价于`(*ptr).mem`

## 4.7 条件运算符`?:`

- `cond ? expr1 : expr2`，首先求`cond`的值，若为真则对expr1求值并返回，若为假则对expr2求值并返回

### 低优先级

- 在输出语句使用条件运算符时，应将其用圆括号括起

## 4.8 位运算符

- 求反、左移、右移、位与、位或、位异或

### 符号位的处理依赖于机器

- 例如对负数左移时，如何处理符号位是不确定的
- **最好只对无符号类型进行位运算**

### 移位运算符满足左结合律

- 在IO运算符可以得到体现

## 4.9 `sizeof`运算符

- `sizeof`运算符返回**一条表达式或一个类型名字所占的字节数**
- `sizeof expr`并不会实际计算运算对象的值

### `sizeof`的运算结果

- 对引用类型执行`sizeof`运算将得到被引用对象所占空间的大小
- 对指针执行`sizeof`运算得到指针本身所占空间大小
- 对解引用指针执行`sizeof`得到指针指向对象所占空间大小，即`sizeof *p`等价于`sizeof(*p)`

## 练习

- 以下表达式是否正确，`ptr`是`int*`类型，`vec`是`vector<int>`类型，`ival`是int类型

  ```c++
  ptr != 0 && *ptr++			// 如果ptr非空指针且指向的整数非0则为真
  ival++ && ival				// 如果ival不是0且ival + 1也不是0则为真
  vec[ival++] <= vec[ival]	// 错误, 因为两侧运算对象求值顺序不确定, 因此无法判断右侧ival的值
  ```



## 4.10 逗号运算符

- 常用于for循环中

  ```c++
  for (...; ...; ++idx,--cnt) {...}
  ```

- 逗号运算符按从左到右的顺序求值，首先**求左侧表达式的值，丢弃**；然后求**右侧表达式的值并返回**



## 4.11 类型转换

### 隐式转换

- 编译器自动转换，无需程序员介入

#### 算术转换

- 整型提升：小整数类型提升为大整数类型
- 无符号与有符号类型混合运算：如果无符号类型不小于带符号类型，则将带符号类型转换为无符号类型；否则，转换结果依赖于机器。因此最好**不要将无符号类型与有符号类型混合运算**

#### 其他隐式转换

- 条件处转换成布尔类型
- 转换成常量，如指向非常量类型的引用或指针，转换为指向相应常量类型的引用或指针

### 显式转换

```c++
cast-name<type>(expression)
```

- 其中**cast-name是转换类型，包含`static_cast`, `dynamic_cast`, `const_cast`, `reinterpret_cast`**
- type是转换的目标类型
- expression是要转换的值

#### `static_cast`

- 任何具有明确定义的类型转换，只要不包含底层const，都可以使用`static_cast`
- 把较大的算术类型赋值给较小的算术类型时，若使用了`static_cast`则编译器不会给出警告消息

```c++
double a = 3.14;
int b = static_cast<int>(a);
```

- 用于**找回存在于void*的指针**，但仍保证该指针类型相符，若不符则产生的行为是未定义的

```c++
int a = 1;
void *p = &a;
int *p1 = static_cast<int*>(p);
```

#### `const_cast`

- 只能**改变运算对象的底层const**
- 若运算对象指向的对象本身不是常量，则产生的行为是合法的；若其所指对象是常量，则通过该指针或引用改变该对象将产生未定义的后果

#### `reinterpret_cast`

- 为运算对象的位模式提供较低层次上的重新解释，如下

  ```c++
  int *ip;
  char *pc = reinterpret_cast<char*>(ip);
  ```

  

### 尽量避免使用显示转换

