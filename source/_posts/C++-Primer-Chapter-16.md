---
title: C++ Primer Chapter 16
date: 2022-02-22 19:37:42
tags: C++
categories: C++
mathjax: true
---

**C++ Primer第16章笔记**

<!--more-->

## 16.1 定义模板

### 16.1.1 函数模板

- 一个**函数模板**就是一个公式，可用来生成**特定类型的函数版本**

- 模板定义以**关键字`template`**开始，后跟一个**模板参数列表**，以**逗号**分隔多个**模板参数**，用`<>`包围起来

  ```c++
  template <typename T>
  int compare(const T& v1, const T& v2) {
      if (v1 < v2)
          return -1;
      if (v2 < v1)
          return 1;
      return 0;
  }
  ```

- **模板参数**表示在类或函数定义中用到的**类型或值**，**使用模板**时需要**指定模板实参**，将其绑定到模板参数上

#### 实例化函数模板

- 调用**函数模板**时，编译器用**函数实参**来为我们**推断模板实参**
- 编译器用推断出的模板参数为我们**实例化**一个**特定版本的函数**，使用**实际的模板实参**代替对应的**模板参数**来创建出模板的一个新“实例”

- 这些编译器生成的版本通常被称为模板的**实例**

#### 模板类型参数

- `compare`函数有一个**模板类型参数**，类型参数可看作类型说明符，如同内置类型或类类型说明符一样使用
- **类型参数**可**指定返回类型**或函数的**参数类型**，以及在函数体内用于**变量声明**或**类型转换**
- 类型参数前必须使用关键字`typename`或`class`，在模板参数列表中这两个关键字含义相同，可互换使用

#### 非类型模板参数

- 在模板中定义**非类型参数**，表示**一个值**，通过**特定的类型名**而非`class`或`typename`指定非类型参数
- 模板被**实例化**时，非类型参数被一个**用户提供的或编译器推断出的值**所替代，这些值**必须是常量表达式**
- 非类型参数可以是整型，或指向对象或函数类型的指针，或左值引用
  - 绑定到非类型**整型参数**的实参必须是**常量表达式**
  - 绑定到**指针或引用**的非类型参数的实参必须具有**静态的生存期**（**`static`对象**），指针参数也可以用`nullptr`或值为0的常量表达式来实例化
- 模板定义内，非类型参数是一个**常量值**，在需要**常量表达式**的地方可以**使用非类型参数**，如指定数组大小

#### 编写类型无关的代码

- 编写泛型代码的两个重要原则
  - 模板中的**函数参数是`const`引用**
  - 函数体中的**条件判断仅使用`<`比较运算**

> 第一点保证了可将函数用于不能拷贝的类型，第二点使得函数只要求类型支持`<`，不必同时支持`>`，减少了对实参类型的要求

- 模板程序应尽量减少对实参类型的要求

#### 模板编译

- 编译器遇到**模板定义时不生成代码**
- 只有在**实例化**出**模板的一个特定版本**时，编译器才**生成代码**
- 为了**生成**实例化版本，编译器需要**掌握函数模板或类模板成员函数的定义**，因此模板的**头文件**通常既包含**声明**也包含**定义**

#### 模板编译错误的三个阶段

- **编译模板本身**时，检查语法错误等
- 编译器遇到**模板使用**时，检查实参数量是否正确、参数类型是否匹配等
- 编译器进行**模板实例化**时，会发生类型相关的错误，大多数错误在实例化期间报告

### 16.1.2 类模板

- **类模板**用于生成类的蓝图，编译器**不能**为类模板**推断模板参数类型**，必须在模板名后的尖括号中提供额外信息

- 类模板的成员函数具有和模板相同的模板参数，**定义在类模板之外**的成员函数必须**以关键字`template`开始，后接类模板参数列表**
- 对于一个实例化了的类，其**成员**只有在**使用时才被实例化**。如果一个成员函数没有被使用，则它不会被实例化
