---
title: C++ Primer Chapter 18
date: 2022-02-23 10:16:59
tags: C++
categories: C++
mathjax: true
---

**C++ Primer第18章笔记**

<!--more-->

# 第18章 用于大型程序的工具

- **大规模**应用程序的特殊要求包括
  - 在独立开发的子系统之间**协同处理错误**（**异常处理**）
  - 使用各种库进行**协同开发**（**命名空间**）
  - 对复杂应用概念**建模**（**多重继承**）

## 18.1 异常处理

- **异常处理**允许程序中**独立开发的部分**对在运行时就出现的问题做出处理，**问题检测**与**问题解决**被分离

### 18.1.1 抛出异常

- 通过**抛出**一条表达式来**引发**一个异常

#### 栈展开

- 抛出异常后，程序暂停当前函数的执行过程，并寻找与异常匹配的`catch`子句
- 寻找与异常匹配的`catch`子句的过程称为**栈展开**，具体为
  - 首先在`throw`**当前的`try`语句块**内，检查与该`try`块关联的`catch`子句
  - 如果该`try`嵌套在**外层`try`语句块**中，检查外层`try`关联的`catch`子句，依此类推
  - 在调用当前函数的**外层函数**继续查找，过程同上
- 栈展开过程沿着**嵌套函数的调用链**不断查找
  - 若没找到匹配的`catch`，则**退出主函数**后终止查找过程，程序将调用**标准库函数`terminate`终止程序的执行过程**
  - 若找到了匹配的`catch`，则进入该子句并执行其中的代码，**执行完`catch`子句**后，找到与`try`块关联的最后一个`catch`子句之后的点，并从这里**继续执行**

#### 栈展开过程中对象被自动销毁

- 栈展开过程中，若**提前退出**了调用链上的**语句块**，则其**局部对象也随之销毁**。如果局部对象是类类型将自动调用该对象的**析构函数**，如果是内置类型则无需做任何事情

- **析构函数不应该抛出**它自己无法处理的异常，一旦栈展开过程中析构函数抛出了异常，且其自己无法捕获异常，则**程序将被终止**

  > 根据《more effective C++》析构函数不应该抛出异常，因为
  >
  > - 析构函数抛出异常，将导致其后的释放资源的代码被跳过
  > - 前一个异常尚未处理，而析构函数又抛出了异常，无法处理

#### 异常对象

- 异常对象是一种特殊对象，使用**`throw`表达式**对异常对象进行**拷贝初始化**
- 抛出一个指向局部对象的指针，是一个错误行为，该局部对象可能会在执行`catch`子句前被销毁
- 抛出表达式时，**表达式的静态类型决定了异常对象的类型**，如果`throw`表达式解引用一个**基类指针**，即使该指针指向**派生类对象**，也只有**基类部分被抛出**（派生类部分被**切掉**）

### 18.1.2 捕获异常

- `catch`子句中的异常声明，其类型必须是**完全类型**，可以是左值引用，**不能是右值引用**
- 如果`catch` 的参数类型是**非引用参数**，则该参数在`catch`子句内是异常对象的一个**副本**，如果是**引用类型**，则该参数是异常对象的一个**别名**
- 如果`catch`的参数是**基类类型**，则可以使用**派生类类型的异常对象**进行初始化，如果是**非引用类型**则异常对象会被**切掉**一部分，**只保留基类部分**，因此如果`catch`接受的异常与继承体系有关，**最好将其定义为引用类型**

#### 查找匹配的处理代码

- 在搜寻`catch`语句过程中，我们会进入第一个与异常匹配的`catch`语句，但未必是异常的最佳匹配
- 因此，越是**专门**的`catch`越应该置于`catch`列表的**前端**。对于继承体系，应该把**继承链最底端**的类放在**前面**，**继承链最顶端**的类放在**后面**
- `catch`的类型匹配，绝大多数的类型转换不被允许，除了
  - **非const对象**匹配**指向const对象的引用**
  - **派生类**向**基类**的转换
  - **数组**转换为**数组指针**，**函数**转换为**函数指针**

#### 重新抛出

- 如果当前的`catch`处理完后，还需要**调用链更上一层的函数**接着处理异常，可以通过**重新抛出**将异常传递给另一个`catch`语句

- 重新抛出是一条**不包含任何表达式的`throw`语句**

  ```c++
  throw;
  ```

- 除了在`catch`子句外，**其他区域**执行空`throw`语句，编译器将**调用`terminate`**

- 重新抛出语句将**当前的异常对象**沿着**调用链向上传递**，特别地，如果`catch`子句的参数不是引用类型，则传递的异常对象不包含当前`catch`子句对其的改变

#### 捕获所有异常

- 使用省略号，`catch(...)`将**捕获所有异常**

  ```c++
  try {
      // ...
  } catch(...) {
      // ...
  }
  ```

### 18.1.3 函数try语句块与构造函数

- 如果构造函数**初始值列表执行**时出现了**异常**，则构造函数体中的`try`语句块无法捕获异常

- 为此，我们将构造函数写成**函数`try`语句块**，也称为**函数测试块**，它使得`catch`语句既能处理**构造函数体**，也能处理构造函数**执行初始值列表**的过程

- 方法是在构造函数的**形参列表后**、**冒号前**加上`try`

  ```c++
  T(const string &s) try: name(s) {
      // ...
  } catch(...) {
      // ...
  }
  ```

### 18.1.4 `noexcept`异常说明

#### 异常说明符

- 如果确定某个函数不抛出异常，可以提供`noexcept`说明，通过**关键字`noexcept`紧跟在函数形参列表后**进行说明

  ```c++
  void f() noexcept {
      // ...
  }
  ```

  

- 对于一个函数，`noexcept`说明要么出现在该函数的所有声明语句和定义语句中，要么一次也不出现

- 编译器**不会在编译时检查`noexcept`**，如果一个函数说明了`noexcept`，但又含有`throw`语句或调用了其他抛出异常的函数，仍然能编译成功。运行时，如果**说明了`noexcept`的函数**，**抛出了异常**，程序会**调用`terminate`**

#### 运算符

- 一元运算符，返回`bool`类型的右值常量表达式，表示**给定的表达式是否会抛出异常**

- 当该表达式**本身不包含`throw`**，且**调用**的**所有函数也作了`noexcept`说明**时，返回`true`

  ```c++
  void f() noexcept {
      // ...
  }
  void g() noexcept(f()) {
      // ...
  }
  // g()的不抛出说明与f()一致, 若f()可能抛出异常则g()也可能, 否则g()不抛出异常
  ```

#### 异常说明与指针、虚函数和拷贝控制

- **函数指针**与该指针指向的函数必须具有一致的异常说明

  - 如果函数指针**做了不抛出说明**，它**只能**指向**不抛出异常的函数**
  - 如果函数指针**没有做不抛出说明**，它可以指向**任何函数**

  ```c++
  void f(int) noexcept {
      // ...
  }
  void (*pf1)(int) noexcept = f;	// pf1只能指向不抛出异常的函数
  void (*pf2)(int) = f;			// pf2可指向任何函数
  ```

- **虚函数**与抛出异常

  - 如果**虚函数**承诺了**不抛出异常**，则**后续派生出的虚函数**也**必须承诺不抛出异常**
  - 如果**虚函数**允许**抛出异常**，则**后续派生的虚函数**可以允许抛出异常，也可以不抛出异常

### 18.1.5 异常类层次

- 标准库异常类的继承体系
- `exception`派生出`bad_cast`、`bad_alloc`、`runtime_error`、`logic_error`
- `bad_cast`、`exception`、`bad_alloc`定义了**默认构造函数**
- `runtime_error`和`logic_error`没有默认构造函数，有一个**接受C风格字符串或标准库`string`类型**实参的构造函数
- `what()`成员返回用于初始化**异常对象的信息**，`what()`是**虚函数**，可以动态绑定

## 18.2 命名空间

- 目的：为了防止**大型程序开发**过程中，不同库名字放在全局命名空间中引发**命名空间污染**
- 命名空间**分割了全局命名空间**，每个命名空间是一个**作用域**

### 18.2.1 命名空间定义

- 命名空间的**定义**由**关键字`namespace`**，随后是**命名空间的名**字，后面是一系列**花括号括起的声明和定义**，其中可以包含**类、变量、函数、模板和其他命名空间**

  ```c++
  namespace A {
      int i = 10;
      // ...
  }
  ```

- 命名空间可以定义在**全局作用域**，可以定义在**其他命名空间中**，但**不能**定义在**函数或类的内部**

#### 每个命名空间都是一个作用域

- 不同命名空间内可以有相同名字的成员

- 命名空间的名字可以被命名空间内的其他成员直接访问，也可以被这些成员内嵌作用域的任何单位访问。而命名空间之外的代码则必须明确指出所用的名字属于哪个命名空间

  ```c++
  namespace A {
      int i = 10;
      int j = 9;
      int k = i + j;
  }
  
  void f() {
      cout << A::k << endl;
  }
  ```

#### 命名空间可以不连续

```c++
namespace A {
    int i = 10;
    int j = 9;
    int k = i + j;
}

namespace A {
    void f() {
        cout << k << endl;
    }
}
```

#### 命名空间可以嵌套

```c++
namespace A {
    int i = 10;
    int j = 9;
    int k = i + j;
    namespace B {
        int i = 11;
        void f() {
            cout << i << endl;
        }
    }
}

A::B::f();
```

#### 未命名的命名空间

```c++
namespace {
    int i = 10;
}
```

- **未命名的命名空间**中定义的变量拥有**静态生命周期**，在第一次使用前创建，直到程序结束才销毁
- 未命名的命名空间**仅在文件内部有效**，其作用域无法跨越文件
- 未命名的命名空间中的名字的**作用域**，与**该命名空间所在的作用域相同**
- 未命名的命名空间中的名字**可以直接使用**

### 18.2.2 使用命名空间成员

#### 命名空间别名

- 为命名空间的名字设定一个**更短的别名**，以方便使用

  ```c++
  namespace p = cpluscplus_primer;
  // p设定为命名空间cpluscplus_primer的别名
  ```

- 特别地，我们可以给**嵌套的命名空间**取**别名**

  ```c++
  namespace E1 = A::B::C::D::E;
  cout << E1::i << endl;
  ```

#### `using`声明

- 一条`using`**声明**语句一次只引入命名空间的**一个成员**

  ```c++
  using namespace std::vector;
  ```

#### `using`指示

- `using`**指示**以`using`开始，后跟`namespace`关键字和命名空间名字，该命名空间中的**所有名字都是可见的**

  ```c++
  using namespace std;
  ```

- `using`**指示**与**作用域**

  - `using`指示将命名空间成员提升到**包含命名空间本身和`using`指示**的**最近作用域**

  ```c++
  namespace A {
      int j;
  }
  int j = 0;
  void f() {
      using namespace A;
      ++j;		// 二义性错误
  }
  ```


## 18.3 多重继承

- 待补充

## 习题

- 下列代码存在什么问题？

  ```c++
  void exercise(int *b, int* e) {
      vector<int> v(b, e);
      int *p = new int[v.size()];
      ifstream in("ints");
      // 此处发生异常
  }
  ```

  - 存在的问题是`new`分配的动态对象无法得到释放，造成内存泄漏

  - 解决方法：使用**智能指针**

  ```c++
  shared_ptr<int> sp(new int[v.size()], [](int* p) { delete[] p; });
  // shared_ptr不支持支持管理数组, 必须传入删除器, 使用delete[]
  unique_ptr<int[]> up(new int[v.size()]);
  // unique_ptr支持管理数组, 模板类型参数传入T[]即可, 其中T为数组元素类型
  ```

  

