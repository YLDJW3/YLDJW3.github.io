---
title: C++ Primer Chapter 3
date: 2022-02-12 13:29:34
tags: C++
categories: C++
mathjax: true 
---

# 第三章 字符串、向量和数组

## 3.1 命名空间的using声明

### 作用域操作符`::`

- 作用域操作符的含义是，编译器应该从操作符左侧名字所示的**作用域**中寻找右侧的**名字**，因此`std::cin`意思是使用命名空间`std`中的名字`cin`

### using声明

- 通过using声明可以无须专门前缀也能使用所需的名字

  ```c++
  using namespace::name;
  ```

  一旦有了上述语句，就可以直接访问命名空间的名字，即直接使用`name`

#### 每个名字都需要独立的using声明

- 每个using声明仅可以引入命名空间中的一个成员，例如既要使用`cin`又要使用`cout`则需要使用一下语句

  ```c++
  using std::cin;
  using std::cout;
  ```

#### 声明整个命名空间

- 通过以下语句，使用std中的名字时都不需要添加前缀

  ```c++
  using namespace std;
  ```

#### 头文件不应该包含using声明

- 在不经意间包含了一些名字，反而可能产生名字冲突

<!--more-->

## 3.2 标准库类型string

### 直接初始化和拷贝初始化

- 使用等号`=`初始化一个变量称为**拷贝初始化**

  ```c++
  string s = "aaa";
  ```

- 不使用等号的初始化，为**直接初始化**

  ```c++
  string s1("aaa");
  string s2(3, 'a');
  ```

### string的操作

- `s.empty()`，`s.size()`，`s[i]`，`s1+s2`，`==`，`<`，`<=`，`>`，`>=`

#### `size()`函数的返回值

- `s.size()`的返回值是`string::size_type`类型，这是一个无符号类型

- 一般可以通过auto声明变量以存储`size()`的返回值

  ```c++
  auto len = s.size();
  ```

- 避免将int与size()的返回值混合使用

#### 字符串字面值/字符字面值 与 string相加

- 标准库允许字符串字面值/字符字面值 与 string相加，此时会将字符串字面值/字符字面值转换成string对象

- 必须确保加法运算符两侧的运算对象中，**至少有一个是string**

- 易混淆的情况，连加

  ```c++
  string s1 = "";
  string s2 = s1 + "!" + "?";
  string s3 = "!" + "?" + s1;
  ```

  - s2的定义是合法的，因为首先运算`s1 + "!"`，此时运算结果是一个string对象，再与后面的`"?"`相加
  - s3的定义是非法的，因为首先运算`"!" + "?"`，此时两个字符串字面值相加

### cctype头文件的函数

- 主要负责处理字符串中的**某个字符**
- `tolower(c)`，若字符`c`为大写字母，则将字符`c`转换为相应的小写字母，否则仍然返回`c`
- `toupper(c)`，若字符`c`为小写字母，则将字符`c`转换为相应的大写字母，否则仍然返回`c`

### 使用范围for语句改变字符串中的字符

- 通过将循环遍历定义为引用类型，可以改变字符串中的字符

- 例，将字符串所有小写字母转换为大写

  ```c++
  string upper(string& s) {
      for (auto&ch: s) {
          ch = toupper(ch);
      }
      return s;
  } 
  ```

### 使用下标访问某个字符

- 下标的合法取值范围是`[0, s.size())`
- C++不要求标准库监测下标合法性，因此使用超出范围的下标会产生不可预知的结果
- 可以通过`decltype(s.size())`声明下标的类型

### Test

- 下面的范围for语句是否合法，若合法则`c`的类型是什么

  ```c++
  const string s = "Keep out!";
  for (auto &c: s) { 
      //...
  }
  ```

  合法，`c`的类型是const char&，但循环代码块中不能改变`c`



## 3.3 标准库类型vector

### 模板

- C++语言既有类模板，也有函数模板，其中vector是一个类模板
- 模板本身不是类或函数，编译器根据模板创建类或函数的过程称为实例化（instantiation），使用模板时需要指出编译器应把类或函数实例化成**何种类型**

- vector是模板而非类型，由vector生成的类型必须包含vector中元素的类型，如`vector<int>`

### 初始化

- 列表初始化、括号初始化、拷贝初始化、默认初始化（空vector）

- 把一个vector对象的元素拷贝给另一个vector对象进行初始化时，两个vector对象的元素类型必须一致

- 区分**圆括号（构造）**和**花括号（列表初始化）**的情况

  ```c++
  vector<string> a1{"hello", "world"};
  vector<string> a2(10, "hello");
  ```

#### 特殊情况：使用花括号进行构造

- 当初始化时使用了花括号，但提供的值**不能进行列表初始化**时，编译器会**尝试构造**

- 若提供的值既不能列表初始化，又不能进行构造时，编译器会报错

  ```c++
  vector<string> a3{10, "hello"};
  // 以上语句的花括号相当于圆括号, a3是一个包含10个"hello"元素的vector
  ```

### 向vector对象添加元素

#### vector对象能高效增长

- C++标准要求vector能在运行时高效快速地添加元素
- 因此最好的方法是创建空的vector对象，并在运行时动态地添加元素，这样的性能反而更好

#### 不要在范围for语句体内改变所遍历序列的大小

- 如以下代码会导致不可预料的错误结果

```c++
vector<int> a{1, 2};
for (auto &v: a)
    a.push_back(v + 1);
```



## 3.4 迭代器介绍

### 尾后迭代器

- end成员返回指向容器尾元素的下一个位置的迭代器
- 如果容器为空，则**begin和end成员返回的是同一个迭代器，均为尾后迭代器**

### 迭代器支持的运算符

- `++`, `--`, `==`, `!=`
- 使用相等和不等运算符判断两个迭代器是否相等
- `++`让迭代器指向下一个元素
- `--`让迭代器指向容器的上一个元素

#### 解引用

- `*iter`返回迭代器所指元素的引用

#### 对尾后迭代器的运算

- 不能解引用`*`，不能递增`++`

### 迭代器类型

- 主要分为两种，分别是`iterator`和`const_iterator`，且与所迭代的容器类型有关，如`vector<int>::iterator`

- `iterator`可读可写，`const_iterator`只读不写
- 如果vector或string对象是一个**常量，则只能使用const_iterator**

#### cbegin成员和cend成员

- 分别返回指向容器第一个元素的迭代器，和指向尾元素后一位置的迭代器
- 不管容器是否常量，均返回const_iterator

### 箭头运算符

```c++
vector<string> a{...};
auto it = a.begin();
if ((*it).empty()) {...};
```

- 上述if语句将判断a对象的首元素string是否为空，它首先对迭代器`it`解引用，然后调用其`empty()`方法
- 上述语句可通过箭头运算符简化

```c++
if (it->empty()) {...};
```



### 某些对vector对象的操作会使迭代器失效

- 但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素



### 迭代器的算术运算

- `iter += n`，迭代器向后移动`n`个位置
- `iter -= n`，迭代器向前移动`n`个位置
- `iter1 - iter2`，参与运算的**两个迭代器必须指向同一容器的某个元素或尾后位置**，结果是两个迭代器的距离，其类型是名为`difference_type`的带符号整型数



## 3.5 数组

- 数组的大小确定不变，不能随意向数组增加元素

### 定义和初始化数组

- 定义数组时，维度必须是一个常量表达式

#### 默认初始化

- 默认情况下，数组的元素被**默认初始化**，若定义在函数体内，则初始化令数组含有未定义的值

#### 显式初始化

- 列表初始化

  ```c++
  int a[3] = {1, 2, 3};
  ```

- 允许不指定维度，此时编译器将根据列表提供的值的数量确定维度

  ```c++
  int a[] = {1, 2, 3};
  ```

- 字符数组的特殊初始化方式：使用**字符串字面值**初始化，此时结尾的空字符也将拷贝到数组中

  ```c++
  char a[] = "hello";
  ```

  字符数组`a`的维度是6，包含字符串字面值末尾的空字符

#### 不允许拷贝和赋值

- 不能用一个数组给另一个数组进行拷贝初始化

- 也不能用一个数组为另一个数组赋值

  ```c++
  int a1[] = {1, 2};
  int a2 = a1;		// 非法
  a2 = a1;			// 非法
  ```



### 复杂的数组声明

#### 从数组名字开始从内向外阅读

- 定义数组的引用，数组的指针

```c++
int (*pa)[10] = &arr;		// pa指向一个含有10个int的数组
int (&ra)[10] = arrl		// ra引用一个含有10个int的数组
```

- 又一个例子

```c++
int *(&ra)[10] = ptrs;		// ra引用一个含有10个int型指针的数组
```

### size_t类型

- 使用下标访问数组时，可将下标定义为`size_t`类型，这是一种机器相关的无符号类型
- 在`cstddef`头文件中定义了`size_t`类型

### 使用范围for语句遍历数组

- 用法与遍历vector时相似

```c++
int a[] = {1, 2, 3};
for (auto &v: a) 
    cout << v << " ";
```

### 数组和指针

#### 数组名字与指针

- 在很多使用**数组名字**的地方，编译器会自动地将其替换为一个**指向数组首元素的指针**

- 特殊情况：`decltype`仍然会返回数组类型

  ```c++
  int a[2] = {0, 1};
  decltype(a) a1 = {1, 2};
  // decltype(a)返回的类型是由2的数组
  ```


#### 数组指针支持vector迭代器的操作

- 递增、递减运算符

  ```c++
  int a[] = {...};
  int *p = a;	// p指向a[0]
  ++p;		// p指向a[1]
  ```

##### 尾后指针

- 使用大小等于数组维度的下标索引符，以获取数组的尾后指针

  ```c++
  int a[3] = {...};
  int *e = &a[3];		// 获取数组的尾后指针
  ```

- 尾后指针不能执行解引用、递增操作

##### 更安全的获取尾后指针的方法

- C++11引入了两个名为begin和end的函数，将数组作为其参数可以获得指向数组首元素的指针、指向数组尾后位置的指针

- 这两个函数定义在`<iterator>`头文件中

  ```c++
  int a[] = {...};
  int *b = begin(a);
  int *e = end(a);
  ```

  

#### 指针运算

- 解引用、递增、比较、递减、与整数相加、两个指针相减等，与vector迭代器类似
- 两个指针相减结果是一个类型名为`ptrdiff_t`的标准库类型，是带符号类型
- 只有两个指针**指向同一个数组**的元素或其尾后位置，才能进行**相减与比较**

##### 下标操作（内置下标操作支持负值）

- 数组指针经运算后，只要还是指向该数组的元素，就可以进行下标操作
- 特别地，**内置的下标操作支持负值下标（只要仍指向该数组的元素）**，而vector和string的下标操作只支持无符号类型

```c++
int a[] = {...};
int *p = &a[2];
int j = p[1];		// 相当于a[3]
int k = p[-1];		// 相当于a[1]
```













































