---
title: 数据库-面试题
date: 2022-02-18 22:38:02
tags: 
    - Database System
    - 面试
mathjax: true
categories: Database System
---

**数据库常考面试题总结**

<!--more-->

# 关键问题

## 基本原理

- 数据库三大范式是什么？
- 事务状态有哪些？
- 事务的四大特性是什么？
- 如何实现事务的四个特性？
- 事务的隔离级别有哪些？
- 事务并发执行可能产生什么问题？
- 事务的各个隔离级别分别解决了什么问题？
- 索引的数据结构有哪些？有何优缺点？

## MySQL中的具体实现

- MySQL日志有哪些？
- MySQL的redo log有何作用？刷盘时机是怎样的？
- MySQL的binlog有何作用？刷盘时机是怎样的？
- MySQL的redo log使用了两阶段提交是怎样的？
- MySQL的MVCC是如何实现的？使用了哪三个关键机制？
- MySQL是如何防止幻读的？
- MySQL的InnoDB引擎默认隔离等级是什么？

# 数据库基础概念

## 什么是数据库

- **数据库（Database）**是保存**有组织的数据**的**容器**（通常是一个文件或一组文件），是通过**数据库管理系统（DataBase- Management System，DBMS）**创建和操纵的容器。DBMS的主要目标是提供一种可以方便、高效地存取数据库信息的途径
- 目前，较为流行的数据库管理系统有MySQL、SQL Server、Oracle等

## 什么是`SQL`

- `SQL` 是**结构化查询语言（Structured Query Language）**的缩写，是一种数据库查询语言，用于**存取数据、查询、更新和管理关系数据库系统**。`SQL` 由少量的描述性很强的词构成，简单易学

## 关系型数据库、非关系型数据库的对比

- 数据库有两种类型，分别是 **关系型数据库** 和 **非关系型数据库**

|      | 关系型数据库                                                 | 非关系型数据库                                               |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定义 | 建立在关系模型基础上，由多张能互相连接的**表**组成的数据库   | 非关系型数据库又被称为 NoSQL（Not Only SQL )，通常指数据以 **对象** 的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定。 |
| 优点 | 1）使用**表结构**，格式一致，易于维护；<br>2）使用 `SQL` 语句，可用于**复杂查询**；<br>3）数据存储在**磁盘**中，安全性高 | 1) 存储数据的格式可以是 **key-value 、文档、图片**等形式，应用场景更广泛；<br>2）可轻松进行**海量数据**的维护和处理；<br>3）具有可扩展、**高并发**、高稳定性、成本低的优势；<br>4）可以实现数据的**分布式**处理 |
| 缺点 | 1）读写**性能**比较**差**；<br>2）建立在关系模型上，不可避免空间浪费；<br>3）固定的表结构，**灵活度**较低 | 1）**不提供 `SQL` 支持**；<br>2）无事务处理，无法保证数据的完整性和安全性；<br>3）功能没有关系型数据库完善 |
| 示例 | MySQL，Microsoft SQL Server，Oracle，PostgreSQL 等           | Neo4j，Redis，MongoDB 等                                     |

## 为什么要使用数据库

- 数据保存在**内存**：存取速度**快**，但数据无法持续保存
- 数据保存在**文件**：数据可永久保存，但**数据查询不方便**，需要频繁的IO操作，速度比内存操作**慢**得多
- 数据保存在**数据库**
  - 优点：数据可永久保存且数据**安全性高**；使用 `SQL` 语句，**查询方便效率高**；便于**数据管理、智能化数据分析**
  - 缺点：数据库移植不方便；不支持集群；不擅长业务逻辑的处理

## `MySQL`与`SQL`的区别是什么

- `SQL` 和 `MySQL` 是 DBMS 中最令人困惑的两个术语，二者之间存在**本质**上的区别。

- `SQL` 是一种 **结构化查询语言**，用于在数据库上执行各种操作，但 `MySQL`是一个 **关系数据库管理系统（RDBMS）**，**使用`SQL`执行所有数据库操作**。
- `SQL` 用于访问，更新和操作数据库中的数据，用户使用时需要学习该语言，然后编写查询，而 `MySQL` 是一个软件，会为用户提供一个界面，只需单击一些按钮即可用于执行各种数据库操作。
  由于 `MySQL` 是一个软件，所以它会定期获得各种更新，但在 `SQL` 中，命令总是相同的。

## 数据库三大范式是什么

- 数据库**范式**是**设计数据库时，需要遵循的一些规范**。各种范式是**条件递增**的联系，**越高的范式数据库冗余越小**。常用的数据库三大范式为：

- 第一范式（1NF）：**每个列都不可以再拆分**，强调的是**列的原子性**。第一范式要求数据库中的表都是**二维表**
- 第二范式（2NF）：在第一范式的基础上，一个**表必须有一个主键**，非主键列**完全依赖**于主键，而不能是依赖于主键的一部分
- 第三范式（3NF）：在第二范式的基础上，非主键列**只依赖（直接依赖）**于主键，不依赖于其他非主键

- 解析详见，[对三大范式的理解](https://www.cnblogs.com/wsg25/p/9615100.html)

## 数据库连接泄露的含义

- **数据库连接泄露**指的是如果在某次使用或者某段程序中**没有正确地关闭** `Connection`、`Statement` 和 `ResultSet` 资源，那么每次执行都会**留下一些没有关闭的连接**，这些**连接失去了引用而不能得到重新使用**，因此就造成了数据库连接的泄漏。**数据库连接的资源是宝贵而且是有限的**，如果在某段使用频率很高的代码中出现这种泄漏，那么**数据库连接资源将被耗尽，影响系统的正常运转**。

## 什么是触发器

- 触发器（trigger）是与**表**相关的**数据库对象**，是用户定义在关系表上的一类由**事件驱动**的特殊的**存储过程**，在满足定义条件时触发，并执行触发器中定义的 **语句集合**。触发器的这种特性可以协助应用在数据库端确保 **数据库的完整性**。

- 使用场景
  - 可以通过数据库中的相关表实现 **级联更改**；
  - 实时**监控**某张表中的某个字段的更改，并需要做出相应的处理。

# 事务管理

## 什么是数据库事务？

- 数据库的**事务**（Transaction）是一种**机制**、一个**操作序列**，包含了一组数据库操作命令，其执行的结果必须使数据库从**一种一致性状态**变到**另一种一致性状态**。事务把**所有的命令**作为一个**整体**一起向系统提交或撤销操作请求，即这一组数据库命令**要么都执行，要么都不执行**，因此事务是一个不可分割的工作逻辑单元。如果任意一个操作失败，那么整组操作即为失败，会回到操作前状态或者是上一个节点。

- 因此，事务是保持**逻辑数据一致性**和**可恢复性**的重要利器。而**锁**是实现事务的关键，可以保证事务的**完整性**和**并发性**

## 有哪些事务状态？

- 事务在其整个**生命周期**中会经历不同的状态，这些状态也称为**事务状态**
  - **活跃状态**：事务的第一个状态，任何正在执行的事务都处于此状态，所做的**更改**存储在**主内存的缓冲区**中。
  - **部分提交状态**：执行上次操作后，事务进入部分提交状态。之所以是部分提交，是因为所做的更改**仍然在主内存的缓冲区**中。
  - **失效状态**：如果某个检查在活动状态下**失效**，在活动状态或部分提交状态发生一些**错误**，并且事务无法进一步执行，则事务进入失效状态。
  - **中止状态**：如果任何事务已达到失败状态，则恢复管理器将数据库**回滚到开始执行的原始状态**。
  - **提交状态**：如果所有操作成功执行，则来自**部分提交状态**的事务进入提交状态。无法从此状态回滚，它是一个新的**一致状态**

## 事务的四大特性

- 事务具有 4 个特性，即**原子性**（Atomicity）、**一致性**（Consistency）、**隔离性**（Isolation）和**持久性**（Durability），这 4 个特性通常简称为**ACID**，**关系型数据库**需要遵循 ACID 规则。

- **原子性**

- 事务是**最小的执行单位**，不可分割的（原子的）。事务的原子性确保动作**要么全部执行，要么全部不执行**。

- 以 银行转账 事务为例，如果该事务提交了，则这两个账户的数据将会更新；如果由于某种原因，事务在成功更新这两个账户之前终止了，则不会更新这两个账户的余额，并且会 撤销 对任何账户余额的修改，回到此操作前状态，即事务不能部分提交。

- **一致性**

- 当事务完成时，数据必须处于一致状态，**多个事务对同一个数据读取的结果是相同的**。

- 以银行转账事务事务为例。在事务开始之前，所有账户余额的总额处于一致状态。在事务进行的过程中，一个账户余额减少了，而另一个账户余额尚未修改。因此，所有账户余额的总额处于不一致状态。但是当事务完成以后，账户余额的总额再次恢复到一致状态。

- **隔离性**

- **并发访问数据库**时，一个用户的事务**不被其他事务所干扰**，各个事务不干涉内部的数据。

- 修改数据的事务可以在另一个使用相同数据的事务开始之前访问这些数据，或者在另一个使用相同数据的事务结束之后访问这些数据。

- **持久性**

- 一个事务被提交之后，它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

## 如何实现事务的ACID特性

- 事务的 ACID 特性是由**关系数据库管理系统**来实现的。
- DBMS 采用 **日志** 来保证事务的 **原子性**、**一致性** 和 **持久性**。日志记录了事务对数据库所做的更新，如果某个事务在执行过程中发生错误，就可以根据**日志，撤销事务对数据库已做的更新**，使数据库退回到执行事务前的初始状态。
- DBMS 采用 **锁机制** 来实现事务的**隔离性**。当多个事务同时更新数据库中相同的数据时，只允许 **持有锁的事务** 能更新该数据，其他事务必须等待，直到前一个事务释放了锁，其他事务才有机会更新该数据。

## 事务之间的相互影响

- **脏读**（Dirty Read）
- 一个事务读取了另一个事务未提交的数据。
- **不可重复读**（Non-repeatable Read）
- 就是在一个事务范围内，两次相同的查询会返回两个不同的数据，这是因为在此间隔内有其他事务对数据进行了修改。
- **幻读**（Phantom Read）
- 幻读是指当事务 **不是独立执行时** 发生的一种现象，例如有一个事务对表中的数据进行了修改，这种修改涉及到表中的全部数据行，同时，第一个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，第一个事务的用户发现表中还有没有修改的数据行，就**好像发生了幻觉一样**。
- **丢失更新**（Lost Update）
- 两个事务同时读取同一条记录，事务 A 先修改记录，事务 B 也修改记录（B 是不知道 A 修改过），当 B 提交数据后， 其修改结果**覆盖了 A 的修改结果**，导致事务 A 更新丢失。

## 什么是事务的隔离级别

- 为了尽可能的避免上述事务之间的相互影响，从而达到事务的四大特性，SQL 标准定义了 4 种不同的**事务隔离级别**（TRANSACTION ISOLATION LEVEL），即 **并发事务对同一资源的读取深度层次**，由低到高依次是 **读取未提交**（READ-UNCOMMITTED）、**读取已提交**（READ-COMMITTED）、**可重复读**（REPEATABLE-READ）、**可串行化**（SERIALIZABLE），这 4 个级别与事务相互间影响问题对应如下
- **读取未提交**
- 最低的隔离级别，一个事务可以读到另一个事务未提交的结果，**所有的并发事务问题都会发生**。
- **读取已提交**
- 只有在事务提交后，其更新结果才会被其他事务看见，可以解决 **脏读问题**，但是不可重复读或幻读仍有可能发生。Oracle 默认采用的是该隔离级别。
- **可重复读**
- 在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交，除非数据是被本身事务自己所修改。可以解决 **脏读、不可重复读**。MySQL 默认采用可重复读隔离级别。
- **可串行化**
- 事务 **串行化执行**，隔离级别最高，**完全服从 ACID**，牺牲了系统的并发性，也就是说，所有事务依次逐个执行，所以可以解决并发事务的所有问题。

## Mysql是如何解决幻读的？

- **幻读**：一个事务进行了两次相同范围的读取，后一次读取读到了前一次未读到的数据

- **幻读发生的场景**

  事务A执行`SELECT * FROM t WHERE age = 20`

  事务B执行`INSERT INTO t values(3, "Jack", 20)`

  **执行顺序**：事务A第一次查询-事务B插入并提交-事务A第二次查询

  **幻读**：事务A在第二次读取读到事务B所插入的这一项，因为事务A第一次读取时该项还不存在，无法加锁，因此事务B能够插入该项并提交

- **快照读-MVCC**：Mysql在可重复读级别下的select默认采用快照读，通过MVCC技术解决幻读
- **当前读-Next-key Locks**：特别地，如果select指定了lock in shared mode或for update，则会采用当前读，此时Mysql通过间隙锁避免幻读。假如select涉及的索引范围有x个，则它会给x个索引项上锁，并对其间产生的x+1个间隙加上间隙锁，其他事务对这些间隙进行插入操作将被阻塞直至本事务提交

# 锁

## 什么是死锁？

- 死锁是指**两个或多个事务**在**同一资源**上相互占用，并**请求锁定对方的资源**，从而导致恶性循环的现象。

## 如何解决死锁？

- 如果不同程序**并发存取多个表**，尽量约定**以相同的顺序访问表**，可以大大降低死锁机会；
- 在同一个事务中，尽可能做到 **一次锁定所需要的所有资源**，减少死锁产生概率；
- 对于非常容易产生死锁的业务部分，可以尝试使用 **升级锁定颗粒度**，通过 **表级锁** 定来减少死锁产生的概率。

### 死锁的四个必要条件

- 死锁的必要条件：**互斥**、**不可抢占**、**等待时不释放已有资源**、**等待关系成环**



# 索引

## 索引的概念、作用

- 索引是一种用于快速查询和检索数据的数据结构，常见的索引结构有B树、B+树和hash

## 索引的优缺点

### 优点

- 使用索引可以加快数据的检索速度
- 创建唯一性索引，保证数据表中每一行数据的唯一性

### 缺点

- 创建索引和维护索引需要耗费许多时间，当对表中数据进行增删改的时候，如果数据有索引，则索引需要动态修改，会降低SQL执行效率
- 索引需要使用物理文件存储，会耗费一定空间

## 索引的数据结构

### 哈希表

- **哈希冲突**：常用链地址法解决，JDK1.8后的HashMap引入了红黑树
- **哈希函数**：应该均匀地将键值对分布在各个桶中
- **缺点**
  - 哈希冲突
  - **不支持顺序和范围查询**

### B树与B+树

- B树是**多路平衡查找树**，B+树是B树的一种变体

- 对比

  **键值的存放**：B树的所有节点都存放key和data，B+树只有叶节点存放key和data，内部节点只存放key

  **叶节点结构**：B树的叶节点是独立的，B+树的叶节点包含指向下一个叶节点的指针

  **检索过程**：B树的检索过程不一定到达叶子节点，B+树的检索效率稳定，任何查找都会从根节点到叶节点

- **InnoDB引擎**的索引实现

  **数据文件也是索引结构**：数据文件本身是按B+树组织的一个索引结构，索引的 key就是表的主键

  **叶节点data**：对于数据文件本身的索引结构，叶节点保存了完整的数据记录；对于辅助索引，叶节点保存了数据记录主键的值

  **查询过程**：使用主索引搜索，找到叶节点并取出数据记录即可；使用辅助索引，第一次搜索取出该数据记录的主键，第二次搜索再取出数据记录

## 索引类型

### 主键索引

- 一张数据表只有一个主键，主键不能为null也不能重复
- **InnoDB引擎指定主键**：如果没有显式地指定主键，将自动检查表中是否有唯一索引且不允许存在null值的字段，有则选择该字段为默认主键，没有则自动创建一个自增主键

### 辅助索引

- 辅助索引的叶子节点存储的数据是主键
- **唯一索引**：唯一索引的属性列不能出现重复的数据，但是允许NULL，一张表可以创建多个唯一索引
- **普通索引**：普通索引的唯一作用是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和NULL
- **前缀索引**
- **全文索引**

### 聚集索引与非聚集索引

#### 聚集索引

- **聚集索引**：索引结构和数据一起存放的索引，主键索引属于聚集索引

- **优点**：查询速度快，定位到索引节点就相当于定位到了数据

- **缺点**

  **依赖于有序的数据**：如果索引的数据不是有序的，则需要在插入时排序，导致插入速度慢

  **更新代价大**：如果索引列的数据被修改时，则对应的索引也将被修改，且聚集索引的

#### 非聚集索引

- **非聚集索引**：索引结构和数据分开存放的索引

- **优点**：更新代价小于聚集索引，叶子节点不存放数据

- **缺点**

  **依赖于有序的数据**

  **需要二次查询**，即查询到对应记录的主键后，再次根据主键查询数据记录

### 覆盖索引

- 要查询的字段正好是索引的字段，则直接根据该索引即可查询到数据

# MySQL日志

- `MySQL`日志包含**二进制日志**（binlog）、事务日志（**重做日志**redo log、**回滚日志**undo log）

## redo log

- **redo log的作用**：使MySQL拥有崩溃恢复能力，当MySQL宕机后重启时，InnoDB引擎使用redo log恢复数据，保证数据的持久性与完整性
- **buffer pool的作用**：**MySQL以页为单位**，查询一条记录会从硬盘把一页的数据加载出来并放入buffer pool。更新数据时，先在buffer pool里查找该数据页进行更新
- **redo log buffer与刷盘**：在数据页上进行的修改会写入redo log buffer，然后刷盘到redo log文件里

### 刷盘时机

- **redo log的刷盘策略**有三种
  - 每次事务提交时不进行刷盘（只依赖后台线程刷盘）
  - 每次事务提交时都进行刷盘（将redo log buffer写入page cache，并调用fsync写入磁盘）
  - 每次事务提交时只把redo log buffer写入page cache（只将redo log buffer写入page cache）

- **负责刷盘的后台线程**

  InnoDB存储引擎有一个后台线程，每隔1秒，就把redo log buffer的内容写入文件系统缓存page cache，并调用fsync刷盘

- **到达容量一半时刷盘**

  redo log buffer空间即将到达总容量一半时，后台线程主动刷盘

### 日志文件组

- **日志文件组**：redo log日志文件不止一个，而是以日志文件组的形式出现的，每个redo日志文件大小一样
- **write pos**：当前记录的位置，一边写一边后移
- **checkpoint**：当前要擦除的位置，也是往后推移
- **空间大小**：write pos和checkpoint之间还空闲的部分，表示可用来写入新的redo  log记录的空间
- **空间已满**：write pos追上checkpoint，表示日志文件组满了，不能再写入新的redo log记录，MySQL得停下来清空记录，以推进checkpoint

## binlog

- **binlog**：记录所有涉及更新的逻辑操作，并且是顺序写

### 记录格式

- `binlog_format`**参数**，指定为三种格式中的一种

  **statement**：记录SQL语句原文

  **row**：记录SQL语句，并包含操作的具体数据

  mixed：判断SQL语句是否可能引起数据不一致，如果是则用row格式，否则用statement格式

  > 可能引起数据不一致的SQL语句，如获取当前时间的now()，必须记录该事件的具体值

### 写入机制

- **binlog cache**：事务执行时先把日志写到binlog cache，事务提交时把binlog cache写入binlog文件中

- **单个事务的binlog cache必须一次性写入**：系统为每个线程分配一个块内存作为binlog cache，如果存储内容超过了所分配内存的大小，则要暂存到磁盘

- binlog日志刷盘

  - **write调用**：将日志从binlog cache写入文件系统缓存page cache

  - **fsync调用**：将日志从page cache刷盘

- 控制write和sync的时机，三种策略

  **默认策略**：事务提交时只**write到page cache**，从page cache写入磁盘的时机由系统决定

  **每次提交都刷盘**：事务提交时不仅write到page cache，而且**fsync到磁盘中**

  **N-混合策略**：事务提交时write到page cache，计数值加1，**累积N个事务后fsync到磁盘中**

## 两阶段提交

### 概念

- **2PC**：两阶段提交协议（2PC）是为了解决**分布式系统的一致性**产生的，它为了保证事务要么在所有节点都提交，要么在所有节点都不提交

### MySQL的两阶段提交

- **两阶段**：将redo log写入拆分为prepare和commit两个步骤
- **执行顺序**：执行时写入redo log（prepare阶段），提交事务时**先写入binlog**，然后设置redo log（commit阶段）
- **binlog写入异常分析-回滚**：如果写入binlog时发生异常，则因为MySQL根据redo log恢复日志时发现其处于prepare阶段，且没有对应的binlog日志，则回滚该事务
- **redo log commit异常-redo**：如果redo log commit阶段发生异常，则由于事务的binlog日志存在，它认为redo log是完整的，因此提交事务恢复数据，不用回滚

## undo log

- **回滚日志**：所有事务进行的修改都会先记录到回滚日志中，然后再执行相关的操作
- **回滚**：如果执行过程中遇到异常，则利用回滚日志的信息将数据回滚到修改前的样子。回滚日志总是先于数据持久化到磁盘上，保证即使遇到数据库宕机等情况，再次启动数据时，仍然能通过回滚日志来回滚之前未完成的事务

# InnoDB存储引擎对MVCC的实现

## 当前读和快照读

### 快照读（非锁定读）

- **使用快照读的情况**：在可重复读、已提交读的隔离级别下，如果执行普通的select语句，则会使用快照读，并且在可重复读级别下MVCC实现了可重复读和防止部分幻读

### 当前读（锁定读）

- **使用当前读的情况**：如果执行select ... lock in shared mode，select ... for update语句，或insert、update、delete语句，则使用当前读，对读取的记录加相应的S锁或X锁

## InnoDB对MVCC的实现

- MVCC的实现依赖于：隐藏字段、Read view、undo log

### 隐藏字段

- 三个隐藏字段：InnoDB为每行数据添加了三个隐藏字段

  **DB_TRX_ID**（6字节）：表示最后一次插入或更新该行的事务id

  **DB_ROLL_PTR**（7字节）：回滚指针，指向该行的undo log，如果该行未被更新则为空

  **DB_ROW_ID**（6字节）：如果没有设置主键且该表没有唯一非空索引时，InnoDB会使用该id来生成聚集索引

### ReadView

- **可见性判断**：保存了当前对本事务不可见的其他活跃事务
- `m_ids`：活跃事务列表，ReadView创建时其他未提交的活跃事务id列表。创建ReadView时将当前未提交事务id记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的
- `max_trx_id`：目前出现的最大事务id+1，即下一个将被分配的事务id
- `min_trx_id`：活跃事务列表m_ids中最小的事务id，如果活跃事务列表为空，则min_trx_id等于max_trx_id
- `creator_trx_id`：创建该ReadView的事务id

- 规则

  - 大于等于max_trx_id的事务不可见

  - 小于min_trx_id的事务可见

  - 大于等于min_trx_id且小于max_trx_id的事务，若存在于活跃事务列表中则不可见；否则说明该事务已提交，可见

### undo log

- undo log的两个主要作用

  **事务回滚**：事务回滚时用于将数据恢复到修改前的样子

  **MVCC**：当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过undo log读取之前的版本数据，以此实现快照读

- **insert undo log**：在insert操作中产生的undo log，因为insert操作的记录只对事务本身可见，对其他事务不可见，故该undo log可以在事务提交后直接删除，不需要进行purge操作
- **update undo log**：update或delete操作中产生的undo log，该undo log可能需要提供MVCC机制，不能再事务提交时就删除，提交时仿佛undo log链表，等待purge线程进行删除操作

- **链表**：不同事务或相同事务对同一记录行的修改，会使该记录行的undo log成为一条链表，链首是最新的记录，链尾是最早的旧纪录

### 数据可见性算法

- **快照的创建**：InnoDB中，创建新事务后，执行每个select语句前，都会创建一个快照Read View，快照中保存了当前数据库系统中正处于活跃的事务的id号（即不应该被本事务看到的其他事务的id列表）
- **数据可见性算法**
  - **步骤1**：记录的DB_TRX_ID＜m_up_limit_id，表明最新修改该行的事务在本事务创建快照前已提交，因此可见
  - **步骤2**：记录的DB_TRX_ID ≥ m_low_limit_id，表明最新修改该行的事务在本事务创建快照后修改该行，不可见，跳到步骤5
  - **步骤3**：m_ids为空，表明当前事务创建快照前，修改该行的事务已提交，该行可见
  - **步骤4**：如果m_up_limit_id ≤ DB_TRX_ID ＜m_low_limit_id，则修改该行的事务可能处于活跃状态或已提交状态，通过二分查找活跃事务列表m_ids判断可见性
    - 若在活跃事务列表中找到了DB_TRX_ID，不可见，跳到步骤5
    - 若没找到，则该事务已提交，该记录行可见
  - **步骤5**：通过该记录行的DB_ROLL_PTR指针所指向的undo log取出快照记录，用快照记录的DB_TRX_ID跳到步骤1重新开始执行可见性判断，知道找到满足的快照版本，或返回空

## 可重复读和已提交读隔离级别下MVCC的差别

- **已提交读**：**每次select查询前**都生成一个Read View
- **可重复读**：**第一次select**数据前生成一个Read View

## MVCC解决不可重复读的问题

### 在已提交读下ReadView生成的情况

- **不可重复读**：每次select都创建一个Read View，所以导致不可重复读
- **原因**：事务A的两次select都会创建Read View，如果第一个Read View的活跃事务列表中的某个事务B在两次select之间进行了提交，则第二个Read View将包含事务B对数据项的更改，从而导致读取结果不一样

### 在可重复读下ReadView生成的情况

- **ReadView生成时机**：只在事务开始后**第一次读取数据**时生成ReadView，在事务的全过程中，m_ids和m_up_limit_id和m_low_limit_id**始终不变**，因此即使undo log list改变，也不影响读取结果，保证了可重复读

## MVCC + Next-key-Lock防止幻读

- **普通select**：通过MVCC快照读方式读取数据，可重复读隔离级别只在第一次查询生成Read View，并使用事务提交。在生成Read View后其他事务所做的更新、插入记录版本对当前事务不可见，实现了**可重复读**，并**在快照读下防止了幻读**

- **select ... for update/lock in share mode、insert、update、delete等当前读**

  **幻读**：当前读下，读取的是**最新的数据**，如果其他事务有插入新的记录，且刚好在当前事务查询范围内就会产生幻读

  **Next-key Lock防止幻读**：执行当前读时，锁定读取到的记录的同时，锁定它们的间隙，防止其他事务在查阅范围内插入数据，防止了幻读

