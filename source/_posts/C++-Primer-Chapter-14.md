---
title: C++ Primer Chapter 14
date: 2022-02-20 17:32:40
tags: C++
categories: C++
mathjax: true
---

**C++ Primer第14章笔记**

<!--more-->

# 第14章 重载运算与类型转换

## 14.1 基本概念

- 重载运算符时具有**特殊名字**的函数，其名字由**关键字`operator`后加运算符号**共同组成
- 重载运算符的**参数数量**跟运算符作用的运算对象数量一样
- 除了重载函数调用运算符外，其他重载运算符**不能有默认实参**
- 如果重载运算符是**成员**函数，则**第一个运算对象**隐式地绑定到`this`指针
- 重载运算符要么是**类成员**，要么**至少含有一个类类型的参数**，因此我们无法改变内置类型运算符的含义
- 只能重载已有运算符，**无法发明新的运算符号**
- 有四个符号（`+`、`-`、`*`、`&`）**既是一元运算符，也是二元运算符**，可根据参数数量推断重载运算符是那种运算符？
- 重载运算符的**优先级和结合律**与内置运算符一致

### 直接调用一个重载的运算符函数

- 通常将运算符作用于实参以间接地调用重载运算符，但也可以像普通函数一样直接调用重载运算符
- 两者是等价的

### 不能被重载的运算符

- `::`，`.*`，`.`，`?:`

### 不应被重载的运算符

- 定义了运算对象**求值顺序**，或**短路属性**的运算符，如`,`，`&&`，`||`，其特性在重载后无法保留
- 运算符作用于类类型对象的含义已定义，如`,`和`&`

### 使用与内置类型一致的含义

- 如果类执行IO操作，则重载移位运算符`>>`和`<<`
- 如果类检查相等性，则重载`==`和`!=`
- 如果类需要进行单序比较操作，则重载`<`及其他关系运算符

### 重载运算符的返回类型

- 最好与内置版本的返回类型兼容
- **逻辑**运算符和**关系**运算符返回`bool`，**算术**运算符返回**一个类类型的值**，**赋值**运算符和**复合赋值**运算符返回**左侧运算对象的引用**

### 赋值和复合赋值运算符

- 重载了算术运算符或位运算符，最好也重载相应的复合赋值运算符

### 选择成员或非成员

- **赋值**`=`、**下标**`[]`、**调用**`()`、成员访问**箭头**运算符`->`**必须是成员**
- **复合赋值**运算符一般是**成员**
- 改变对象状态的运算符，如**递增、递减、解引用**，通常是**成员**
- 具有**对称性的运算符**，如**算术**、**关系**、**相等性**、**位运算**符通常是普通的**非成员**函数
- 如果把运算符定义为成员，则其左侧运算对象必须是该类类型的对象

## 14.2 输入和输出关系运算符

### 重载输出运算符`<<`

- 输出运算符的**第一个参数**一般是**非常量`ostream`对象的引用**
- 输出运算符的**第二个参数**一般是**类类型的`const`引用**

- 输出运算符的**返回值**一般是它的**`ostream`形参**
- 输出运算符应该尽量**减少格式化操作**，如**换行符**，由类的使用者控制输出的细节

- 输入输出运算符必须是**非成员函数**，因为它们的左侧运算对象为输入输出流
- IO运算符一般被声明为**友元**，从而访问该类的`private`数据成员

### 重载输入运算符`>>`

- 输入运算符的**第一个参数**一般是**非常量`istream`对象的引用**
- 输入运算符的**第二个参数**一般是**将要读入到的对象的非常量引用**
- 输入运算符的**返回值**一般是它的`istream`形参

#### 输入运算符必须处理输入可能失败的情况

- 执行输入运算符时可能遇到的错误
  - 流含有**错误类型**的数据
  - 读取达到**文件结尾**
  - 输入流遇到其他错误
- 当输入运算符发生错误时，我们必须**将对象置为合法状态**，如将一个新的默认初始化的对象赋予该对象形参。输入运算符应该负责**从错误中恢复**

#### 标示错误

- 一些输入运算符需要做更多**数据验证**的工作

- 假如**数据验证不通过**，即使从技术上看IO是成功的，输入运算符仍应该通过**设置流的条件状态**以**标示失败信息**，即**设置`failbit`**

- 回顾，设置`failbit`的方法

  ```c++
  is.setstate(is::iostate | is::failbit);
  ```

  

## 14.3 算术和关系运算符

- 通常把算术运算符和关系运算符定义为**非成员函数**，以允许对**左侧或右侧**运算对象进行**转换**
- 这些运算符一般不需要改变运算对象的状态，所以**形参都是const引用**

### 算术运算符

- 算术运算符通常**计算两个运算对象**并得到一个**新值**，这个值常位于**局部变量**内，**返回该局部变量的副本**作为结果- 
- 定义了算术运算符的类，通常也定义定义的**复合赋值运算符**，最好的方式是**使用复合赋值来定义算术运算符**

### 相等运算符

- C++通过定义相等运算符来检验两个对象是否相等，即**比较**对象的**每一个数据成员**，只有当**所有对应成员都相等**时才认为**两个对象相等**
- 如果定义了相等运算符，则它应该能判断一组给定的对象中**是否含有重复数据**

- 通常，相等运算符应该具有**传递性**
- 定义了相等运算符`operator==`的类，通常也**应该定义不相等运算符`operator!=`**，且应该把其中一个的工作**委托**给另一个

### 关系运算符

- 关联容器和一些算法会用到**小于运算符**，因此考虑定义`operator<`
- 如果类同时含有`==`运算符，则定义一种关系应**令其与`==`保持一致**。如果两个对象是`!=`的，则一个对象应该`<`另一个

- 如果存在唯一一种逻辑可靠的`<`定义，则应该考虑为这个类定义`<`运算符
- 如果类存在`==`，**当且仅当`<`的定义与`==`产生的结果一致时**才定义`<`运算符

## 14.4 赋值运算符

- **拷贝**赋值运算符、**移动**赋值运算符
- 接受**花括号列表**作为参数的赋值运算符，**其参数是`initializer_list<T>`类型的**，这种赋值运算符无需考虑自赋值，因为其参数与`this`肯定不指向同一个对象
- 赋值运算符**必须定义为成员函数**
- 赋值运算符应**返回左侧运算对象的引用**

### 复合赋值运算符

- **复合赋值运算符**并非必须为成员函数，但**最好也将其定义为成员函数**

- 同样地，复合赋值运算符也应该**返回左侧运算对象的引用**

- 如果定义了复合赋值运算符，**算术运算符**应该通过**对应的复合赋值运算符实现**

## 14.5 下标运算符

- **表示容器的类**通常可以通过元素在容器中的**位置**访问元素，这些类一般定义下标运算符`operator[]`
- 下标运算符**必须是成员**函数
- 下标运算符**返回所访问元素的引用**，且通常包含**常量版本**和**非常量版本**，
  - **常量版本**接受常量对象的调用，**返回`const`引用**
  - **非常量版本**接受非常量对象的调用，返回**普通引用**

## 14.6 递增和递减运算符

- **迭代器类**通常实现**递增运算符**和**递减运算符**
- 递增运算符和递减运算符**通常定义为成员函数**，且应该**同时定义前置版本和后置版本**

### 定义前置版本

- `operator++()`，和`operator--()`
- 前置版本应该返回**递增**或**递减后的对象的引用**

### 定义后置版本

- 区分**前置**版本和**后置**版本：后置版本**接受一个`int`类型的形参**
- 当我们使用**后置**递增或递减运算符时，**编译器会为这个形参提供一个值为0的参数**
- 运算符实际并**不使用该`int`形参**，其定义的**唯一作用是区分前置版本和后置版本的函数**   

- 后置版本应该**返回该对象递增或递减前的值**（而不是引用）

- **显式调用**后置版本的递增/递减运算符时，**必须传入一个实参**

  ```c++
  obj.operator++(0);
  ```

  

## 14.7 成员访问运算符

- **解引用运算符**`*`通常是**成员**函数，**返回类的引用类型**
- **箭头运算符**`->`**必须**是**成员**函数

- 箭头运算符、解引用运算符通常都**定义为`const`成员**

### 箭头运算符返回值的限定

- 形如`point->mem`的表达式，`point`必须是指向类对象的**指针**，或**重载了`operator->`的类的对象**，根据`point`类型不同有不同的执行过程

- `point->mem`的执行过程如下
  - 如果`point`是**指针**，则应用内置的箭头运算符，对`point`解引用，然后从所得的对象获取指定的成员，如果`point`所指的类没有名为`mem`的成员，将发生错误
  - 如果`point`是**定义了`operator->`的类的对象**，则使用`point.operator->()`的结果来获取`mem`，如果**结果是指针**，则**执行上面描述的操作**；如果**结果本身含有重载的**`operator->()`，则**重复调用当前步骤**

- 因此，**箭头运算符**必须返回**类的指针**，或者**自定义了箭头运算符的某个类的对象**

  ```c++
  string& operator*() const {
      // 解引用, 返回类的引用类型
  }
  
  string* operator->() const {
      return &this->operator*();
      // 调用解引用运算符获得对象, 然后通过取地址运算符返回指向该对象的指针
  }
  ```

## 14.8 函数调用运算符

- C++的**五种可调用对象**：函数、函数指针、lambda表达式、重载了调用运算符的类的对象、bind返回的对象
- 如果类重载了函数调用运算符，则可以像使用函数一样使用该类的对象，该类的对象称作**函数对象**
- 函数调用运算符**必须是成员函数**，一个类可以定义多个**不同版本的调用运算符**，其参数数量或类型必须有所区别

### lambda是函数对象

- 当我们编写了**lambda表达式**后，编译器将该表达式翻译为**一个未命名类的未命名对象**

- lambda表达式产生的类含有一个**重载的函数调用运算符**

#### 没有捕获变量的lambda对应的类

```c++
auto f = [](const string& a, const string& b) { return a.size() < b.size(); };
// 其行为类似下面这个类的未命名对象
class A {
    public:
    	bool operator()(const string &s1, const string& s2) const {
            return s1.size() < s2.size();
        }
};
```

- 该类只有一个函数调用运算符成员，默认情况下**lambda不能改变它捕获的变量**，因此函数调用运算符是一个**`const`成员函数**

- 如果lambda被声明为**可变的**（在参数列表后加上`mutable`关键字），则函数调用运算符不是`const`的

#### 表示lambda及相应捕获行为的类

- 若一个lambda通过**引用捕获**变量，则编译器可**直接使用**该引用而**无需**在lambda将其**存储为数据成员**

- 若lambda通过**值捕获**变量，则变量将被**拷贝**到lambda中，产生的类必须**为每个值捕获的变量建立对应的数据成员**，同时创建**构造函数**，**使用捕获的变量的值初始化对应的数据成员**

  ```c++
  [sz](const string& a) { return a.size() >= sz; }
  // 其行为类似于下面这个类的未命名对象
  class A {
      A(size_t n): sz(n) {}
      public:
      	bool operator()(const string& a) {
              return a.size() >= sz;
          }
     	private:
      	size_t sz;
  }
  ```

- lambda表达式产生的类**不含默认构造函数、赋值运算符、默认析构函数**。是否含有默认的拷贝/移动构造函数则通常要视捕获的数据成员类型而定

### 标准库定义的函数对象

- 略

### 可调用对象与function

- C++的**可调用对象**：**函数、函数指针、bind创建的对象、lambda表达式、重载了函数调用运算符的类**
- **可调用对象也有类型**，**每个lambda**有它自己**唯一的类类型**，函数及函数指针类型则由其返回类型和实参类型决定
- 两个不同类型的可调用对象却可能共享同一种**调用形式**。调用形式指明了调用的**返回类型**和传递给调用的**实参类型**，**一种调用形式对应一种函数类型**

#### 不同类型可能具有相同的调用形式

- 以下三种可调用对象的**调用形式**都是`int(int, int)`

```c++
int add(int i, int j) { return i + j; }
auto mod = [](int i, int j) { return i % j; };
class divide {
    public:
    	int operator()(int i, int j) { return i / j; };
};
```

- **函数表**，存储**指向可调用对象的指针**，当需要执行某种特定操作时，从表中查找该调用的函数

```c++
map<string, int(*)(int, int)> binops;
binops["+"] = add;
// 但是我们却不能用同样方式添加mod和divide, 因为它们类型并非int(*)(int, int)
```

#### 标准库function类型

- `function`是一个模板，创建具体的`function`类型时必须提供`function`类型能够表示的对象的**调用形式**，如

  ```c++
  function<int(int, int)> f;
  ```

- 此`function`类型可以表示接受两个`int`，返回一个`int`的可调用对象，我们可以把所有**具有该调用形式**的可调用对象（**包括函数指针、lambda或函数对象**）传递给`f`

  ```c++
  function<int(int, int)> f(obj);		// 在f中存储可调用对象obj的副本
  ```

- 我们**不能直接把重载函数的名字**放入`function`类型的对象中，因为这会导致**二义性问题**，解决方法是**放入函数指针**或**lambda**

## 14.9 重载、类型转换与运算符

- 通过定义**类型转换运算符**，可以显式地定义对于类类型的类型转换，也称为**用户定义的类型转换**
- **类型转换运算符**，与**转换构造函数**（隐式的类类型转换）共同定义了**类类型转换**

### 14.9.1 类型转换运算符

- **类型转换运算符**是类的一种特殊成员函数，负责**将一个类类型的值转换成其他类型**

- 一般形式如下，`type`表示某种类型，类型转换运算符可以面向**除了函数类型、数组类型、void**以外的任意类型定义

  ```c++
  operator type() const;
  ```

- 类型转换运算符的特点

  - **必须是成员函数**
  - 不能声明**返回类型**
  - **形参列表**必须为**空**
  - 通常应该是`const`的

#### 定义含有类型转换运算符的类

```c++
class SmallInt {
    public:
    	SmallInt(int i = 0): val(i) {
            if (i < 0 || i > 255) 
                throw out_of_range("Bad SmallInt val");
        }
    	operator int() { return val; }
    private:
    	size_t val;
};
```

- 编译器一次只能执行一个用户定义的类型转换，但隐式的**用户定义类型转换**可置于**内置类型转换之前**或**之后**并一起使用

  ```c++
  SmallInt si = 3.14;	// 内置类型转换将double转换成int, 再调用转换构造函数
  si + 3.14;			// SmallInt类型转换运算符将si转为int, 再由内置类型转换继续转换为double
  ```

- 类型转换运算符**不能声明返回类型**，但**实际上会返回对应类型的值**

#### 类型转换运算符可能产生意外结果

- 实践中，类**很少定义**类型转换运算符。一种例外是，**定义向`bool`的转换较为普遍**

- 类型转换运算符可能产生意外结果，特别是`bool`类型能够参与算术运算的特点。示例如下，假如`istream`含有向`bool`的类型转换

  ```c++
  int i = 42;
  cin << i;
  ```

  - `istream`没有定义`<<`，但该代码使用`istream`的`bool`类型转换符将`cin`转换为`bool`，而`bool`会被提升为`int`并进行左移运算，从而导致意外结果

#### 显式的类型转换运算符

- 为了阻止上述意外结果发生，新标准引入**显式的类型转换运算符**
- 显式的类型转换运算符**指定**`explicit`，则编译器**不会将一个显式的类型转换运算符用于隐式类型转换**
- 为了进行类型转换，我们必须通过**显式的强制类型转换**`static_cast`
- 一个例外是，若表达式**被用作条件**，则编译器将显式的类型转换**自动应用于它**
  - `if`、`while`、`do`语句的条件部分
  - `for`语句头的条件表达式
  - 逻辑与或非运算符的运算对象
  - 条件运算符的`?:`的条件表达式

- 向`bool`的类型转换一般被用作条件，因此**`operator bool`一般被定义成`explicit`**。这样，将表达式用作条件无需显式转换，而且其他情况下也不会发生向`bool`类型的隐式转换

### 14.9.2 避免有二义性的类型转换

- 如果类包含一个或多个类型转换，必须**保证类类型和目标类型之间只存在唯一的转换方式**，否则代码可能具有**二义性**
  - 两个类提供了相同的类型转换
  - 类定义了多个转换规则，而这些转换涉及的类型本身又可以通过其他类型转换联系在一起（如算术类型）
- 准则
  - 不要定义**相同的类型转换**
  - 不要在类中定义两个或两个以上**转换源或转换目标是算术类型**的转换

### 14.9.3 函数匹配与重载运算符

- 如果我们对同一个类既提供了转换目标是**算术类型的类型转换**，又提供了**重载的运算符**，则会遇到**重载运算符与内置运算符的二义性问题**

  ```c++
  class SmallInt {
      friend SmallInt operator+(const SmallInt&, const SmallInt&);
      public:
      	SmallInt(int i = 0): val(i) {}
      	operator int() const { return val; }
      private:
      	size_t val;
  };
  
  SmallInt s1, s2;
  SmallInt s3 = s1 + s2;		// 调用重载的opreator+
  int i = s3 + 0;		// 二义性错误
  ```

  - 上述例子中最后一个语句会导致二义性错误，可以把0转换为`SmallInt`然后调用重载运算符，也可以把`s3`转换为`int`并调用内置运算符

