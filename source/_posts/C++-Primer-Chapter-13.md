---
title: C++ Primer Chapter 13
date: 2022-02-19 14:34:11
tags: C++
categories: C++
mathjax: true
---

**C++ Primer 13章笔记**

<!--more-->

# 第13章 拷贝控制

- 构造函数控制在创建此类型对象时做什么
- 类似地，我们可以控制该类型对象**拷贝、赋值、移动或销毁**时做什么，这是通过**拷贝构造函数、移动构造函数、拷贝赋值运算符、移动赋值运算符、析构函数**实现的

- 以上五种特殊成员函数，其中
  - **拷贝和移动构造函数**定义当用同类型的另一个对象**初始化**本对象时做什么
  - **拷贝和移动赋值运算符**定义了当将一个对象**赋予**同类型的另一个对象时做什么
  - **析构函数**定义了当此类型对象**销毁**时做什么

- 如果一个类没有定义以上拷贝控制成员，编译器会自动为它定义缺失的操作，但有时候我们必须自定义

## 13.1 拷贝、赋值与销毁

### 拷贝构造函数

- 如果一个构造函数的**第一个参数是自身类类型的引用**，且任何额外参数都有默认值，则它是拷贝构造函数
- 第一个参数**必须是一个引用类型**，且几乎总是一个**const引用**
- 拷贝构造函数通常**不应该是`explicit`的**

#### 合成拷贝构造函数

- 如果我们没有定义拷贝构造函数，编译器会为我们定义一个，称为**合成拷贝构造函数**
- 一般情况，合成拷贝构造函数会**依次将每个非`static`成员拷贝到正在创建的对象中**

- 成员类型决定了如何拷贝
  - **内置类型**直接拷贝
  - **类类型**则使用该类的拷贝构造函数进行拷贝
  - 特别地，对于**数组类型**将**逐个元素地进行拷贝**

#### 拷贝初始化

- 直接初始化与拷贝初始化的区别
  - 使用**直接初始化**时，实际上要求编译器使用普通的**函数匹配**来选择与我们提供的参数最匹配的**构造函数**
  - 使用**拷贝初始化**时，是依靠**拷贝构造函数**或**移动构造函数**完成的

- 拷贝初始化在何时发生
  - 使用`=`**定义变量**
  - 将对象作为实参传给**非引用类型的形参**
  - 从**返回类型为非引用类型**的函数中返回一个对象
  - 用**花括号列表初始化**数组元素或聚合类中的成员
  - 某些类类型会对它们所分配的对象使用拷贝初始化，如**初始化标准库容器，或调用`insert`或`push`成员时**（使用`emplace`则为直接初始化）

#### 参数和返回值

- 将对象作为实参传给**非引用类型的形参**，从**返回类型为非引用类型**的函数中返回一个对象时，会进行拷贝初始化
- 这解释了**为什么拷贝构造函数必须接受引用类型**。如果并非引用类型，则为了调用构造拷贝函数，我们必须拷贝实参，而为了拷贝实参又必须调用构造拷贝函数，形成无限循环

#### 编译器可以绕过拷贝构造函数

- 编译器**可能跳过拷贝/移动构造函数**，采用**直接初始化**的形式创建对象

  ```c++
  string book = "111";
  string book("111");		
  // 编译器可能略过拷贝构造函数, 采用直接初始化, 即上式被改写为下式
  ```

  

### 拷贝赋值运算符

- 控制对象如何**赋值**
- 若类未定义拷贝赋值运算符，编译器会合成一个

#### 重载赋值运算符

- **重载运算符**本质上是**函数**，也有返回类型和形参列表
- 重载运算符的**名字**是`operator`关键字后接要定义的运算符符号，如重载赋值运算符的名字为`operator=`
- 重载运算符的**参数**表示运算符的**运算对象**，赋值运算符必须定义为成员函数，其**左侧运算对象**隐式地绑定在隐式的`this`参数中，**右侧运算对象**作为显式参数传递
- 重载赋值运算符一般**返回指向左侧运算对象的引用**

#### 合成拷贝赋值运算符

- 若类未定义自己的拷贝赋值运算符，编译器会生成一个**合成的拷贝赋值运算符**
- 一般地，它会将右侧运算对象的每个**非`static`成员**赋予左侧运算对象的对应成员
  - 对于**内置类型**直接赋值
  - 对于**类类型**调用该类的拷贝赋值运算符进行赋值
  - 对于**数组类型**，将**逐个元素地进行赋值**
- 类似重载赋值运算符，合成拷贝赋值运算符也**返回指向左侧运算对象的引用**

### 析构函数

- 析构函数**释放**对象使用的资源，并**销毁**对象的非`static`数据成员

- 析构函数的**名字**由`~`接类名构成，不接受**参数**，没有**返回值**

- 一个类只有**唯一**一个析构函数

#### 析构函数完成什么工作

- 析构函数由一个**函数体**和一个**析构部分**，析构函数首先执行函数体，然后执行析构部分
- 析构部分是**隐式**的，它会按成员初始化顺序的**逆序销毁成员**，成员销毁完全依赖于成员类型
  - 销毁**类类型**的成员将执行成员自己的析构函数
  - 销毁**内置类型**不需要操作

- 特别地，**隐式销毁一个内置指针类型，不会`delete`它所指向的对象**

- **智能指针**是类类型，具有析构函数，对于`unique_ptr`销毁时会**销毁所指对象**，对于`shared_ptr`销毁时若引用计数为0也会销毁所指对象

#### 什么时候调用析构函数？

- 只要**对象销毁**，就会执行析构函数，包括
  - 变量在**离开其作用域**时被销毁
  - 一个对象被销毁时，其**成员被销毁**
  - **容器**（标注库容器或数组）被销毁时，其元素被销毁
  - **动态分配的对象**，指向它的指针被`delete`时
  - **l临时对象**在创建它的完整表达式结束时
- 当一个对象的**引用或指针**离开其作用域时，析构函数不会执行

#### 合成析构函数

- 类未定义自己的析构函数，则编译器会为它定义一个**合成析构函数**
- 一般地，**合成析构函数的函数体为空**（其数据成员在析构部分被销毁）

### 三/五法则

- 对于类的**五个拷贝控制成员**，通常被看作一个**整体**，只需要其中一个操作而不需要定义所有操作的情况很罕见，即“要么都不用定义，要么都要定义”

#### 需要析构函数的类也需要拷贝和赋值操作

- 首先确定类是否需要自定义析构函数，**如果需要析构函数，那么这个类几乎肯定也需要一个拷贝构造函数和一个拷贝赋值运算符**

#### 需要拷贝操作的类也需要赋值操作，反之亦然

- 某些类只需要拷贝或赋值操作，不需要析构函数

### 使用`=default`

- 可以通过将**拷贝控制成员**定义为`=default`来**显式**地要求编译器**生成合成的版本**

- 只能对具有合成版本的成员函数使用`=default`，包括**默认构造函数**，和五个**拷贝控制成员**

### 阻止拷贝

- 对某些类来说，拷贝或赋值操作是无意义的，需要采取某种机制阻止拷贝或赋值，如`iostream`类阻止了拷贝

#### 定义删除的函数

- 将拷贝构造函数和拷贝赋值运算符定义为**删除的函数（deleted function）**
- deleted function指**声明了**，**但不能以任何方式调用**它们的函数，通过在**形参列表后加上`=delete`**指明
- `=default`与`=delete`的区别
  - `=delete`必须出现在函数第一次声明的时候
  - 可以对任何函数指定`=delete`

#### 析构函数不能是删除的成员

- **不能删除析构函数**
- 如果析构函数被删除，则**不允许定义该类型的变量**或**创建该类的临时对象**
- 如果一个类的**某个成员的类型删除了析构函数**，也不能定义该类的变量或临时对象
- 特别地，我们**可以动态分配这种类型的对象**，但无法销毁对象，不能`delete`指向该对象的指针，因为没有析构函数，

#### 合成的拷贝控制成员可能是删除的

- 如果类的**某个成员**的**析构函数**是**删除的或不可访问**的，则它的**合成析构函数、默认构造函数、合成拷贝构造函数**是删除的

  > 这样的目的是为了**防止创建无法销毁的对象**

- 如果类的某个成员的**合成拷贝构造函数**是删除的或不可访问的，则类的**合成拷贝构造函数**是删除的

  > 无法拷贝该成员

- 如果类的某个成员的**合成拷贝赋值运算符**是删除的，或类有一个**const成员**，或一个**引用成员**，则类的合成拷贝赋值运算符是删除的

  > 我们不能对const成员赋值；我们虽然可以对引用成员赋值，但是这种行为使得两个类的引用成员指向同一个对象，大多数情况下这种行为并非所期望的

- 如果类有一个**引用成员且没有类内初始化器**，或类有一个**const成员且没有类内初始化器**且其**类型未显式定义默认构造函数**，则类的**默认构造函数**是删除的

  > 因为我们必须初始化const成员，引用成员

- 总之，如果一个类有数据成员**不能默认构造、拷贝、复制、销毁**，则**对应的成员函数被定义为删除的**

#### `private`拷贝控制

- 被删除的函数是新标准添加的，此前使用将拷贝构造函数和拷贝赋值运算符**声明为`private`的方式来阻止拷贝**
- 特别地，友元和成员函数仍可以拷贝对象，为此，我们将拷贝成员**声明为`private`的**，同时**不定义它们**
- 试图**访问一个未定义的成员**将导致**链接时错误**

- 因此，试图拷贝对象的**用户代码**将导致**编译错误**，试图拷贝对象的**成员函数或友元**将导致**链接时错误**，从而阻止了拷贝

## 13.2 拷贝控制和资源管理

- 通常， **管理类外资源的类**必须定义拷贝控制成员。因为需要析构函数来释放对象所分配的资源，而需要析构函数的类也需要拷贝构造函数和拷贝赋值运算符
- **拷贝语义**：我们可以定义拷贝操作，使类的行为看起来**像一个值**，或**像一个指针**

### 行为像值的类

- 类的行为像一个值，意味着它有自己的状态，当我们拷贝对象时，**副本和原对象时完全独立的**

#### 类值拷贝赋值运算符

- 编写赋值运算符时，必须保证
  - 如果将一个**对象赋予它自身**，赋值运算符必须能正确工作
  - 大多数赋值运算符**组合了析构函数和拷贝构造函数**的工作
- 编写赋值运算符时，好的方式是**先将右侧运算对象拷贝到局部对象**中，然后**销毁左侧运算对象的现有成员**，最后**将数据从局部对象拷贝到左侧运算对象中**

- 下面赋值运算符存在什么问题？

  ```c++
  HasPtr& operator=(const HasPtr &rhs) {
      delete ps;
      ps = new string(*(rhs.ps));
      i = rhs.i;
      return *this;
  }
  ```

  假如`rhs`和`*this`指向同一个对象，则执行`delete ps`后`rhs.ps`是一个**空悬指针**，对其解引用的**行为和结果是未定义的**

### 行为像指针的类

- 类的行为像指针，则它们**共享状态**，副本和原对象使用相同的底层数据，改变副本也会改变原对象

#### 引用计数

- **构造函数**创建一个引用计数，初始化为1
- **拷贝构造函数**共享计数器，递增该计数器
- **析构函数**递减计数器，若计数值为0则销毁状态
- **赋值运算符**递减左侧运算对象的计数器，若计数值为0则销毁状态，然后递增右侧运算对象的计数器，并拷贝成员
- 我们不能将计数器作为对象的成员，解决方法是**将计数器保存在动态内存中**

## 13.3 交换操作

- 重排元素顺序的算法要交换两个元素时，会调用`swap`，如果类**定义了自己的**`swap`则算法将使用类自定义的版本，否则使用**标准库定义的**`swap`
- **管理资源的类**通常自定义一个名为`swap`的函数，**避免不必要的拷贝**，这可能是一种很重要的优化手段

### `swap`函数应该调用`swap`，而不是`std::swap`

- 调用`swap`时，如果交换的对象的类型存在特定的`swap`版本，则调用**该类型自定义的**`swap`

- 如果该类型**没有自定义**`swap`才调用**标准库的**`std::swap`

  ```c++
  using std::swap;
  swap(lhs.ps, rhs.ps);
  swap(lhs.i, rhs.i);
  ```


### 在赋值运算符中使用`swap`

- 定义`swap`的类常用`swap`定义其赋值运算符，这种赋值运算符运用了**copy and swap技术**，将**左侧运算对象**与**右侧运算对象的一个副本**进行交换

  ```c++
  HasPtr& operator=(HasPtr rhs) {
      swap(*this, rhs);
      return *this;
  }
  ```

- 右侧运算对象**以传值方式**传递给赋值运算符（之前的版本使用传引用方式），因此`rhs`是**右侧运算对象的一个副本**

- 使用**copy and swap**的赋值运算符自动就是**异常安全**的，且能够**正确处理自赋值**

## 13.4 拷贝控制示例

- 略

## 13.5 动态内存管理类

- 某些类需要在运行时分配可变大小的内存空间，这种类通常可以（如果可以，一般应该）使用**标准库容器**来保存它们的数据
- 某些**类需要自己进行内存分配**，必须定义自己的拷贝控制成员来管理所分配的内存

### 实现`StrVec`类

## 13.6 对象移动

- 在某些情况下，对象拷贝后就立即被销毁了，此时**移动而非拷贝**对象会**大幅度提升性能**
- 例子
  - 如`StrVec`类重新分配内存的过程中，更好的方式是移动元素，而非元素从旧内存拷贝到新内存
  - `IO`类或`unique_ptr`类的对象不能拷贝但可以移动

### 右值引用

- 新标准引入了新的引用类型“**右值引用**”，它必须绑定到**右值**
- 右值引用的重要性质是，**只能绑定到一个将要销毁的对象上**
- 普通引用称为左值引用，它不能被绑定到**要求转换的表达式**、**字面值常量**、或**返回右值的表达式**
- 返回**左值**的表达式，只有**左值引用**可以绑定到返回左值的表达式
  - 返回左值引用的函数
  - **赋值**运算符
  - **下标**运算符
  - **解引用**运算符
  - **前置递增/递减**运算符
- 返回**右值**的表达式，只有**const左值引用**、**右值引用**可以绑定到返回右值的表达式
  - 返回非引用类型的函数
  - **算术**运算符
  - **关系**运算符
  - **位**运算符
  - **后置递增/递减**运算符

#### 左值持久，右值短暂

- **左值**有**持久的状态**
- **右值**要么是**字面值常量**，要么是在表达式求值过程中创建的**临时对象**
- 右值引用只能绑定到临时对象，所以
  - 该引用的**对象将要被销毁**
  - 该对象**没有其他用户**
  - 因此，右值引用可以**自由地接管所引用的对象的资源**

#### 变量是左值

- **变量是左值**，不能将一个右值引用绑定到变量上

- 变量可能是右值引用类型，即使如此，我们也不能将右值引用绑定到该变量上

#### 标准库`move`函数

- `std::move`可以**获得绑定到左值上的右值引用类型**

- `move`定义在头文件`utility`中

- 调用`move`意味着，我们可以**销毁**移后源对象，也可以**赋予它新值**，但**不能使用它的值**

  ```c++
  int i = 10;
  int &&p = std::move(i);
  // 除了对i赋值或销毁它外, 我们不应再使用它
  ```

- 我们应该直接调用`std::move`，而不是`move`（这与`swap`不同，交换时我们优先调用类类型自定义的版本，若没有再调用标准库中的`std::swap`）

#### 总结

- 解释右值引用和左值引用的区别？
  - 可以绑定的对象不同（举例说明左值表达式、右值表达式）
  - 左值持久，右值短暂（我们可以自由地接管右值引用所指对象的资源）

### 移动构造函数和移动赋值运算符

- **移动构造函数**的**第一个参数**是该类型的**右值引用**，其他参数必须有默认实参（**拷贝构造函数**的**第一个参数**是该类型的**左值引用**，其他参数必须有默认实参）
- 移动构造函数必须确保**移后源对象**满足，**销毁它是无害的**，即移后源对象**不再指向被移动的资源**

#### 移动操作、标准库容器和异常

- **不抛出异常的**移动构造函数、移动赋值运算符必须标**记为`noexcept`**
- 在移动构造函数中指明`noexcept`，应该在**形参列表后、冒号之前**添加`noexcept`
- 除非标准库知道移动构造函数不会抛出异常，否则它会做一些**额外的操作**

##### 为什么需要指明`noexcept`

- 移动操作通常不抛出异常，但抛出异常也是允许的
- **标准库容器能对异常发生时其自身的行为提供保障**，如`vector`保证调用`push_back`时发生异常，`vector`自身不会发生改变
- 具体来说，除非`vector`知道元素类型的移动构造函数不会抛出异常，否则在**重新分配内存**的过程中，它就必须**使用拷贝构造函数而非移动构造函数**

#### 移动赋值运算符

- **移动赋值运算符**如果不抛出异常必须标记为`noexcept`
- 必须正确处理**自赋值**
- 移动赋值运算符的名字为`operator=`，参数是**右值引用**类型
- 移动赋值运算符所做的操作
  - **释放左侧**运算对象所使用的**内存**
  - **接管**给定对象的**内存**
  - 将`rhs`的**指针置为**`nullptr`
  - 必须检查两个运算对象是否相同

#### 移后源对象必须可析构

- 移后源对象必须进入**可析构**的状态，因此其指针不应再指向资源
- 移后源对象必须保持**有效**，指可以安全地为其赋予新值
- 但是，移后源对象留下的值没有任何要求，因此程序不能依赖于移后源对象中的数据
- 总之，移后源对象必须保持**有效的、可析构的**状态，但用户**不能对其值进行任何假设**

#### 合成的移动操作

- 只有当一个类**没有定义任何自己版本的拷贝控制成员**，且**所有**非`static`数据成员都能**移动构造或移动赋值**时（内置类型，或有移动操作的类类型），编译器**才**会为它**合成移动构造函数或移动赋值运算符**
- 如果一个类**没有移动操作**，通过正常的函数匹配，类会**使用对应的拷贝操作代替移动操作**
- 什么时候将**合成的移动操作**定义为**删除的**？
  - 有**类成员定义了自己的拷贝构造函数**但**未定义移动构造函数**，或类成员**未定义自己的拷贝构造函数**且**编译器不能为其合成移动构造函数**，则类的移动构造函数被定义为删除的
  - 有**类成员**的**移动构造函数或移动赋值运算符**被定义**为删除的或是不可访问的**，则类的移动构造函数或移动赋值运算符被定义为删除的
  - 类的**析构函数**被定义为**删除的或不可访问的**，则类的**移动构造函数定义为删除的**
  - 如果类成员是**const的或是引用类型，**则类的**移动赋值运算符定义为删除的**
- 如果类**定义了一个移动构造函数或一个移动赋值运算符**，则类的**合成拷贝构造函数和拷贝赋值运算符被定义为删除的**

#### 移动右值、拷贝左值

- 如果一个类**既有移动构造函数**，**也有拷贝构造函数**，则编译器根据**普通的函数匹配规则**确定使用哪个构造函数
- 若**赋值时右侧运算对象**是一个**右值**，则两个赋值运算符都是可行的，调用**拷贝赋值运算符**需要进行一次**到`const`的转换**，而调用**移动赋值运算符**则是**精确匹配**

#### 如果没有移动构造函数，右值也被拷贝

- 如果类**定义了拷贝构造函数**，但**未定义移动构造函数**，则**不会合成移动构造函数**
- 此时函数匹配规则保证该类型的对象会被**拷贝**，即使我们试图调用`move`来移动它们也是如此
- 用**拷贝**构造函数**代替移动**构造函数几乎**肯定是安全的**

#### 拷贝并交换赋值运算符和移动操作

- 如果类定义了一个**拷贝并交换赋值运算符**，且定义了**移动构造函数，**那么实际上会**获得一个移动赋值运算符**

- 代码示例

  ```c++
  // 移动构造函数
  HasPtr(HasPtr&& obj) noexcept: ps(obj.ps), i(obj.i) {
      obj.ps = nullptr;
  }
  
  // 拷贝赋值运算符(copy and swap)
  HasPtr& operator= (HasPtr rhs) {
      swap(*this, rhs);
      return *this;
  }
  ```

  - `HasPtr`类定义了copy and swap版本的拷贝赋值运算符，移动构造函数
  - 由于赋值运算符接受非引用类型，因此会执行**拷贝初始化**，拷贝初始化将根据**实参类型**调用**拷贝构造函数或移动构造函数**，**左值拷贝、右值移动**
  - 因此，单一的赋值运算符**同时实现**了**拷贝赋值运算符**和**移动赋值运算符**

  ```c++
  // hp, hp2都是HasPtr对象
  hp = hp2;
  hp = std::move(hp2);
  ```

  - 第一行的赋值语句中, `hp2`是**左值**，调用**拷贝构造函数**
  - 第二行的赋值语句中，`std::move(hp2)`是**右值**，调用**移动构造函数**

#### 三/五法则

- 所有**五个拷贝控制成员应该看作一个整体**，如果定义了其中的任意一个，则应该定义所有五个操作

#### 移动迭代器

- 移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器

- 一般迭代器解引用运算符返回指向元素的左值引用，而移动迭代器返回指向元素的右值引用

- 通过标准库的`make_move_iterator`将一个普通迭代器转换为一个移动迭代器，它接受一个普通迭代器，返回一个移动迭代器

- 将移动迭代器应用于`uinitialized_copy`

  - `unitialized_copy`对输入序列中的每个元素调用`construct`来将元素**“拷贝”**到目的位置，**移动迭代器**解引用将得到**右值引用**类型，因此`construct`会使用**移动构造函数**去构造元素

  ```c++
  // StrVec
  void reallocate() {
      auto new_capacity = size()? 2 * size(): 1;
      auto first = alloc.allocate(new_capacity);
      auto last = uninitialized_copy(make_move_iterator(begin()), make_move_iterator(end()), first);
      free();
      elements = first;
      first_free = last;
      cap = elements + new_capacity;
  }
  ```

#### 不要随意使用移动操作

- 当我们调用`move`时，必须确认移后源对象没有其他用户
- 在移动构造函数或移动赋值运算符实现代码外的地方，只有确保需要进行移动操作且移动操作是安全的时候，才使用`std::move`

### 右值引用和成员函数

- 如果一个**成员函数**同时提供了**拷贝和移动版本**，也是有益的。其中一个版本接受一个**指向`const`的左值引用**，另一个版本接受一个**非`const`的右值引用**
- 一般来说，我们**不需要**未函数操作**定义接受`const T&&`或`T&`的版本**，因为如果希望移动则应该传入右值引用，如果希望拷贝则应该传入`const T&`

#### 限制`this`指向的对象必须是左值

- 我们在对象上调用成员函数时，不管该对象是左值还是右值

  ```c++
  string s1 = "hello", s2 = "world";
  s1 + s2 = "wow";
  // s1 + s2表达式的结果是右值, 我们可以对其进行赋值
  ```

- 这是为了**向后兼容性**，但我们可以在类定义中**阻止这种用法**，即**强制`this`必须指向左值**，这是通过在参数列表后放置一个**引用限定符**实现的

- **引用限定符**可以是`&`或`&&`，分别指出`this`**必须指向左值**，或**必须指向右值**

- 如果一个成员函数同时用`const`和引用限定，则**引用限定符必须跟在`const`限定符之后**

#### 重载和引用函数

- 引用限定符也可以区分重载版本
- **如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符**

## 习题

- 什么类型的引用可以绑定到下面的初始化器上

  ```c++
  int f();
  vector<int> vi(100);
  int? r1 = f();				// 右值
  int? r2 = vi[0];			// 左值
  int? r3 = r1;				// 左值
  int? r4 = vi[0] * f();		// 右值
  ```

- 已知`Foo`类包含如下`sorted`函数

  ```c++
  Foo Foo::sorted() && {
      sorted(data.begin(), data.end());
      return *this;
  }
  ```

  - 如果`sorted`定义如下，会发生什么

  ```c++
  Foo Foo::sorted() const & {
      Foo ret(*this);
      return ret.sorted();
  }
  // ret是左值, 循环调用
  ```

  - 如果`sorted`定义如下，会发生什么

  ```c++
  Foo Foo::sorted() const & {
      return Foo(*this).sorted();
  }
  // 正确, Foo(*this)临时对象是右值, 将调用Foo类sorted的右值版本
  ```

  
