---
title: C++ Primer 关键问题集
date: 2022-02-13 21:39:36
tags:
    - C++
    - 面试
categories: C++
mathjax: true
---

**C++ Primer各章节关键问题总结**

<!--more-->

# 第6章 函数

## 函数基础

- 函数调用表达式的类型是什么？
- 函数的返回类型有什么要求？
- 函数的局部变量初始化是怎样的？
- 局部静态对象是什么？其初始化是怎样的？其生命周期如何？



## 函数传递

- 函数的两种参数传递方式是什么？区别是什么？
- 如何选择函数参数传递的方式？
- 顶层const和底层const在形参中是怎样的？
- 形参应尽量使用常量引用，为什么？若在应该使用常量引用的地方，使用了普通引用，会造成什么影响？
- 数组如何作为形参？



## 返回类型和return语句

- 返回局部对象的引用或指针会导致什么后果？
- 函数返回值是左值还是右值？
- 数组类型无法作为函数的返回类型，若返回值像包含数组的信息该怎么办？
- 如何定义返回数组指针的函数？有几种方式？



## 函数重载

- 什么是函数重载？

- 如何区分两个函数声明是等价的，还是重载函数？
- const_cast在重载函数中是怎样运用的？
- 调用重载函数时，会进行函数匹配，函数匹配的结果有多少种可能？



## 特殊用途语言特性

- 什么是默认实参？
- 如何对默认实参的函数进行声明？

- 什么是内联函数？
- 什么是constexpr函数？
- assert是什么？它有何作用？
- NDEBUG是什么？它有何作用？



## 函数匹配

- 什么是候选函数？
- 什么是可行函数？
- 什么是最佳匹配？
- 函数调用时，实参类型转换有多少种等级？
- 函数匹配在底层const形参中有何特别之处？



## 函数指针

- 什么是函数类型？
- 什么是函数指针？
- 函数指针类型作为形参是怎样的？
- 返回函数指针类型的函数是怎样定义的？有多少种方式？



## 习题

- 说明形参、局部变量、局部静态变量的区别

- 指出下列函数中可能存在的问题

  ```c++
  void print(const int a[10]) {
  	for (size_t i = 0; i < 10; ++i)
          cout << a[i] << endl;
  }
  ```




# 第7章 类

## 定义抽象数据类型

### 成员函数

- 什么是成员函数？其声明和定义有何特点？
- 什么是`this`，有何特点？
- 什么是const成员函数？
- 在类内定义的成员函数，和在类外定义的成员函数有何区别？

- 什么时候需要返回`this`对象？应该如何返回？

### 构造函数

- 什么是构造函数？作用是什么？
- 构造函数有哪些特点？
- 什么是合成的默认构造函数，其初始化是怎样的？
- 为什么说不能依赖于合成的默认构造函数？
- 什么是`=default`？其使用有何需要注意的地方？
- 什么是构造函数初始值列表？使用有何需要注意的地方？

### 拷贝、赋值、析构

- 类需要控制拷贝、赋值、析构时发生的行为
- 若不主动定义拷贝、赋值、析构时的行为，会怎样？

## 访问控制与封装

### 封装

- 什么是封装？封装有何优点？

### 访问说明符

- C++有哪些访问说明符？有何作用？
- class和struct都可以定义类，有何区别？

### 友元

- 什么是友元？什么可以声明为友元？
- 友元声明与函数声明有何区别？

## 类和其他特性

### 类成员

- 类型成员有何特殊之处？
- 如何把成员函数定义为内联函数？
- 什么是可变数据成员？有何特殊之处？
- mutable关键字有什么作用？
- 提供类内初始值有哪两种方式？

### 返回`*this`的成员函数

- 普通成员函数返回`*this`，与const成员函数返回`*this`有何区别
- 返回`*this`的成员函数一般会定义基于const的重载，为什么？

### 类类型

- 什么是类的声明？什么是不完全类型？
- 不完全类型可以在哪些场景使用？
- 类的成员类型有何限制？

### 友元

- 如何把其他类声明为友元？作用是什么？
- 如何把其他类的成员函数声明为友元？此时这两个类的定义有何要求？

- 友元的声明与函数的声明有何区别？试分析以下代码有何问题

  ```c++
  struct X {
      friend void f() { /* 友元函数定义在类的内部*/ }
      X() { f(); }	// 非法, 友元函数并未声明
      void g();
      void h();
  };
  void X::g() { return f(); }	// 非法, 友元函数并未声明
  void f();			// 这是函数f第一次被声明
  void X::h() { return f(); }	// 合法, 该友元函数已经被声明
  ```

## 类的作用域

- 什么是类的作用域？
- 在类外部定义的成员函数有何需要注意的地方？
- 编译器在处理类的定义时会分为两步，具体是怎样的？
- 相对于普通成员，类型名有何特殊之处？
- 成员函数中的名字查找是怎样进行的？

## 构造函数再谈

### 构造函数初始值列表

- 构造函数的初始化与赋值效果有何区别？什么时候只能使用初始化？
- 构造函数初始化成员的顺序是怎样的？
- 构造函数可以提供默认实参，若为所有成员都提供了默认实参会发生什么？

### 委托构造函数

- 什么是委托构造函数？

### 默认构造函数的作用

- 当对象被默认初始化，或值初始化时将会自动执行默认构造函数
  - 对象什么时候会被默认初始化
  - 对象什么时候会被值初始化

### 隐式的类类型转换

- 什么是转换构造函数？

- 什么时候会发生隐式类类型转换？此时编译器做了什么？
- 隐式类类型转换有何特点？
- 如何抑制构造函数定义的隐式转换？
- 什么是explicit关键字？explicit构造函数有何特点？
- 可以让explicit构造函数显示转换吗？是怎样进行的？
- 标准库中含有显式构造函数的类是什么？试举两个例子
- string对象和vector对象都有一个接受单个参数的构造函数，它们有何区别？为何这么设计？

### 聚合类

- 什么是聚合类？
- 如何初始化聚合类的成员

## 类的静态成员

- 什么是类的静态成员？有何特点？
- 如何声明静态成员？
- 类的静态成员是每个对象都有的吗？
- 类的静态成员函数与普通的成员函数有何区别？
- 如何使用静态成员？访问静态成员的方式有哪几种？
- 类的静态成员声明，与定义应该如何进行？
- 类的静态成员声明时，可以提供类内初始值吗？有何要求？
- 类的静态成员和普通成员有何区别？



# 第8章 IO库

## IO类

- IO类型可以分为哪三类？它们分别在什么时候使用？
- IO类型之间的关系是怎样的？

- 可以给IO类型拷贝或赋值吗？IO类型如何传参？

### 条件状态

- IO类型有哪几个标志位？分别是什么含义？
- 如何判断IO类型是否处于有效状态？
- 采用IO类型的哪两个方法可以查询流的状态？
- 如何管理条件状态？
- 如何获取IO类型的完整条件状态？
- 什么是`strm::iostate`类型？

### 管理输出缓冲

- 为什么输出流有缓冲区？每个输出流都有缓冲区吗？
- 缓冲刷新是什么意思？什么时候发生缓冲刷新？
- 哪些操纵符可以显式地刷新输出流缓冲区？它们有何区别？
- 程序崩溃时，输出流缓冲区会刷新吗？这会造成什么影响?

### 关联输入流和输出流

- 举例说明C++中关联输入流和输出流？
- 为什么要关联输入流和输出流？
- 如何关联输入流和输出流？
- 一个输出流可以被多个流关联吗？一个流可以关联到多个输出流吗？

## 文件输入输出

- 文件IO类型有哪些？

### 使用文件流对象

- 相比于普通的IO类型，文件流对象有何特殊操作？
- 文件流对象是如何打开文件的？
- 文件流对象如何关闭文件？
- 什么时候打开文件会失败？有什么需要注意的地方？
- 什么是`is_open`方法，它的返回值是什么？
- 文件流对象的自动构造和析构是怎样的？

### 文件模式

- 每个文件流对象都有关联的文件模式吗？
- 文件模式都有哪些？分别是什么含义？
- 如何指定文件流对象的文件模式？
- 文件模式是任意指定的吗？有何限制？
- 文件流类型的默认文件模式是怎样的？
- 使用`ofstream`打开文件有什么要注意的地方？
- 如何同时指定多个文件模式？

## string类

- 暂略

# 第9章 顺序容器

## 顺序容器概述

- 有哪些类型的顺序容器？分别有何特点？
- `list`和`forward_list`有何区别？为什么C++11需要新增`forward_list`？
- `array`类型有何特点？
- 每个容器都有`size()`成员吗？它的时间复杂度如何？

### 顺序容器类型选择

- 如何选择顺序容器类型？

## 容器库概览

- 容器类型操作的层次是怎样的？
- 容器定义在哪些头文件中？使用前如何引入?
- 容器类型有何特别之处？
- 容器可以保存的元素类型有何限制？

### 迭代器

- 哪些容器类型支持迭代器的算术运算？
- `forward_list`的迭代器有何特点？
- 什么是迭代器范围？
- 什么是迭代器对？有何要求？
- 什么时候迭代器范围为空？

### 容器类型成员

- 容器的类型成员都有哪些？
- 什么是反向迭代器？

### begin和end成员

- `begin`和`end`成员返回什么？
- `cbegin`和`cend`返回什么？
- `rbegin`和`rend`返回什么？
- `begin`成员和`end`成员的重载是怎样的？
- 使用迭代器时，我们应该如何选择这几个成员？

### 容器定义和初始化

- 将一个容器初始化为另一个容器的拷贝有两种形式，分别是什么？这两种形式有何区别？
- 与容器大小相关的构造函数是怎样的？其初始化有何特点？
- 标准库`array`类型有何特点？其初始化是怎样的？
- `array`类型可以拷贝吗？内置数组可以拷贝吗?

### 赋值和swap

- 赋值运算符的作用是什么？
- 如果两个容器原来大小不同，赋值后怎样？
- `array`类型的赋值有何特别之处？
- 赋值运算后，左侧运算对象的迭代器、指针、引用还有效吗？

#### 使用assign

- 如何使用`assign`成员？有几种形式?
- 传入`assign`的迭代器有何要求？
- 所有顺序容器都有`assign`成员吗？
- `assign`后，左侧运算对象的迭代器、指针、引用还有效吗？

#### 使用swap

- 如何使用`swap`成员？它对两个运算对象的类型有何要求？
- `swap`操作的时间复杂度如何？它的实现方式是怎样的？
- `swap`后，两个运算对象的迭代器、指针、引用还有效吗?
- `swap`两个`array`有何特别之处？其时间复杂度如何？迭代器、指针、引用如何？
- C++11提供了非成员版本和成员版本的swap，应该如何选择？

### 容器大小操作

- 有三个成员函数与容器大小有关，分别是什么？
- `forward_list`的容器大小成员函数都有哪些？

### 关系运算符

- 每个容器类型都支持的关系运算符是什么，它们是怎么工作的？
- 哪些容器支持运算符`>`，`>=`，`<`，`<=`？
- 关系运算符对两侧的运算对象有何要求？
- 容器的关系运算符是怎样执行运算的？对容器的元素类型有何要求？

## 顺序容器操作

### 添加元素

- `push_back`和`push_front`是如何执行的？
- 哪些容器类型支持`insert`操作？有多少种版本？返回值是什么？
- `emplace`操作是怎样的？

### 访问元素

- `back`和`front`成员返回值是什么？容器为空时会发生什么？
- 下标访问与`at`成员函数有何区别？
- 这些访问元素的函数返回值是什么？

### 删除元素

- `pop_back`和`pop_front`是如何执行的？

- `erase`有多少种版本？返回值是什么？
- `clear`的作用是什么？
- 请总结以上各种操作的返回值？

### 特殊的forward_list操作

- forward_list有哪些操作？
- `before_begin()`成员返回什么？

### 改变容器大小

- 什么成员函数可以改变大小？
- 如果大小扩大了会怎样?
- 如果大小缩小了会怎样？

### 容器操作可能使迭代器失效

- 容器添加元素操作对迭代器、引用、指针的影响是怎样的？
- 容器删除元素操作对迭代器、引用、指针的影响是怎样的？
- 在循环中添加/删除元素，有何需要注意的地方？
- 为什么不能在for范围循环中增加/删除元素？

## vector对象的增长

- C++规定vector和string是连续存储的，vector是如何实现高效增长的？
- 管理容量的成员函数有哪几个？
- `capacity()`和`size()`的概念有何区别？
- `reverse()`执行的结果可能是怎样的？
- `shrink_to_fit()`成员有何作用？结果可能是怎样的？

- vector会在还有容量的情况下，重新分配内存空间吗？



## 额外的string操作

- 从数组或string构造string的方法是怎样的？
- `substr`操作是怎样的？

### 搜索操作

- `string`有哪几个搜索操作？其返回值有何特点？

### 数值转换

- 如何将算术类型转换为string？

- 如何将string转化为算术类型？

## 容器适配器

- 什么是适配器？
- 顺序容器适配器有哪些？
- 如何定义一个适配器？
- 栈适配器有哪些特殊操作？
- 队列适配器 有哪些特殊操作？



# 第十章 泛型算法

## 10.1 概述

- 泛型算法的概念是什么？**泛型**是什么含义？
- 通过**迭代器**表示输入范围有何优点？
- 算法`find`是如何使用的？
- 泛型算法有何特点？它依赖于容器类型吗？依赖于元素类型吗？

## 10.2 泛型算法的分类

- 泛型算法可分为哪几类？

  **只读算法、写容器元素的算法、重排容器元素的算法**

- 什么是算法的**输入范围**？

### 只读算法

- 什么是只读算法？
- `accumulate`算法的参数是什么？作用是什么？定义在哪个头文件？
- `equal`算法的参数是什么？作用是什么？有何特殊之处？

### 写容器元素的算法

- `fill`算法的参数是什么？作用是什么？
- `fill_n`算法的参数是什么？作用是什么？有何需要注意的地方？
- 算法**不执行写检查**是什么意思？

- **插入迭代器**是什么？`back_inserter`是怎样使用的？

- `copy`算法的参数是什么？作用是什么？返回值是什么？
- 算法的拷贝版本是什么？
- `replace`算法的参数是什么？作用是什么？
- `replace_copy`算法的参数是什么？作用是什么？

### 重排容器元素的算法

- `sort`算法的参数是什么？作用是什么？
- `unique`算法的参数是什么？作用是什么？返回值是什么？
- `unique`算法的返回值有何特殊之处？这与泛型算法的什么特点有关？

## 10.3 定制操作

### 10.3.1 向算法传递函数

- 什么是**谓词**？
- 什么是**一元谓词**？什么是**二元谓词**？
- 接受谓词参数的算法如何使用谓词？
- `sort`的重载版本接受几个参数？作用是什么？
- `stable_sort`算法的作用是什么？

- `partition`算法的参数是什么？作用是什么？返回值是什么？

### 10.3.2 lambda表达式

- 谓词有什么限制？
- 什么是可调用对象？C++有哪几种**可调用对象**？
- lambda表达式是什么？其形式是怎样的？其中的哪几部分是可以忽略的？
- 如何**定义**lambda表达式？
- 如何**调用**lambda表达式？

- 捕获列表的作用是什么？如何捕获多个变量？被捕获的变量有哪些要求？

- `find_if`算法的参数是什么？作用是什么？其第三个参数有何特点？
- `for_each`算法的参数是什么？作用是什么？

### 10.3.3 lambda捕获和返回

- lambda表达式的类型是什么？
- 什么时候会创建这种类型的对象？
- lambda表达式的变量捕获有哪两种方式？有何特点？
- lambda表达式的引用捕获有何特点？对被捕获的变量有何要求？
- 什么是lambda表达式的隐式捕获，如何使用隐式捕获？
- 什么是lambda表达式的混合捕获，如何使用？
- 什么是可变lambda？
- lambda表达式的返回类型是什么？如何指定返回类型？
- 能否将lambda作为函数的返回类型？若可以，有何要求？

### 10.3.4 参数绑定

- 标准库`bind`函数是什么？其参数是什么？返回值是什么？作用是什么？
- `bind`函数的第二个参数是什么意思？其中的占位符是什么意思？
- 上述占位符定义在哪个命名空间中？如何使用？
- `bind`调用其可调用对象时，是如何传参的？如果想要通过引用传递，该如何操作？

- `bind`有何应用？

## 10.4 再探迭代器

- 除了容器定义的迭代器外，标准库在`iterator`头文件中定义了哪几种特殊迭代器？

### 插入迭代器

- 什么是插入迭代器？有哪几种类型？有何区别？
- 通过插入迭代器赋值时，将发生什么？

### 流迭代器

- 什么是`iostream`迭代器？有哪几种类型？
- `istream_iterator`的两种构造方式有何区别？
- 如何使用`istream_iterator`？
- `istream_iterator`的懒惰求值是什么？
- `ostream_iterator`的两种构造方式有何区别？`ostream_iterator`是否必须绑定到一个输出流？

### 反向迭代器

- 什么是反向迭代器？哪些容器没有反向迭代器？
- 如何将反向迭代器转换为迭代器？转换前后的迭代器指向同一个元素吗？为何这样设计？

## 10.5 泛型算法结构

- 算法的最基本特性是什么？
- 五类迭代器是什么？分别有什么特点？
- 常见容器定义的迭代器分别属于哪类迭代器？
- 算法的形参模式是什么？接受第二个输入序列的算法可以通过哪两种方式接受？
- 算法的命名规范有哪些？

## 10.6 特定容器算法（`list`和`forward_list`）

暂略

## 10.7 泛型算法总结

- `find`
- `accumulate`
- `equal`
- `fill`
- `fill_n`
- `copy`
- `copy_if`
- `find_if`
- `replace`
- `replace_copy`
- `sort`
- `unique`
- `stable_sort`
- `partition`
- `for_each`



# 第11章 关联容器

- C++标准库定义了8个关联容器，分别是什么？

## 11.2 关联容器概述

- 关联容器的构造函数有哪几种？
- 有序容器对关键字类型有什么要求？
- 如何自定义比较操作？

### `pair`类型

- 什么是`pair`类型？定义在哪个头文件？
- `pair`的数据成员有哪些？
- `pair`的初始化方式有哪些？
- `make_pair`函数如何使用？
- 从一个函数返回一个`pair`有哪两种方式？

## 11.3 关联容器操作

- 关联容器的类型别名有哪些？对于`set`和`map`它们分别是什么？
- 通常不对关联容器使用泛型算法，为什么？

### 添加元素

- 如何使用`insert`向关联容器添加元素？
- `insert(v)`的返回值是什么？`set`和`multiset`有何区别？
- 如何使用`emplace`向关联容器添加元素？

### 删除元素

- `erase`的三个版本分别是什么？
- `erase(k)`作用是什么？返回值是什么?
- 删除元素时有何需要注意的地方?

### map的下标操作

- 哪些容器支持下标操作？
- 下标运算符和`at`成员函数都能执行下标操作，有何区别？
- 下标操作的返回值是什么？请与解引用map迭代器进行对比？

### 访问元素

- `find`如何使用？
- `count`如何使用
- `lower_bound`如何使用？
- `upper_bound`如何使用？
- `equal_range`如何使用？

## 11.4 无序容器

- 无序容器对关键字类型的要求是怎样的？
- 如何使用自定义类型的无序容器？
- 如何提供自定义的哈希计算函数，和相等性判断运算符？
- 无序容器是如何存储元素的？具有相同哈希值的所有元素会被存储在一起吗？
- 无序容器相对于有序容器，有何优点？有何缺点？

# 第12章 动态内存

- **全局对象、局部自动对象、局部static对象**的生存期分别是怎样的
- **静态内存、栈内存、堆内存**分别保存哪种对象？

## 12.1 动态内存与智能指针

- C++通过哪对运算符对动态内存进行管理？
- C++为什么要用智能指针管理动态对象？动态内存的使用容易造成哪些问题？

### `shared_ptr`类

- 智能指针定义在哪个头文件中？
- `shared_ptr`类的默认初始化是怎样的？
- 若`p`是智能指针，`p.get()`返回什么？
- `make_shared`函数有何作用？
- 使用`make_shared`分配动态对象时，若不传递任何参数，对象将如何初始化？

#### `shared_ptr`的拷贝和赋值

- `shared_ptr`的**引用计数**是什么？
- 什么时候`shared_ptr`的引用计数会**递增**？
- 什么时候`shared_ptr`的引用计数会**递减**？
- 拷贝`shared_ptr`的操作有哪些？

#### `shared_ptr`自动销毁所管理的对象

- 智能指针指向的对象在什么时候被释放?
- `shared_ptr`类的**析构函数**会进行什么操作？

#### 使用动态生存期资源的类

- 程序**使用动态内存的原因**一般是哪三种？
- 程序需要**在多个对象间共享数据**时，一般使用动态内存，这种类对象销毁时能直接销毁该共享数据吗？应该如何管理？

### 使用`new`和`delete`直接管理内存

#### `new`

- 运算符`new`和`delete`的作用分别是什么？
- 使用`new`动态分配对象，有几种**初始化**方法？
- 可以使用`new`动态分配`const`对象吗，初始化有什么要求？
- 若**内存耗尽**，`new`表达式会如何？
- 什么是`placement new`？什么是`nothrow`？

#### `delete`

- `delete`的作用是什么？`delete`在什么情况下的行为是**未定义**的？

#### 动态内存管理的常见错误

- 动态内存管理的常见错误有哪几种？
- 什么是**空悬指针**？
- 为什么要在`delete`后**重置指针值**？为什么这样做仍然无法防止出错？

### `shared_ptr`和`new`结合使用

#### `shared_ptr`的初始化

- `shared_ptr`的构造函数是`explict`的，这给它的使用带来了哪些限制？
- 如何用`new`返回的指针初始化`shared_ptr`智能指针？
- 假如初始化智能指针的内置指针并非指向动态内存，会发生什么？

#### 不要混合使用普通指针和智能指针

- 为什么？

#### 不要用`get`初始化另一个智能指针，或为智能指针赋值

- `get()`返回值是什么？
- `get()`设计的目的是什么？
- 使用`get()`返回的指针的代码有何要求？
- 不要用`get`初始化另一个智能指针或为另一个智能指针赋值，为什么？

#### `reset`成员函数

- `reset`成员函数有多少个版本？其作用是什么？

#### `unique`和`use_count`成员函数

- `use_count()`的返回值是什么?
- `unique()`的返回值是什么？

### 智能指针和异常

- 使用异常处理的程序，若采用`new`和`delete`直接管理动态内存，有何问题？
- 在异常处理程序中采用智能指针有什么好处？

#### 使用自定义的释放操作

- 默认情况下，`shared_ptr`释放其所指对象时将执行什么操作？
- 如何使用自定义的释放操作？
- 什么是删除器？

#### 智能指针使用的标准规范

- 请说出四点`shared_ptr`使用的标准规范？

### `unique_ptr`类

#### `unique_ptr`的定义和初始化

- `unique_ptr`的类型与`shared_ptr`的类型有何区别？
- 为什么说`unique_ptr`拥有其所指向的对象？
- 如何初始化`unique_ptr`？
- 可以拷贝或赋值一个`unique_ptr`吗?

#### `release`和`reset`转移指针所有权

- `release()`的作用是什么？返回值是什么？为什么`shared_ptr`没有`release()`成员
- `reset`有多少种版本？作用是什么？
- 若`p`是一个`unique_ptr`，`p=nullptr`的作用是什么？

#### 返回`unique_ptr`

- 不能拷贝和赋值`unique_ptr`有一种例外，是什么？

#### 向`unique_ptr`传递删除器

- 向`unique_ptr`传递删除器会改变什么？

### `weak_ptr`类

- `weak_ptr`指向的对象是什么？
- `weak_ptr`有何特点？
- 如何初始化一个`weak_ptr`？
- 如何访问`weak_ptr`指向的对象？为什么要采取这种访问方式？
- `weak_ptr`的`use_count`成员、`expired`成员、`lock`成员分别有何作用？

## 12.2 动态数组

### `new`和数组

- 如何使用`new`分配动态数组？
- `new`分配动态数组需要指明要分配的对象的数目，该数目必须是常量吗?
- 使用`new`分配数组返回值是什么？这意味着什么限制？
- 如何初始化动态分配对象的数组？有哪几种方式？
- 如果动态分配数组中，对象的数目为0会发生什么?
- 如何释放动态数组？
- 如果`delete[]`一个指向单一对象的指针，或`delete`一个指向动态数组的指针，会发生什么？
- 如何使用`unique_ptr`管理动态数组？
- 如何使用`shared_ptr`管理动态数组？

### `allocator`类

- `allocator`相对于`new`有何优点？
- `allocator`分配的内存有何特点？
- `allocator`**分配内存**的成员是什么？如何使用？
- `allocator`**构造对象**的成员是什么？如何使用？
- `allocator`**销毁对象**的成员是什么? 如何使用？
- `allocator`**释放内存**的成员是什么？如何使用？
- `allocator`的两个**伴随算法**，可以在未初始化内存中创建对象，它们是怎么使用的？

# 第13章 拷贝控制

## 13.1 拷贝、赋值与销毁

### 拷贝构造函数

- 什么是拷贝构造函数？
- 拷贝构造函数的第一个参数有何特点？
- 拷贝构造函数是`explict`的吗？

#### 合成拷贝构造函数

- 如果没有类没有定义拷贝构造函数，编译器会如何处理？
- 合成拷贝构造函数会进行什么操作？拷贝数据成员时有何特点？

#### 拷贝初始化

- 直接初始化与拷贝初始化的区别是什么？
- 什么时候进行拷贝初始化？

#### 参数和返回值

- 为什么拷贝构造函数必须接受引用类型

- 编译器可以绕过拷贝构造函数吗？此时编译器会如何操作？

### 拷贝赋值运算符

- 什么是重载赋值运算符？
- 重载运算符本质是什么？名字有何特点？参数有何特点？
- 重载赋值运算符参数是什么？返回值是什么？

#### 合成拷贝赋值运算符

- 若类未定义自己的拷贝赋值运算符，编译器会做什么？
- 合成拷贝赋值运算符会做什么？对于不同类型的成员会做什么？

### 析构函数

- 什么是析构函数？名字是什么？参数是什么？返回值是什么？
- 一个类可以有几个析构函数？
- 析构函数由哪两部分组成？
- 析构函数如何销毁数据成员？有何特点？
- 析构函数在处理内置指针成员，与智能指针成员时有何区别？

- 什么时候调用析构函数？
- 对象的引用或指针离开作用域时，会调用析构函数吗？

#### 合成析构函数

- 合成析构函数是什么？它会销毁数据成员吗？

### 三/五法则

- 类的拷贝控制成员定义，有哪两个原则？

### 使用`=default`

- 将拷贝控制成员定义为`=default`意味着什么?

### 阻止拷贝

- 什么时候需要阻止拷贝？已学过的哪些类阻止了拷贝？

#### 定义删除的函数

- 什么是删除的函数？
- 如何定义删除的函数？

#### 析构函数不能是删除的函数

- 如果一个类删除了析构函数，会发生什么?
- 如果一个类的某个成员类型的析构函数删除了，会发生什么？
- 对于这种类，我们可以动态分配该类型的对象吗？如果可以，我们可以销毁该对象吗？

#### 合成的拷贝控制成员可能是删除的

- 如果类的某个成员的析构函数是删除或不可访问的，类哪些的合成拷贝控制成员是删除的？为什么？
- 如果类的某个成员的合成拷贝构造函数是删除或不可访问的，类的哪些合成拷贝控制成员是删除的？为什么？
- 什么情况下类的合成拷贝赋值运算符是删除的？为什么?
- 什么情况下类的默认构造函数是删除的？为什么？

#### `private`拷贝控制

- 如何将拷贝控制成员声明为`private`以阻止拷贝？
- 试图拷贝对象的用户代码会发生什么错误？试图拷贝对象的友元或成员函数会发生什么错误？

## 13.2 拷贝控制和资源管理

- 什么是行为像值的类？
- 什么是行为像指针的类？
- 类如何定义某种共享资源的引用计数？

## 13.3 交换操作

- 什么时候会调用`swap`？
- 定义了自己的`swap`，与没定义自己的`swap`的类，在进行排序时有何区别？
- 为什么管理资源的类最好自定义一个名为`swap`的函数？
- 类自定义的`swap`一般如何编写

### 在赋值运算符中使用`swap`

- 什么是`copy and swap`技术？
- `copy and swap`技术相对于普通的赋值运算符有何优点？

## 13.6 对象移动

- 什么情况下移动而非拷贝对象能大幅提升性能？

### 13.6.1 右值引用

- 什么是**右值引用**？它能指向什么对象？
- 右值引用有何重要**性质**？
- 左值引用可以绑定到返回左值的表达式，**返回左值的表达式有哪些**？
- 右值引用可以绑定到返回右值的表达式，**返回右值的表达式有哪些**？

#### 左值持久、右值短暂

- 为什么右值引用可以**自由地接管**所引用的对象的**资源**？

- 变量是左值还是右值？

#### 标准库`move`函数

- 标准库`move`函数的作用是什么？
- 定义在哪个头文件？
- 对`std::move`的调用有何需要注意的地方？
- 移后源对象有何特点？
- 请总结左值引用和右值引用的区别？

### 13.6.2 移动构造函数和移动赋值运算符

- 移动构造函数的参数有何特点？
- 移动构造函数应该如何处理移后源对象？

#### 移动操作、标准库容器和异常

- 以`vector`为例，说明如果移动构造函数会抛出异常，标准库容器会做什么额外操作？
- 如何告诉标准库移动构造函数不会抛出异常？

#### 移动赋值运算符

- 移动赋值运算符进行什么操作？
- 移动赋值运算符如何保证自赋值的正确性？

#### 移后源对象

- 移动构造函数和移动赋值运算符应该保证移后源对象的哪些要求？

#### 合成的移动操作

- 什么时候编译器会合成移动构造函数或移动赋值运算符？
- 什么时候合成的移动操作会被定义为删除的？

#### 移动左值、拷贝右值

- 如果类既定义了拷贝构造函数，又定义了移动构造函数，在对该类型进行拷贝初始化时，将调用哪个函数？
- 如果类只定义了拷贝构造函数，没有定义移动构造函数，在对该类型进行拷贝初始化时，将发生什么？会引发错误吗？

#### 三/五法则

- 请阐述三/五法则

#### 移动迭代器

- 什么是**移动迭代器**？它与普通迭代器有何区别？
- 如何将**普通迭代器转换为移动迭代器**？
- 移动迭代器有何应用？可以以`StrVec`类的`reallocate`成员举例说明？

#### 不要轻易使用移动操作

- 什么时候调用`move`？

### 13.6.3 右值引用和成员函数

- 对于普通的成员函数，如何定义其**拷贝和移动**版本？

- 在对象上调用成员函数时，该对象一定是左值吗？以下语句合法吗？

  ```c++
  string s1 = "Hello", s2 = "world";
  cout << (s1 + s2).size() << endl;
  ```

- 如何限制调用成员函数的**对象必须为左值或必须为右值**？

- 什么是**`const`限定符**？什么是**引用限定符**？可以**混合使用**吗？

- 引用限定符可以区分重载版本吗？使用时有何需要注意的地方？



# 第14章 重载运算与类型转换

## 14.1 基本概念

- 重载运算符本质是什么？
- 重载运算符的名字是怎样的？其参数是怎样的？
- 重载运算符一定是成员函数吗？重载运算符中的`this`指针指向什么？
- 为什么我们无法改变内置类型运算符的含义
- 可以发明新的运算符号吗？
- C++有多少个符号既是一元运算符，又是二元运算符？重载这些运算符该如何区分？
- 重载运算符的优先级、结合律、求值顺序是怎样的？

- 我们可以直接调用重载的运算符函数吗？
- 什么运算符不能被重载？
- 什么运算符最好不要重载？

- 重载运算符的返回类型是怎样的？

- 重载运算符时，应该将定义为成员函数，还是非成员函数？

## 14.2 输入和输出关系运算符

- 重载输出运算符`<<`的第一个参数是什么？第二个参数是什么？返回值是什么？
- 重载输入运算符`>>`的第一个参数是什么？第二个参数是什么？返回值是什么？
- 重载输入输出运算符是成员还是非成员？为什么？
- 重载输入运算符，相对于重载输出运算符，做了什么额外的操作？
- 执行输入运算符可能遇到什么错误？此时应该进行什么操作？
- 执行输入运算符若没有遇到IO错误，但读入的数据有问题，该如何标识错误？

## 14.3 算术和关系运算符

- 算术和关系运算符是成员还是非成员？为什么？
- 算术和关系运算符的形参通常是什么类型的？

### 算术运算符

- 算术运算符进行什么操作？返回值是什么？
- 定义了算术运算符的类，通常也应该定义什么运算符？它们的实现上有何联系？

### 相等运算符

- 定义相等运算符时，通常如何对比两个对象是否相等？
- 相等运算符应该具有什么性质？
- 定义了`operator==`的类，通常也应该定义什么运算符？两者的实现上有何联系？

### 关系运算符

- 什么时候需要定义`operator<`运算符？
- 如果类存在`==`运算符，则`<`的定义有何要求？

## 14.4 赋值运算符

- 我们已学过的赋值运算符有哪两种？
- 接受花括号列表作为参数的赋值运算符是怎样的？它需要考虑自赋值问题吗？
- 赋值运算符是成员还是非成员？
- 赋值运算符的返回值是什么？

### 复合赋值运算符

- 复合赋值运算符是成员还是非成员？
- 复合赋值运算符返回值是什么？

## 14.5 下标运算符

- 什么类通常会定义下标运算符`operator[]`
- 下标运算符是成员还是非成员？
- 下标运算符返回值是什么？
- 下标运算符通常会重载，为什么？

## 14.6 递增和递减运算符

- 什么类通常定义递增和递减运算符？
- 递增和递减运算符是成员还是非成员？

### 前置版本

- 如何定义递增递减运算符的前置版本？
- 其返回值是什么？

### 后置版本

- 如何定义后置版本？它和前置版本是如何区分的？
- 编译器调用后置版本的递增和递减运算符时，会作什么处理？
- 其返回值是什么？
- 如果显式调用后置版本呢，即通过`opreator++`调用，应怎么做？

## 14.7 成员访问运算符

- 成员访问运算符包含哪两个运算符？
- 解引用运算符是成员还是非成员？返回值是什么？
- 箭头运算符是成员还是非成员？返回值是什么？
- 为什么箭头运算符、解引用运算符通常定义为`const`成员？

### 箭头运算符返回值的限定

- 箭头运算符返回值是什么？
- 当使用`pointer->mem`表达式时，会发生什么？

## 14.8 函数调用运算符

- 请列举C++的可调用对象？
- 什么是函数对象？
- 函数调用运算符是成员还是非成员？
- 函数调用运算符可以重载吗？

### lambda是函数对象

- 为什么说lambda是函数对象？编译器如何处理lambda表达式？
- 没有捕获变量的lambda表达式等价于什么形式的类？其函数调用运算符是怎样的？

#### 表示lambda及相应捕获行为的类

- 如果lambda通过值捕获变量，它对应的类的函数调用运算符可以直接使用这些变量吗？应该如何处理？
- 如果lambda通过引用捕获变量，它可以直接使用这些变量吗？

### 可调用对象与function

- 函数和函数指针类型是什么？
- `lambda`的类型是什么？
- 什么是调用形式？不同类型的可调用对象可以有相同的调用形式吗？

- 什么是函数表？它有什么作用？它的使用有何问题？

#### 标准库function类型

- 什么是标准库`function`类型？如何定义`function`类型？
- 如何通过`function`类型解决上述函数表的问题？
- 可以用重载函数的名字初始化`function`类型对象吗？如何解决该问题？

## 14.9 重载、类型转换与运算符

- 什么是类类型转换？
- 什么是转换构造函数？什么是类型转换运算符？

### 类型转换运算符

- 类型转换运算符的作用是什么？

- 如何定义类型转换运算符？可以转换的目的类型有哪些？

- 类型转换运算符是成员还是非成员？返回类型是什么？参数是什么？是`const`成员吗？

- 以下代码是正确的吗？这体现了类型转换的什么特点？

  ```c++
  class SmallInt {
      public:
      	SmallInt(int i = 0): val(i) {
              if (i < 0 || i > 255) 
                  throw out_of_range("Bad SmallInt val");
          }
      	operator int() { return val; }
      private:
      	size_t val;
  };
  
  SmallInt si = 3.14;	// 内置类型转换将double转换成int, 再调用转换构造函数
  si + 3.14;			// SmallInt类型转换运算符将si转为int, 再由内置类型转换继续转换为double
  ```

- 类型转换运算符**可能产生意外结果**，特别是定义向`bool`的转换时，请举例说明？

#### 显式的类型转换运算符

- 什么是显式的类型转换运算符？它是如何防止类型转换运算符产生意外结果的？
- 定义了显式的类型转换运算符，我们应该如何进行类型转换？
- 显式的类型转换运算符有何例外？
- 为什么向`bool`类型的转换通常指定`explicit`？

### 避免有二义性的类型转换

- 什么情况下可能出现二义性的类型转换？

- 定义类型转换运算符时，如何避免二义性的出现？

### 函数匹配与重载运算符

- 什么时候会出现重载运算符与内置运算符的二义性问题？请举例说明



# 第15章 面向对象程序设计

## 15.1 OOP概述

- 面向对象程序设计的三个概念是什么？分别是什么意思？

- 什么是基类？什么是派生类？
- 基类一般将成员函数分为哪两类？如何区分？
- 什么是类派生列表？
- 什么是虚函数？派生类重新定义虚函数时需要加上`virtual`关键字吗？需要加上`override`关键字吗?
- 什么是动态绑定？什么时候会发生动态绑定？

## 15.2 定义基类和派生类

### 定义基类

- 基类将哪些成员定义为虚函数？
- 对虚函数的调用有何特点？
- 派生类能访问基类的哪些成员？
- 什么是`protected`关键字？有何作用？

### 定义派生类

- 类派生列表中的访问说明符有何作用？
- 如果派生类不覆盖虚函数，会发生什么？
- `override`关键字的作用是什么？
- 派生类对象包含多个组成部分是什么意思？
- 什么是派生类向基类的转换？举出派生类向基类转换的例子

- 派生类的构造函数如何初始化基类部分？初始化顺序是怎样的？
- 派生类可以访问基类的哪些成员？
- 如果基类定义了`public`的静态成员，派生类访问该静态成员有哪些方式？
- 基类可以派生它本身吗？为什么？
- 什么是直接基类？什么是间接基类？
- 如何使一个类不能被继承？

### 类型转换与继承

- 把引用或指针绑定到一个对象上时，引用或指针的类型与对象类型有何要求？
- 什么是静态类型？什么是动态类型？
- 什么是派生类向基类转换？什么是基类向派生类转换？
- 有时候，我们可以向基类的拷贝/移动操作传递派生类对象，此处是将派生类对象转换为基类对象吗？还是什么原理？

## 15.3 虚函数

- 虚函数的调用有时候在编译时解析，有时在运行时解析，请解释？
- `override`说明符的作用是什么？
- 如果我们在派生类定义了与虚函数同名，但形参列表不同的函数，会发生什么？
- 把函数指定为`final`会发生什么？
- 虚函数可以有默认实参吗？此时虚函数的调用有何特别之处？
- 为什么虚函数的默认实参在基类和派生类中最好一致？
- 如果我们希望对虚函数的调用不进行动态绑定，而是执行某个特定版本，应该怎么做？

## 15.4 抽象基类

- 什么是纯虚函数？为什么要声明纯虚函数？如何定义纯虚函数？

- 含有纯虚函数的类有何特别？

## 15.5 访问控制与继承

- 当我们提及类的用户时，“用户”可能有三种含义，请解释？

### `protected`

- `protected`成员是怎样的？派生类的成员或友元可以访问基类的`protected`成员吗，派生类的普通用户可以访问基类的`protected`成员吗？
- 派生类的成员或友元可以通过派生类对象访问基类的`protected`成员吗？可以通过基类对象访问基类的`protected`成员吗？

### `public`、`private`、`protected`继承

- 派生访问说明符有何作用？解释`public`、`private`、`protected`继承之间的区别？
- `public`继承，派生类对于基类成员的访问权限是怎样的？
- `private`继承，派生类对于基类成员的访问权限是怎样的？
- `protected`继承，派生类对于基类成员的访问权限是怎样的？

### 派生类向基类转换的可访问性

- 假设`D`派生自`B`
- 什么时候用户代码可以使用派生类向基类的转换？
- 什么时候`D`的成员函数和友元可以使用派生类向基类的转换？
- 什么时候`D`的派生类的成员和友元可以使用`D`向`B`的转换？

### 改变个别名字的可访问性

- 如何改变个别成员的可访问性？

## 15.6 继承中的类作用域

- 类作用域是怎样的？继承关系中的类作用域是怎样的？

- 对象、引用或指针的静态类型决定了对象的哪些成员是可见的，请解释这句话

- 什么是隐藏？

- 派生类的名字与基类相同的名字之间的关系是怎样的？

- 如果想在派生类中访问被隐藏的基类成员，应该怎么做？

- 在继承关系中调用`p->mem()`会发生什么？请详细说明

- 派生类的函数与基类的同名函数之间的关系是怎样的？请解释重载、隐藏、覆盖之间的区别？

- 如果基类定义了虚函数，而派生类定义了与其同名但形参列表不同的函数，将发生什么？

- 请分析以下代码是否存在错误？

  ```c++
  class Base {
    virtual int fcn();  
  };
  
  class Derived: public Base {
      int fcn(int);
  }
  
  Base b; Derived d;
  Base* bp1 = &b, bp2 = &d;
  bp1->fcn();
  bp2->fcn();
  ```

  

## 15.7 构造函数与拷贝控制

### 虚析构函数

- 为什么基类需要定义**虚析构函数**？
- **三/五法则**是什么？该法则的一个**例外**是什么？

### 合成拷贝控制与继承

- 继承体系中的合成拷贝控制成员有何特别之处？
- 类定义了析构函数，对其移动操作有何影响?
- 如果基类的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是删除或不可访问的 ，派生类的对应成员是怎样的？为什么？
- 如果基类的析构函数是删除或不可访问的，派生类的合成默认构造函数、拷贝构造函数是怎样的？为什么？
- 如果基类的移动操作是删除的或不可访问的，则派生类的合成移动操作是怎样的？为什么？
- 因此，如果我们想要在**派生类中进行移动操作**，应该**怎么做**？

### 派生类的拷贝控制成员

- 派生类的拷贝或移动操作会进行什么操作？
- 派生类的析构函数会进行什么操作？
- 定义派生类的拷贝或移动操作时，有什么要求？
- 定义派生类的赋值运算符时，有什么要求？
- 定义派生类的析构函数时，有什么要求？
- 继承体系中，派生类对象的构造函数或析构函数的执行有何特点？顺序是怎样的？
- 在构造函数或析构函数中调用虚函数有何需要注意的地方?

### 继承的构造函数

- 派生类可以“继承”基类的构造函数，是怎么做的？
- 编译器如何处理继承构造函数时的`using`声明？
- 继承构造函数如何处理派生类自定义的数据成员？
- 如果派生类通过`using`声明继承了基类的构造函数，有什么例外？哪些构造函数不会被继承？

## 15.8 容器与继承

- 容器存放的元素类型应该一致，因此想要将继承关系中的对象放入容器时，应该如何处理？

## 补充 虚函数表

- 什么是类的虚表？哪些类有虚表？
- 虚表本质是什么，其元素是什么?
- 类的每个对象都有虚表吗？
- 虚表的构造发生在什么时候？
- 什么是虚表指针，每个对象都有虚表指针吗？
- 请说明类是如何通过虚表调用虚函数的？
- 动态绑定的三个条件是什么？

# 第18章 用于大型程序的工具

- 大规模应用程序开发有何特殊要求，分别用什么工具解决？

## 18.1 异常处理

### 抛出异常

- 程序如何抛出异常？
- 什么是栈展开，其过程是怎样的？
- 如果栈展开，最终也没找到匹配的`catch`子句，会怎样？
- 栈展开过程中伴随着什么的发生？
- 为什么析构函数不应该抛出异常？

- 抛出一个指向局部对象的指针，会发生什么？

### 捕获异常

- catch子句的参数类型是值类型或引用类型有何区别？
- 如果catch的参数是基类类型，而使用了派生类类型的异常对象初始化，会发生什么？

### 查找匹配的处理代码

- catch子句的顺序会造成什么影响？为此，应该如何设计catch子句的顺序？
- catch子句的类型匹配规则是怎样的？
- 什么是重新抛出？
- 如何捕获所有异常？

### 函数try语句块与构造函数

- 如果在构造函数体中使用try语句块，有何问题？
- 什么是函数try语句块，有何作用？

### noexcept异常说明

- noexcept有哪两种含义？
- 它作为异常说明符时有何作用？
- 它作为运算符时有何作用？

### 异常类层次

- `exception`包含哪4个派生类
- 异常类的`what()`成员有什么作用？

## 18.2 命名空间

- 命名空间有何作用？
- 命名空间如何**定义**？
- 命名空间与**作用域**是什么关系？
- 命名空间可以**不连续**是什么意思？
- 命名空间可以**嵌套**吗？
- **未命名的命名空间**有何特殊之处？
- 什么是命名空间**别名**？
- 什么是**using声明**？
- 什么是**using指示**？

## 18.3 多重继承

- 待补充

# 第19章 特殊工具与技术

## 19.1 控制内存分配

### 重载new和delete

- 分别阐述new表达式和delete表达式的工作原理？
- 当执行new或delete表达式时，会调用相应的operator函数，编译器是如何进行解析的？

- 重载operator new或operator delete的作用是什么？
- operator new的返回类型是什么？第一个形参类型是什么？
- operator new有一个版本无法重载，是什么？它的作用是什么？
- operator delete的返回类型是什么？第一个形参类型是什么？
- operator delete不抛出异常，为什么？
- operator new和operator delete作为类成员时，为什么是隐式静态的？

- malloc和free函数的作用分别是什么?

### 定位new表达式

- 什么是定位new表达式？
- 接受单一地址参数的定位new表达式有何特殊之处？它的作用是什么？
- 接受单一地址参数的定位new表达式和allocator类的construct成员有何异同？

## 19.2 运行时类型识别

- 运行时类型识别的英文全称和简称是什么？它由哪两个运算符组成？
- 什么时候我们需要使用运行时类型识别？

### dynamic_cast运算符

- dynamic_cast的三种形式分别是什么？对参数有何要求？
- dynamic_cast对**表达式类型**和**目标类型**有何要求？
- dynamic_cast的引用类型和指针类型有何区别？如何使用？

### typeid运算符

- typeid运算符作用是什么？
- typeid运算符作用于引用时会怎样？作用于指针时会怎样？
- typeid运算符的结果在编译时求得还是在运行时求得？
- typeid常用于什么场景？

### RTTI使用

- 具有继承关系的类实现相等运算符，是RTTI的典型使用场景，试阐述其具体实现

