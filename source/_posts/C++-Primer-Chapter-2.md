---
title: C++ Primer Chapter 2
date: 2022-02-11 15:27:12
tags: C++
categories: C++
mathjax: true 
---

# 第二章 变量和基本类型

## 2.1 基本内置类型

- char, int, bool, long long, double

### 无符号类型赋值

- 赋给无符号类型一个超出其表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数
- 如，将`-1`赋给8 bit的unsigned char，结果为`255`

### 不要混用带符号类型和无符号类型

- 当算术表达式既有无符号数又有int时，会**将int值转换为无符号数**

- 如，下列代码产生的结果为`4294967264`

```c++
unsigned u = 42;
int i = 10;
cout << i - u << '\n';
```

### 指定字面值的类型

- `42ULL`指定类型为unsigned long long，`1E-3F`指定类型为float，`3.14159L`指定类型为long double，`3LL`指定类型为long long

<!--more-->

## 2.2 变量

### 初始化与赋值

- 初始化与赋值不同，初始化是在创建变量的时候赋予其一个初始值；赋值是将变量当前值擦除，并以一个新值代替

#### 列表初始化

- 通过花括号初始化变量，称为列表初始化

- 如果使用列表初始化且存在丢失信息的风险时，编译器将报错

  ```c++
  long double ld = 3.1415926536;
  int a{b};	// 错误, 存在丢失信息的危险
  ```


#### 默认初始化

- 若定义变量时没有指定初值，则变量被默认初始化。默认值由变量类型决定，且定义变量的位置也会影响

##### 内置类型

- 若在函数体外，则默认初始化为0
- 若在函数体内，则不被初始化，其值是未定义的

##### 类

- **类决定了其初始化对象的方式**，**若允许**不被初始化就定义对象，则类将决定对象的初始值是什么，这样的类一般提供一个合适的默认值
- 若类要求每个对象都显式初始化，则创建该类的对象而未初始化，将引发错误



### 变量声明与定义

- 声明使得名字为程序所知，定义负责创建与名字关联的实体

- 声明变量的方法：使用extern关键字，且不要初始化。如果初始化，则会变为定义（相当于extern不起作用）

  ```c++
  extern int i;
  ```

- 在函数体内部，试图初始化一个由extern关键字标记的变量，将引发错误



### 静态类型语言

- C++是一种**静态类型语言**，**在编译阶段检查类型**（该过程称为类型检查）



### 标识符

- 标识符由字母、数字、下划线组成，必须以字母或下划线开头
- **不能连续使用两个下划线**
- **不能以下划线加大写字母开头**
- **函数体外的标识符不能以下划线开头**



## 2.3 复合类型

### 声明的定义

- 一条声明语句，由一个基本数据类型和紧随其后的一个声明符列表组成，每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型

### 引用

- 引用**为对象起了另外一个名字**，引用类型**引用 (refers to)** 另外一种类型，通过将声明符写成`&d`的形式定义引用类型，其中`d`是声明的变量名
- 定义引用时，程序将引用和它的初始值绑定在一起，**引用必须初始化**，引用无法赋值
- **引用并非对象**，它只是为一个已存在的对象所起的另一个名字
- 引用本身不是对象，**无法定义引用的引用**
- 一般地，引用的类型要和与之绑定的对象严格匹配

#### 不能用字面值常量初始化非const引用

```c++
int &r = 1;
// 非法
```



### 指针

- 指针是**指向（points to）**另外一种类型的复合类型
- 指针本身是一个对象，允许对指针赋值和拷贝，且在其生命周期内指针可先后指向几个不同的对象；指针不必在定义时赋初值

#### 获取对象的地址

- 指针存放某个对象的地址
- 对象的地址可通过取地址符`&`获取
- 一般地，指针的类型要和与之绑定的对象严格匹配

#### 利用指针访问对象

- 如果指针指向一个对象，可利用解引用符`*`来访问该对象，如给解引用符的结果赋值实际上是给指针指向的对象赋值

#### 空指针

- 不指向任何对象的指针，可以用字面值`nullptr`初始化指针
- 最好初始化所有指针，使用未经初始化的指针是引发运行错误的一大原因

#### void* 指针

- 一种特殊的指针，可存放任意对象的地址
- `void*`指针可用于与其他指针比较、作为函数的输入或输出、赋值给另一个`void*`指针，但不能直接操作其所指的对象

#### 指针初始化为0

- 可以把指针初始化为0，代表它为空指针

  ```c++
  int *p = 0;
  ```

- 但不能用int型变量给指针初始化/赋值，即使该int型变量为0

  ```c++
  int v = 0;
  int *p = v;
  // 错误
  ```

  

### 理解复合类型的声明

- 一条定义语句中，基本类型只有一个，但声明符的形式可以不同，从而定义出不同类型的变量

  ```c++
  int i = 1024, *p = &i, &r = i;
  ```

#### 指向指针的引用

- 引用不是对象，不可以定义指向引用的指针，但可以定义指向指针的引用

- 定义指向指针的引用，此后给该引用赋值相当于给其绑定的指针赋值，解该引用相当于解该引用绑定的指针

  ```c++
  int v = 0;
  int *p = &v;
  int *&r = p;
  ```

- 对于复杂的复合类型定义，可以从右到左阅读，离变量名最近的修饰符对其类型的影响最为直接。如，上述对`r`的定义，最近的符号`&`表明它是一个引用，绑定的类型是指向int的指针



## 2.4 const限定符

### const对象必须初始化

- const对象一旦创建后其值就不能再改变

- 若利用一个对象初始化另一个对象，则其是否const无关紧要

  ```c++
  int i = 42;
  const int j = i;		// 合法
  ```

### 默认状态下，const对象仅在文件内有效

- 若程序包含多个文件，则每个用了const对象的文件都需要定义一次
- 特别地，若想在多个文件内共享const对象，则可以在声明和定义语句中都加上extern

### const的引用

- 将引用绑定到const对象上，成为reference to const

  ```c++
  const int i = 1;
  const int &r = i;
  ```

- 无法利用const引用为对象赋值，因为该对象是const的

- **不能将非const引用绑定到const对象上**，否则就可能通过该引用修改const对象的值，导致错误

#### 可以将const引用绑定到非const对象上

- 允许为一个常量引用绑定非常量的对象、字面值，甚至是一般表达式，只要类型符合

  ```c++
  int i = 42;
  const int &r = i;	// 合法
  ```

- 绑定后，不能通过该const引用修改对象的值；但可以通过其他途径修改对象的值

  ```c++
  int i = 42;
  const int &r1 = i;
  int &r2 = i;
  r1 = 10;		// 非法, 不能通过const引用修改对象的值
  r2 = 10;		// 合法
  cout << r1 << '\n';	// 结果将输出10
  ```

> const指针或const引用，可理解为指针或引用”自以为是“地觉得自己指向了const对象，从而自觉地不去改变所指对象的值

### const指针

- 把指针定义为常量，则必须初始化，且初始化完成后其值就不再改变

  ```c++
  int i = 42;
  int *const p = i;		// p是一个指向int的const指针
  const int j = 10;
  const int *const p2 = j;	// p2是一个指向const int的const指针
  ```

  

### 顶层const和底层const

- 指针本身是一个对象，又指向另一个对象，指针本身为常量称为**顶层const**，其所指的对象是常量称为**底层const**

- 执行对象拷贝时，底层const不能忽视，拷入和拷出的对象必须具有相同的底层const，或者底层const将非常量转换为常量

### constexpr

#### 常量表达式

- 常量表达式指值不会改变且编译过程就能得到计算结果的表达式

- 字面值是常量表达式

- 用常量表达式初始化的const对象是常量表达式

  ```c++
  const int max_v = 20;			// 常量表达式
  const int limit = max_v + 1;	// 常量表达式
  ```

- 若const对象的初始值要在 运行时才确定，则也不是常量表达式

  ```c++
  const int sz = get_size();		// sz不是常量表达式
  ```

#### constexpr变量

- 将变量声明为constexpr类型，编译器会验证变量的值是否常量表达式。声明为constexpr的变量是一个常量，且必须用常量表达式初始化

#### constexpr和指针

- 使用constexpr定义指针，会将指针定义为**常量指针（顶层const）**，但不代表它所指的对象是个常量**（非底层const）**

## 2.5 处理类型

### 类型别名

- 让复杂的类型名字更简单、易于理解

  - 方法一：`typedef`

  ```c++
  typedef long long ll;
  ```

  - 方法二：别名声明

  ```c++
  using ll = long long;
  ```

#### 使用别名后在定义类型时容易引起的混淆

- 如下例子，变量`cstr`是一个**指向char类型的常量指针**，而不是一个指向常量char的指针

```c++
typedef char* pstring;
const pstring cstr = 0;
```



### auto类型说明符

- auto类型说明符，让编译器通过初始值推算变量的类型
- 可以在auto语句声明多个变量，但是一条声明语句只能有1个基本数据类型，因此多个变量必须拥有相同的基本数据类型

#### 通过引用初始化，编译器会以引用对象的类型作为auto的类型

```c++
int i = 0, &r = i;
auto a = r;
// 编译器会将a定义为int类型
```

#### auto一般会忽略顶层const，保留底层const

```c++
const int i = 1, &r = i;
auto b = i;		// b是int类型(顶层const被忽略)
auto c = &i;	// c是指向const int的引用(底层const被保留)
```

#### 如果顶层const，可通过const明确指出

```c++
const auto f = i;	// f是const int
```



### decltype类型指示符

- 分析并返回表达式的类型，不计算表达式的值，并将该类型用于声明/定义变量

  ```c++
  decltype(f()) sum = x;
  // 将sum定义为f()函数返回值的类型, 编译器并不实际调用函数f
  ```

#### decltype返回的类型包含顶层const和引用

- decltype使用的表达式为一个变量时，将返回该变量的类型（包括顶层const和引用在内）

  ```c++
  const int i = 0, &j = i;
  decltype(i) x = 0;		// x的类型是const int
  decltype(j) y = x;		// y的类型是const int&
  ```

#### decltype和引用

- 解引用指针可以得到指针指向的对象，`decltype(*p)`将得到该指针指向对象的引用类型

  ```c++
  int i = 42, *p = &i;
  decltype(*p) c = i;
  // 变量c的类型为int&, 而非int
  ```

- 若decltype使用加上括号的变量，将得到引用类型

  ```c++
  int i = 1;
  decltype(i) d = i;		// d的类型为int
  decltype((i)) e = i;    // e的类型为int&
  ```

##### 赋值表达式的类型是引用

- 赋值表达式是一种会产生引用的表达式，引用的类型为左值的类型



## 2.6 自定义数据结构

- 类定义最后加上分号

  ```c++
  struct Sales_data {
    	std::string book_no;
      unsigned units_sold = 0;
      double revenue = 0.0;
  };
  // 此处的分号记得加上
  ```

### 类定义

- 通常定义在与类名相同的头文件中，如`Sales_item`类可以放在`Sales_item.h`头文件中，

### 预处理器

- 确保头文件多次包含仍能安全工作的常用技术是**预处理器**
- 遇到`#include`会用指定的头文件内容代替`#include`

#### 头文件保护符

- `#define`指令把一个名字设定为预处理变量，用作头文件保护时，**一般以头文件名字构建保护符，且预处理变量名字全部大写**
- `#ifdef`当且仅当变量 已定义时为真，`#ifndef`当且仅当变量未定义时为真，一旦为真代码将继续执行直至遇到`#endif`指令为止

```c++
#ifndef SALES_DATA_H
#define SALES_DATA_H
#include <string>
struct Sales_data {
    std::string book_no;
    unsigned units_sold = 0;
    double revenue = 0.0;
};
#endif
// 预处理变量SALES_DATA_H保证了该头文件仅被包含一次
```

