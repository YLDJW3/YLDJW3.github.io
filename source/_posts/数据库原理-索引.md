---
title: 数据库原理-索引
date: 2022-03-10 23:54:04
tags: 
    - 数据库
    - 面试
mathjax: true
categories: OS 
---

数据库索引知识点

<!--more-->

# Basic

- 引入

  如果我们想在A市范围内寻找**名为张伟且年龄为98岁**的男子，我有一个包含A市所有人信息的登记表

  - 假如该登记表杂乱无章，那只能从头开始核对登记表的每个人，直到找到符合的人的信息`O(N)`
  - 如果该登记表按名字拼音顺序排列，则可以快速地定位到Z开头的部分，找到张姓的部分，并找到张伟，然后逐个核对直到找到符合的人的信息`O(logN)`
  - 如果翻动登记表时，突然掉出了一张纸，里面记录了A市所有年龄为98岁的人，在登记表中的页号与行号，而且总共只有10个人年龄是98岁，则我可以非常迅速地分别找到这10个人的信息，并找到张伟`O(C)`

- 索引产生的**原因**

  许多时候，查询只涉及文件的一小部分记录，如

  ```sql
  SELECT * FROM t WHERE name="Amy"
  ```

  倘若为此搜寻数据库的每一条记录，则查询效率低下，因此引入了索引

- 索引的**作用**

  建立记录的属性或属性集到记录之间的映射关系，可以通过某个属性或某几个属性组成的属性集快速定位到具有此属性 (集) 值的记录

- 索引的**搜索码**

  用于在文件中查找记录的属性或属性集。如果一个文件上有多个索引，则它有多个搜索码

- 索引的**种类**
  - **顺序索引**：基于**值的顺序**排序
  - **散列索引**：基于将值平均分布到若干**桶**中，一个值所属的桶是由**散列函数**决定的

- 索引的**评价标准**
  - 支持的访问类型
  - 访问时间
  - 插入时间
  - 删除时间
  - 空间开销

# 顺序索引

- **顺序索引**：按照排好的**顺序存储搜索码的值**，并将每个搜索码与包含该搜索码的记录关联起来
- **聚集索引/主索引**：搜索码定义了文件的次序
- **非聚集索引/辅助索引**：搜索码指定的次序与文件的排列次序不同的索引
- **索引项或索引记录**：由一个**搜索码值**和**指针**组成，指针指向具有该搜索码的一个或多条记录，指针由\<磁盘块标识，块内偏移量>组成

## 稠密索引与稀疏索引

- **稠密索引**：每个搜索码值都有一个索引项

- **稀疏索引**：只有部分搜索码值有索引项，索引是聚集索引时才能使用稀疏索引

- 比较

  - **稠密索引**的查找**速度更快**
  - **稀疏索引**占用的**空间更小**，所需的插入和删除时的维护开销也较小

- 常用方案

  **为每个块建立一个索引项的稀疏索引**，因为查询的开销集中在把块从磁盘读入内存，而把块读入内存后扫描的开销较小

## 多级索引

- 索引的空间开销问题

  假如数据库元组较多，即使使用每个块建立一个索引项的稀疏索引，仍然占用较大的空间

- 引入**多级索引**，即在**内层索引**基础上，建立**外层索引**

- 多级索引形成了树形结构

## 索引更新

- 索引什么时候更新

  文件中有**记录插入或删除**时，**每个索引**都必须更新

  文件中有**记录被更新**时，**搜索码属性受影响的任何索引**也必须更新

  记录的更新可以转换为紧接着的索引的删除和插入操作，因此我们只需考虑索引的删除和插入操作

- **插入一条记录**

  - 稠密索引
    - 如果搜索码值未出现在索引中，则在索引中适当的位置插入带有该搜索码值的索引项
    - 如果索引项存储指向具有相同搜索码值的所有记录的指针，则系统在索引项中增加一个指向新纪录的指针
    - 索引项存储一个仅指向具有相同搜索码值的第一条记录的指针，则把待插入的记录放到具有相同搜索码值的其他记录后

  - 稀疏索引，假设索引为每个块保存一个索引项
    - 如果系统创建了一个**新的块**，则将出现在新块中的**第一个搜索码值插入索引中**
    - 如果新插入的记录具有它在块中的最小搜索码值，则**更新指向该块的索引项**
    - 否则，索引无需改动

- 删除一条记录

  - 稠密索引

    - 如果所删除的记录是具有该搜索码值的唯一记录，则从索引中删除具有该搜索码的索引项
    - 如果索引项存储指向具有相同搜索码值的所有记录的指针，则系统在索引项中删除指向该纪录的指针
    - 如果索引项存储一个仅指向具有相同搜索码值的第一条记录的指针，如果待删除的记录是第一条记录，则更新索引项使其指向下一条记录

  - 稀疏索引

    - 如果索引中并不包含具有待删除记录搜索码值的索引项，则索引不必改动

    - 如果被删除的记录是具有该搜索码的唯一记录，则系统用下一个记录的搜索码值的索引记录替换相应的索引记录，如果下一个记录已经有索引项，则直接删除索引项
    - 如果被删除的记录并非具有该搜索码的唯一记录，则更新索引项使其指向具有该搜索码的下一条记录

## 辅助索引



## 多码索引

- 搜索码的属性可以不止一个，包含多个属性的搜索码称为复合搜索码

## 顺序索引的缺点

- 随着文件增大，**索引查找**的性能和数据**顺序扫描**的**性能都会下降**



# B+树索引文件

## B+树的结构

- 叶节点的结构
  - 最多包含n-1个搜索码值，和n个指针，指针$P_i$指向具有搜索码值$K_i$的一条文件记录$(1\leq i \leq n-1)$
  - 最多包含n-1个搜索码值，最少包含$\lceil (n-1)/2 \rceil$个搜索码值
  - 节点内的搜索码值有序存放
  - 如果两个叶节点$L_i$和$L_j$满足$i \lt j$，则$L_i$内的每个搜索码值都小于$L_j$内的每个搜索码值
  - 指针$P_n$指向按顺序排列的**下一个叶节点**
- 非叶节点的结构
  - 至多包含n个指针，至少包含$\lceil n/2 \rceil$个指针
  - 每个指针都指向另一个节点
  - 一个节点中的指针数称为该节点的扇出 fanout
  - 对于一个包含m个指针的非叶节点
    - 指针$P_i(2\leq i \leq m-1)$指向的子树所包含的搜索码值均满足$K_{i-1} \leq k \lt K_i$
    - 指针$P_m$指向搜索码值大于等于$K_i$的子树
    - 指针$P_1$指向搜索码值小于$K_1$的子树

- 根节点的结构
  - 根节点包含的指针数可以小于$\lceil n/2 \rceil$
  - 除非整棵树只有1个节点，否则根节点至少拥有2个指针

- B+树是**平衡**的

  从**根**节点到每个**叶**节点的**路径具有相同长度**

- 非唯一搜索码的处理

  如果关系r的搜索码$a_i$属性并非唯一，则建立索引时使用唯一复合搜索码$(a_i,A_p)$代替$a_i$建立索引，其中$A_p$是关系$r$的主码或保证唯一性的任何一组属性

## B+树的查询

- 单点查询

- 范围查询

- 查询时间复杂度
  $$
  \lceil log_{\lceil n/2 \rceil }(N)\rceil
  $$

- 节点规模

  典型的节点规模选取为和磁盘块一样大，通常为4KB

  假如搜索码大小为32字节，指针大小为8字节，则n可取100。当文件中包含100万个搜索码值时，只需要查找$\lceil log_{\lceil n/2 \rceil }(N)\rceil=4$

- 非唯一搜索码

  假设要在非唯一搜索码$a_i$上建立索引，则我们会在唯一复合搜索码$(a_i,A_p)$上建立索引

  如果我们想查找具有搜索码值$v$的所有记录，则我们执行一个从$(v,-inf)$到$(v,inf)$的范围查询

## B+树的更新

- 对记录的更新可建模为对旧纪录的删除，后接对新纪录的插入，因此仅考虑插入和删除的情况
- 假设**没有节点拆分与合并**
  - **插入**：使用和查找同样的技术，找到搜索码出现的叶节点，在叶节点中插入一项，使得插入后搜索码仍然有序
  - **删除**：使用和查找相同的技术，找到包含待删除搜索码的叶节点，如果包含多个相同搜索码值的项，则遍历直到找到指向待删除记录的项，移除该项，并将右边的所有项都左移一个位置，以便在删除后不留下空隙

### B+树的插入

- **叶节点拆分**

  假如待插入的叶节点已经具有n-1个搜索码，则必须进行拆分

  前$\lceil n / 2 \rceil$个搜索码保留在原来的节点，剩余节点加入新拆分的节点

  将新拆分节点的第一个搜索码加入原叶节点的父节点

  如果该父节点也满了，则需要进行拆分，该过程将从叶节点向根节点进行

  最坏情况下，根节点也要拆分，则树的深度增加了

- **非叶节点拆分**

  加入非叶节点原来具有n-1个搜索码，则需要进行拆分

  将前$\lceil (n + 1)/2 \rceil$个指针及它们之间的搜索码插入节点P

  将剩余指针及它们之间的搜索码插入新节点P'

  令K‘’为P的最后一个指针，与P'第一个指针之间的搜索码值

  将K''插入P的父节点中

### B+树的删除

