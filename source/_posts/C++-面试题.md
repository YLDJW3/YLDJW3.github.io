---
title: C++-面试题
date: 2022-02-22 15:39:30
tags:
    - C++
    - 面试
categories: C++
mathjax: true
---

**C++常考面试题总结**

<!--more-->

# 基本语法

## static的作用

- **修饰普通变量**，修改变量的存储区域和生命周期，存储在静态区域，生命周期在main函数运行前分配空间并初始化，程序执行结束时才销毁，若未指定初始值则执行值初始化
- **修饰普通函数**，表明函数的作用范围仅在定义该函数的文件内使用
- **修饰成员变量**，该类的所有对象共享一个成员变量，且无需生成对象也可访问该成员
- **修饰成员函数**，无需生成对象也可以访问该函数，但static成员函数不能访问非静态成员

## this指针

- **this指针的值**：对象调用成员函数时，先将**对象的地址赋给this指针**，然后调用成员函数。成员函数存取数据成员时，都隐式地使用this指针
- **this指针的const类型**：this指针被隐式地声明为顶层const，因此在成员函数中不能改变this的值。特别地，如果成员函数使用了const限定符，则this指针还具有底层const，即该成员函数不能修改数据成员
- **this是一个右值**：不能取得this的地址

## 引用与指针的区别

- **初始化**：引用必须初始化，指针不必
- **改变**：引用初始化后不能改变，指针可以改变所指向的对象

## 重载与重写的区别

- **重载**：指同名的函数具有不同的形参列表（数量不同或类型不同）
- **重写**：指派生类堆基类的虚函数进行重新定义override

## C++的显式类型转换

- static_cast：**非多态**类型的转换，通常用于转换数值数据类型
- dynamic_cast：用于**多态**类型的转换，执行运行时类型检查，只适用于**指针或引用**，可以实现继承体系中的向上或向下转换
- const_cast：移除const特性
- reinterpret_cast

## 顶层const和底层const的区别

- **底层const**: const右结合修饰的为类型或*，则为底层const，表示指针所指向的对象是个常量
- **顶层const**: const右结合修饰的为标识符，则为顶层const，表示指针本身是个常量

```c++
int i = 3;
const int* ptr = &i;	// 底层const
int* const ptr = &i;	// 顶层const
```

## 引用类型作为函数返回值

- **不能返回局部变量的引用**，因为在函数执行完后局部变量被销毁
- **不能返回new分配的内存的引用**，因为导致所指向的空间无法释放，造成内存泄漏

## sizeof

- sizeof(数组)，得到整个数组所占空间的大小
- sizeof(指针)，得到存放指针本身所占空间的大小

# 内存管理

## 栈区和堆区的区别

### 申请方式

- **栈区**：由编译器分配释放，存放函数参数值、局部变量值
- **堆区**：由程序员使用new/delete或malloc/free分配释放

### 申请后系统的响应

- **栈区**：若栈的剩余空间大于所申请空间，则系统为程序提供内存，否则报告异常提示栈溢出
- **堆区**：操作系统有一个**记录空闲内存地址的链表**，当系统收到程序申请时，遍历该链表以寻找第一个空间大于所申请空间的堆结点，将该节点从空闲节点链表删除，并将该节点的空间分配给程序。且找到的堆节点大小不一定正好等于申请的大小，系统会自动将多余部分重新让入空闲链表

### 申请大小的限制

- **栈区**：Windows的栈是向低地址扩展的数据结构，是一块连续的内存空间，而栈顶的地址和栈的最大容量是编译时确定的，如果申请的栈空间超过了栈的剩余空间，将提示overflow
- **堆区**：堆是向高地址扩展的数据结构，是不连续的内存区域，因为系统用链表来存储空闲内存地址，堆的大小受限于计算机系统中有效的虚拟内存

### 堆区和栈区的存储内容

- **栈区**：在**函数调用**时，首先将主函数中函数调用语句的下一条可执行语句的地址入栈，然后是函数的各个参数，再到函数的局部变量。函数调用结束后，局部变量先出栈，函数参数出栈，然后栈顶指针指向最开始存储的下一条指令的地址，程序从该点开始继续运行
- **堆区**：在堆的头部用一个字节存放堆的大小，堆中内容由程序员管理

## C++的内存分为哪几个区？

- **栈区**
- **堆区**
- **全局/静态存储区**
- **常量存储区**
- **程序代码区**

## new/delete、malloc/free的区别

- **分配内存的位置**：new分配自由存储区的内存，malloc分配堆区的内存
- **内存分配成功的返回值**：new返回指向所创建对象的指针，malloc返回void*指针，指向分配内存的起始地址
- **内存分配失败**：new分配失败抛出`bad_alloc`异常，malloc分配失败返回NULL
- **分配内存大小**：new由编译器根据创建对象类型计算得到，malloc需要显式指定字节数
- **处理数组**：new[]，malloc需要用户根据数组大小计算内存大小
- **功能**：new/delete除了分配/释放内存外，还会创建/销毁对象

## delete[]如何确定指针指向的数组的大小

- **数组大小**：使用new[]创建对象数组时，编译器会多分配4个字节的内存空间，用于存储数组大小，delete[]时取出该数组大小即可

## 内存对齐的原则和作用

- **原则**：从0位置开始存储，变量存储的起始位置是变量大小的整数倍，struct的大小是其最大元素大小的整数倍

- **作用**

  适应某些无法访问任意地址的硬件平台

  CPU在读取内存时是按块进行读取的，内存对齐可提高CPU的内存访问速度

## delete this合法吗

- **作用**：delete this允许对象销毁自己

- 满足以下条件时合法

  **new分配**：this指向的对象是通过new分配的

  **不再使用this指针**：执行delete this的成员函数是最后一个使用this的成员函数，保证该成员函数在delete this后没有使用this的语句

  **不再访问数据成员和虚函数**：执行delete this后不能再访问该对象的任意数据成员或调用虚函数，因为**delete this会回收对象的数据成员、虚表指针等，但不包含函数代码**

## 如何定义一个只能在堆上/栈上生成对象的类

- **只能在堆上**：将**析构函数设置为私有**。因为C++是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性， 若析构函数不可访问则不能在栈上创建对象
- **只能在栈上**：将new和delete重载为私有。在堆上生成对象，使用new在堆上分配内存并调用构造函数生成对象，若new设置为私有则无法在堆上生成对象

# 类相关

## 面向对象三大特性

- **封装**
- **继承**
- **动态绑定**

## 动态绑定的概念

- **概念**：在运行时（非编译器）判断所引用对象的实际类型
- **发生的时机**：通过基类的**引用或指针**调用**虚函数**时，发生动态绑定。C++动态绑定是通过虚函数实现的，而虚函数调用是通过虚函数表实现的

## 什么是虚函数？什么是纯虚函数？

- **虚函数**：基类在声明成员函数时，如果希望派生类覆盖该成员函数，提供派生类自己的版本，则通过关键字`virtual`将其声明为虚函数，派生类可以覆盖虚函数
- **动态绑定**：如果通过基类的指针、引用调用虚函数时，将发生动态绑定，具体执行哪个类中的虚函数版本，将由该指针、引用所指向的对象的类型决定（动态类型），也称为运行时绑定
- **纯虚函数**：声明虚函数时，如果在形参列表后加上`=0`，则该成员为纯虚函数
- **纯虚函数的作用**：纯虚函数的目的是提供接口，该成员在基类中是没有意义的，各个派生类应该提供自己的版本
- **抽象基类**：含有纯虚函数的基类，被称为抽象基类，抽象基类不可以创建对象
- **抽象类不能创建对象**：如果继承了抽象基类的派生类，没有覆盖所有纯虚函数，则它仍然是抽象类，不能创建对象
- **抽象类不能作为函数的参数，不能作为函数返回类型**
- **可以声明抽象类指针，可以声明抽象类的引用**

## 什么函数不能作为虚函数

- **普通函数**（非类成员函数）
- **静态成员函数**
- **构造函数**：调用构造函数时，对象仍未创建，无法取得对象的虚表指针，从而无法进行虚函数调用
- **内联函数**

## 虚函数的实现机制

- **虚函数表**：通过虚函数表实现，虚函数的地址保存在虚函数表中，虚函数表在**编译阶段创建**
- **虚表指针**：类的对象的内存空间中，保存了虚表指针，它将指向类对应的虚表，虚表指针存放在对象的内存空间中最前面的位置
- **类的对象共享一个虚函数表**：每个类拥有一张虚函数表，该类的对象的虚表指针都指向该虚函数表

## 单继承和多继承的虚函数表结构

- 待补充

## 如何禁止构造函数的使用

- 构造函数的形参列表后加上`=deleted`

## 什么是类的默认构造函数

- 如果构造函数不接受任何形参，或为每个形参都提供了默认实参，则为默认构造函数
- 如果类没有定义任何默认构造函数，则编译器将合成默认构造函数

## 构造函数、析构函数是否需要定义成虚函数？为什么?

- **构造函数不应定义为虚函数**，因为虚表指针由对象持有，构造函数执行时对象仍未创建，无法调用虚函数
- **析构函数定义为虚函数**，因为基类的引用或指针可能指向派生类对象。调用`delete p`销毁该对象时，只有定义为虚函数，才会根据对象的动态类型调用相应版本的析构函数，否则**该对象只有基类部分的内存被释放**，将产生未定义的行为

## 析构函数能抛出异常吗

- **不能**
- **析构函数抛出异常，则异常点后的程序不会执行**，导致析构函数异常点后的释放资源操作无法进行，可能造成**资源泄露问题**
- 异常发生时，通常会调用已构造对象的析构函数来释放资源，若此时析构函数本身也抛出异常，则前一个异常尚未处理又有新的异常，会造成**程序崩溃的问题**

## 为什么拷贝构造函数必须接受引用

- 因为将对象值传参或返回时，将发生拷贝
- 如果拷贝构造函数接受值传递，会导致无限递归

## C++类对象的初始化顺序

- 按类派生列表依次调用各个类的构造函数
- 按成员声明顺序初始化各个成员
- 执行构造函数的函数体

## 深拷贝和浅拷贝的区别

- 如果一个类拥有资源，该类的对象进行复制时，若资源重新分配则为深拷贝；否则为浅拷贝
- **深拷贝**：该对象和原对象占用不同内存空间，既拷贝存储在栈空间的内容，又拷贝存储在堆空间的内容
- **浅拷贝**：该对象和原对象占用同一块内存空间，仅拷贝类中位于栈空间的内容
- **深拷贝的使用**：如果成员变量中有指针变量则最好使用深拷贝。否则，当其中一个对象删除后，该指针指向的内存空间会被释放，另一个对象指向的就是垃圾内存

## 使用初始化列表和在构造函数中初始化的区别

- 若在构造函数中初始化，则实际上会先对成员变量执行默认初始化，再对其赋值。对于类类型对象，则**先调用默认构造函数**执行默认初始化，再执行**拷贝赋值操作**

# 其他

## C++源文件从文本到可执行文件经历的四个阶段

- **预处理阶段**，对预编译语句、预处理变量等进行分析和替换，生成预编译文件（`.i`文件）
- **编译阶段**，对预编译文件进行汇编，得到汇编文件（`.s`文件）
- **汇编阶段**，对汇编文件转换为机器码，生成可重定位目标文件（`.o`文件）
- **链接阶段**，将多个目标文件及所需的库连接成最终的可执行目标文件（`.exe`文件）

## 链接的两种方式

- **静态链接**：代码从所在的静态链接库拷贝到最终的**可执行程序**中，在该程序被执行时，这些代码会被装入到进程的虚拟地址空间中

- **动态链接**：代码放在**动态链接库**或共享对象的某个目标文件中，链接程序只在最终的可执行程序中记录共享对象的名字等信息。程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址空间

- 静态链接特点

  **浪费空间**，每个可执行程序都有目标文件的一个副本

  **更新困难**，对目标文件的更新将导致程序的重新编译和链接生成可执行程序

  **执行速度快**

- 动态链接特点

  **节省内存**

  **更新方便**

  **性能损失**

# STL

## C++容器类的底层实现

- vector用数组实现
- list、forward_list用链表实现
- stack、queue用数组或链表实现
- deque用一个中央控制器和多个缓冲区实现
- priority_queue用二叉大根堆实现
- unordered_set、unordered_set用哈希表实现
- set、map用红黑树实现

## 红黑树

- 特性

  每个节点要么是黑色，要么是红色

  根节点和叶节点都是黑色节点

  红色节点的子节点必定是黑色节点

  从根节点到叶节点的每条路径上的黑色节点数量相等

  从根节点到叶节点的最长路径不超过最短路径长度的两倍

- 插入

  插入的节点初始时涂为红色

  **无需调整**：父节点为黑色

  **需要调整**：父节点为红色

  - **空树**的插入，则插入根节点，重涂为黑色

  - 父节点为红色，**uncle为红色**，recolor
  - 父节点为红色，uncle为黑色，且为**三角形**，则在父节点上旋转变为直线
  - 父节点为红色，uncle为黑色，且为**直线**，在祖父节点上旋转

