---
title: 计网-应用层
date: 2022-02-23 14:35:16
tags: 
    - Computer Network
    - 面试
mathjax: true
categories: Computer Network
---

**计网应用层重要知识总结**

<!--more-->

# 1 应用层

## 1.1 应用层协议原理

### 网络应用程序体系结构

- 应用程序体系结构常用的两种结构是
  - 客户-服务器体系结构
  - 对等（P2P）体系结构
- **客户服务器体系结构**中，有一个总是打开的**服务器**，它服务于其他**客户**主机的请求
  - **客户**之间**不直接通信**
  - 有一个**总是打开**的服务器，它具有**固定的、周知的地址（IP地址）**
  - **Web、FTP、Telnet、电子邮件**等都具有客户服务器结构
- **P2P体系结构**中，间断连接的主机对之间直接通信，这些主机称为**对等方（peer）**
  - P2P体系结构的特性是**自扩展性**
  - 文件共享（**BitTorrent**）、因特网电话和视频会议（**Skype**）等引用采用了P2P体系

### 进程通信

- 运行在不同端系统上的进程之间通信，主要通过在计算机网络中交换**报文（message）**
- 客户和服务器进程
  - 网络应用程序由成对的进程组成，一个称为**客户进程**，一个称为**服务器进程**
  - 对于**客户服务器体系**，**服务器端系统的进程**为服务器进程，**客户端系统的进程**为客户进程
  - 对于**P2P体系**，如文件共享应用BitTorrent，**下载文件**的进程为客户进程，**上传文件**的进程为服务器进程
  - 在一对进程的通信会话场景中，我们把**发起通信的进程**标识为**客户**，在会话开始时**等待联系的进程**标识为**服务器** 

- 进程与计算机网络之间的接口——**套接字**
  - 进程通过套接字软件的接口向网络发送报文，从网络接收报文 
  - 套接字是同一台主机内应用层与运输层之间的接口
  - 套接字也称为应用程序和网络之间的应用程序编程接口（API）
- 进程寻址
  - 发送报文时，为了标识接收进程，需要定义
    - **目的主机的地址**
    - 目的主机中指定**接收进程的标识符**
  - 在因特网中通过**IP地址**标识主机，通过**目的地端口号**标识接收主机的进程
  - 已经给流行的网络应用分配了**特定的端口号**，如Web服务器为80、邮件服务器进程为25

### 可供应用程序使用的运输服务

- 运输层协议提供的服务
  - 可靠数据传输
  - 吞吐量
  - 定时
  - 安全性
- **可靠数据传输**
  - 确保应用程序的一端发送的数据**正确、完全地**交付给应用程序的另一端，如果运输层协议提供这样的服务，则认为提供了可靠数据传输
  - 如果运输层协议不提供可靠数据传输，该协议可能被容忍丢失的应用使用，如多媒体应用等
- **吞吐量**
  - 运输协议能确保可用吞吐量总是至少为`r`bits
  - 具有吞吐量要求的应用称为带宽敏感的应用，反之称为弹性应用
- **定时**
  - 运输协议保证客户端输入套接字的每个bit到达接收方的套接字不迟于`t`ms
  - 交互式实时应用程序需要定时服务，如因特网电话等
- **安全性**
  - 运输协议能够**加密**由发送进程传输的所有数据，在接收主机中，运输协议先解密数据再将其交付给接收进程

### 因特网提供的运输服务: UDP和TCP

- TCP
  - **面向连接**的服务
  - **可靠的数据传输服务**
  - **拥塞控制**机制
  - TCP的加强版本：**安全套接字层SSL**，支持加密、数据完整性和端点鉴别
- UDP
  - 不提供不必要服务的轻量级运输协议，仅**提供最小服务**
  - 提供一种**不可靠数据传输**，并不保证该报文能到到接收进程，且可能是乱序到达的
  - 没有拥塞控制机制
- 总结
  - TCP提供可靠数据传输，SSL提供安全性
  - 不提供定时、吞吐量服务
  - 实际上，TCP将尽可能地减小时延、提高带宽，使得网络电话、流式音视频传输等应用能正常工作，但TCP**不对定时、吞吐做任何保证**

### 应用层协议

- 应用层协议定义了运行在不同端系统的应用程序如何传递报文，包含
  - 交换的**报文类型**
  - 各种报文类型的**语法**，如**各个字段**
  - 字段的**语义**，即字段中**信息的含义**
  - 确定进程**何时及如何发送**报文
- 一些应用层协议由**RFC文档**定义，位于公共域中
- 一些专用应用层协议，如Skype使用的协议
- 重要的网络应用，及其应用层协议
  - **Web，HTTP**
  - **文件传输，FTP**
  - **电子邮件，SMTP**
  - **目录服务，DNS**
  - **流式视频，HTTP**
  - **远程终端访问，Telnet**

## 1.2 Web和HTTP

### 1.2.1 非持续连接和持续连接

#### 非持续连接

- **每个请求/响应对**经过一个**单独的TCP**连接发送
- **往返时间RTT (Round-Trip Time)**，定义为一个短分组从**客户到服务器**然后**再返回客户**所花费的时间
- **每一个对象**经受**两倍RTT**的交付时延，一个RTT用于**创建TCP**，另一个RTT用于**请求和接收一个对象**

#### 持续连接

- **所有**的请求及响应经过**相同的TCP**连接发送
- HTTP默认采用持续连接
- 如果一条连接经过一定时间间隔（**可配置超时间隔**）仍未被使用，则HTTP服务器**关闭该连接**

### 1.2.2 HTTP报文格式

#### HTTP请求报文

```http
GET http://www.example.com/ HTTP/1.1
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
Cache-Control: max-age=0
Host: www.example.com
If-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMT
If-None-Match: "3147526947+gzip"
Proxy-Connection: keep-alive
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 xxx

param1=1&param2=2
```

- 第一行是包含了**请求方法**、**URL**、**协议版本**；
- 接下来的多行都是请求**首部 Header**，每个首部都有一个首部名称，以及对应的值。
- 一个**空行**用来分隔首部和内容主体 Body
- 最后是请求的**内容主体**

##### URL和URN组成了URI

- HTTP 使用 **URL**（ Uniform Resource Locator，**统一资源定位符**）来定位资源，它是 **URI**（Uniform Resource Identifier，**统一资源标识符**）的子集，URL 在 URI 的基础上增加了定位能力。URI 除了包含 URL，还包含 **URN**（Uniform Resource Name，**统一资源名称**），它只是用来定义一个**资源的名称**，并不具备定位该资源的能力。例如 urn:isbn:0451450523 用来定义一个书籍名称，但是却没有表示怎么找到这本书

#### HTTP响应报文

```http
HTTP/1.1 200 OK
Age: 529651
Cache-Control: max-age=604800
Connection: keep-alive
Content-Encoding: gzip
Content-Length: 648
Content-Type: text/html; charset=UTF-8
Date: Mon, 02 Nov 2020 17:53:39 GMT
Etag: "3147526947+ident+gzip"
Expires: Mon, 09 Nov 2020 17:53:39 GMT
Keep-Alive: timeout=4
Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT
Proxy-Connection: keep-alive
Server: ECS (sjc/16DF)
Vary: Accept-Encoding
X-Cache: HIT

<!doctype html>
<html>
<head>
    <title>Example Domain</title>
	// 省略... 
</body>
</html>
```

- 第一行包含**协议版本**、**状态码**以及**描述**，最常见的是 `200 OK` 表示请求成功了
- 接下来多行也是**首部内容**
- 一个**空行**分隔首部和内容主体
- 最后是响应的**内容主体**

#### 请求方法

- 请求方法包括**GET、POST、HEAD、PUT、DELETE**等
- **请求对象**时使用**GET**，**提交表单**时使用**POST**
- 若请求对象时使用**HEAD**，则服务器以HTTP报文响应，但**不返回请求对象**
- **PUT**允许用户**上传对象**到指定的Web服务器上的指定路径
- **DELETE**允许用户**删除**Web服务器上的**对象**
- 其他方法
  - **PATCH**对资源进行部分修改
  - **OPTIONS**查询指定URL支持的方法
  - **CONNECT**要求与代理服务器通信时建立隧道
  - **TRACE**将通信路径返回给客户端

#### 状态码及描述短语

- **1XX**，**信息性**状态码，接收的请求正在处理
  - `100 Continue`，表明到目前为止一切正常
- **2XX**，**成功**状态码，请求正常处理完毕
  - `200 OK`，表明请求成功
  - `204 No Content`，请求成功处理，但是返回的响应报文不包含实体的主体部分
- 3XX，**重定向**状态码
  - `301 Moved Permanently`，对象已被永久转移
  - `302 Found`，临时性重定向，通知浏览器本次返回的是一个**资源文件地址**，需要浏览器**根据这个地址**自动发起请求来**索要这个资源文件**
  - `303 See Other`，与302有相同功能，但303明确要求客户端应采用GET方法获取资源
  - `304 Not Modified`，如果请求报文首部包含一些条件，若该条件不满足则返回304
- 4XX，**客户端错误**状态码
  - `400 Bad Request`，通用差错代码，请求报文存在语法错误
  - `403 Forbidden`，请求被拒绝。
  - `404 Not Found`，请求的文档不在服务器上
- 5XX，**服务器错误**状态码
  - `500 Internal Server Error`，服务器正在执行请求时发生**错误**
  - `503 Service Unavailable`，服务器暂时处于**超负载**或正在进行**停机维护**，现在无法处理请求

#### HTTP首部

- [LeetBook-HTTP首部](https://leetcode-cn.com/leetbook/read/tech-interview-cookbook/or1yu1/)

### 1.2.3 Cookies

#### 用途

- **HTTP服务器**是**无状态**的
- 如果Web站点希望**识别用户**，则可以使用Cookie
  - **限制用户访问**
  - 希望把**内容**与**用户身份**联系起来
  - 对用户的浏览行为进行**跟踪**

#### 创建过程

- HTTP服务器发送的**响应报文**包含**Set-Cookie首部行**，且Web站点的**后端数据库的一个表项**会包含该用户的Cookie
- 浏览器得到响应报文后，**保留Cookie文件**，由**浏览器管理**
- 此后浏览器对同一个服务器发送**请求报文**时，会包含**Cookie首部行**

#### 分类

- **会话期Cookie**：浏览器关闭后被自动删除
- **持久性Cookie**：指定过期时间或有效期，在期限之前该Cookie都会存在

#### 争议

- 使用Cookie被认为是对用户**隐私的侵害**

#### Secure

- **标记为Secure**的Cookie只能通过**被HTTPS协议加密的请求**发送给服务端
- 即使设置了Secure标记，敏感信息也不应该通过Cookie传输，因为即使Secure标记无法提供确实的安全保障

#### Session

- 用户信息除了通过Cookie存储在用户浏览器，也可**利用Session存储在服务器端**，存储在服务器端的信息**更加安全**
- Session可以存储在**服务器**上的**文件、数据库或内存**中，也可将Session存储在**Redis这种内存型数据库**中
- 使用Session维护用户登陆状态
  - 用户进行登录，提交包含用户名和密码的表单，放入HTTP请求报文
  - 服务器验证该用户名和密码，若正确则**把用户信息存储在Redis**，其中的**Key称为Session ID**
  - 服务器返回的HTTP**响应报文**的**Set-Cookie首部**字段包含这个**Session ID**，客户端收到响应报文后将**Session ID**存入浏览器管理的**Cookie中**
  - 客户端对同一服务器进行请求时，会**包含该Cookie值**，服务器收到后**提取Session ID**，从**Redis中取出用户信息**，继续之前的业务操作
- Session ID本身也存在安全性问题，不能生成容易被猜到的值，而且应该经常重新生成，在对安全性要求极高的场景还应该配以短信验证码等方式

#### 浏览器禁用Cookie

- 此时无法使用 Cookie 来保存用户信息，**只能使用 Session**
- 除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 **URL 重写技术**，将 **Session ID 作为 URL 的参数**进行传递。

#### Cookies和Session的对比

- **Cookie**存储在**客户端**（浏览器），**Session**存储在**服务器**
- **Cookie**只能存储**ASCII码字符串**，而**Session**可以存储**任何类型的数据**

### 1.2.4 Web缓存

- **Web缓存器**也叫**代理服务器**，它是能代表初始Web服务器满足HTTP请求的网络实体
- Web缓存器有自己的**磁盘存储空间**，并在存储空间中**保存**了**最近请求过的对象的副本**

- 可以配置浏览器的HTTP请求指向Web缓存器，此时浏览器请求资源的过程如下
  - 浏览器创建一个到Web缓存器的TCP连接，向Web缓存器发送一个HTTP请求报文
  - Web缓存器收到请求后检查本地是否存储了该对象的副本，如果有，则向浏览器通过HTTP响应报文返回该对象
  - 如果没有，则Web缓存器创建一个与该对象的初始服务器的TCP连接，发送HTTP请求报文以请求该对象
  - Web缓存器接收到**初始服务器的HTTP响应报文**，在本地存储空间**存储该对象的副本**
  - Web缓存器通过HTTP响应报文向用户浏览器返回该对象
- 此过程中，Web缓存器**同时担任了客户**（Web缓存器-初始服务器的TCP连接）、**服务器**（用户浏览器-Web缓存器的TCP连接）的角色

#### 优点

- 缓解服务器的压力
- 降低客户端获取资源的延迟，Web缓存器在地理位置上通常比初始服务器更近

#### 缓存的实现方法

- Web缓存器
- 除了Web缓存器外，客户端浏览器也可以进行缓存

#### HTTP进行缓存控制

- **HTTP/1.1**通过**Cache-Control首部字段**来控制缓存

- **禁止进行缓存**，no-store规定不能对请求或响应的任一部分进行缓存

  ```http
  Cache-Control: no-store
  ```

- **强制确认缓存**，no-cache规定Web缓存器必须先向初始服务器**验证缓存资源的有效性**，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应

  ```http
  Cache-Control: no-cache
  ```

- **私有缓存和公共缓存**

  - private指令规定资源作为**私有缓存**，只能被单独用户使用，一般存储在**用户浏览器**中

  ```http
  Cache-Control: private
  ```

  - public指令规定资源作为**公共缓存**，可悲多个用户使用，一般存储在**Web缓存器**中

  ```http
  Cache-Control: public
  ```

- **缓存过期机制**

  - max-age出现在**请求**报文，且缓存资源的缓存时间**小于该指令指定的时间**，那么就能**接受该缓存**
  - max-age出现在**响应**报文，表明缓存资源在代理服务器中**保存的时间**

  ```http
  Cache-Control: max-age=89313917
  ```

#### 缓存验证

- 使用**条件GET**，**缓存器**可以验证它保存的**对象副本是否最新的**

- 如果请求报文**使用GET方法**，且包含**`If-Modified-Since:`首部行**，则该HTTP报文是一个**条件GET请求报文**

- **缓存验证**的**详细过程**
  - 代理服务器接收初始服务器HTTP响应报文，并在本地存储空间保存对象的副本，该**HTTP响应报文的`Last-Modified:`首部行**包含了对象上次修改的时间信息
  - 之后，浏览器再次请求该对象，并经过代理服务器时，**代理服务器**向初始服务器发送HTTP请求报文，**包含`If-Modified-Since:`首部行**，**其值**为当前对象副本对应的HTTP响应报文的**`Last-Modified:`首部行的值**
  - 如果初始服务器中该对象此后**未被修改**，则它将通过HTTP响应报文告知代理服务器，并且**状态码为`304 Not Modified`**，**内容主体为空**
  - 如果初始服务器中该对象**已修改**，返回**带有该对象**的HTTP响应报文，状态码及描述为`200 OK`

### 1.2.5 HTTPS

#### HTTP存在的安全性问题

- HTTP 有以下安全性问题
  - 使用**明文**进行通信，内容可能会被**窃听**
  - **不验证**通信方的**身份**，通信方的身份有可能遭遇**伪装**
  - 无法证明**报文的完整性**，报文有可能遭**篡改**
- **HTTPS** 并不是新协议，而是让 **HTTP先和 SSL（Secure Sockets Layer）通信**，再由 **SSL 和 TCP 通信**，也就是说 HTTPS 使用了**隧道**进行通信
- 通过使用**SSL**，HTTPS具有了**加密**（防窃听）、**认证**（防伪装）和**完整性保护**功能（防篡改）

#### 加密

##### 对称密钥加密

- 加密和解密使用**同一密钥**
- 优点：运算速度**快**
- 缺点：**无法安全**地将密钥传输给通信方

##### 非对称密钥加密

- 又称公开密钥加密，加密和解密使用不同的密钥
- 公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以**使用公开密钥进行加密**，接收方收到通信内容后**使用私有密钥解密**

- **签名**：通信发送方使用**私有密钥进行签名**，通信接收方使用**公开密钥对签名进行解密**，能够判断签名是否正确
- 优点：**安全**性
- 缺点：运算速度**慢**

##### HTTPS采用的加密方式

- 使用**非对称密钥加密**方式，**传输**对称密钥加密方式所需的**Secret Key**，保证安全性
- 获取到Secret Key后，使用**对称密钥加密**方式进行**通信**，保证了效率

- **过程**（真实过程会更加复杂，这是简化的原理）
  - 浏览器向服务器发送请求，建立连接
  - 服务器向浏览器**发送公钥**
  - 浏览器生成**通信用密钥**，并通过**公钥加密**，得到**加密的通信用密钥**，发送给服务器
  - 服务器收到**加密后的通信用密钥**，用**私钥将其解密**，得到**通信用密钥**
  - 浏览器、服务器都有了通信用密钥，可以利用**对称密钥加密**方式进行**通信**

#### 认证

- 使用**证书**对通信方进行认证
- **数字证书认证机构（CA）**是客户端和服务端都信任的第三方机构
- 服务器运行人员向CA提出公开密钥的申请，CA在判明提出申请者的身份后，对已申请的公开密钥做**数字签名**，然后**分配这个已签名的公开密钥**，并将该**公开密钥放入公开密钥证书**后绑定在一起
- 进行HTTPS通信时，服务器把**证书发送给客户端**，客户端获得其中的**公开密钥**后，先用**数字签名进行验证**，如果验证通过则开始通信

![](1.png)

#### 完整性保护

- **SSL**提供**报文摘要**功能进行**完整性保护**
- **HTTP** 也提供了 **MD5 报文摘要**功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改
- **HTTPS** 的**报文摘要功能**之所以安全，是因为它**结合了加密和认证这两个操作**。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文

#### 缺点

- 因为需要进行**加密解密**等过程，因此速度会更**慢**
- 需要支付**证书授权**的高额**费用**

## 1.3 电子邮件协议

- 一个电子邮件系统由三部分组成：**用户代理**、**邮件服务器**以及**邮件协议**
  - **用户代理**允许用户**阅读、恢复、转发、保存和撰写报文**
  - **邮件服务器**形成电子邮件体系的核心，每个接收方在某个邮件服务器上拥有一个**邮箱**，邮箱管理和维护发送给它的报文
  - **邮件协议**包含**发送协议**和**读取协议**，发送协议常用 **SMTP**，读取协议常用 **POP3** 和 **IMAP**

- 一个**邮件发送**的典型过程
  - 从**发送方的用户代理**开始，传输到**发送方的邮件服务器**，传输到**接收方的邮件服务器**，被分发到**接收方的邮箱**，接收方从邮箱**读取报文**时需要提供用户名和口令
  - 发送方的邮箱必须处理接收方邮件服务器的故障，如果邮件不能交付到接收方的邮件服务器，**发送方的邮件服务器**将在**报文队列**中保持该报文，并在以后尝试**重新发送**。若一定时间后**仍然不成功**，发送方邮件服务器会**删除该报文**并以**电子邮件**的形式**通知发送方**

### SMTP

- **SMTP 只能发送 ASCII 码**，而互联网邮件扩充 **MIME 可以发送二进制文件**。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，**定义了非 ASCII 码的编码规则**
- **SMTP**由运行在**发送方邮件服务器**的**客户端**，和运行在**接收方邮件服务器**的**服务器端**组成，每台邮件服务器都**同时运行SMTP的客户端和服务器端**

### POP3

- **POP3** 的特点是只要**用户从服务器上读取了邮件，就把该邮件删除**。但最新版本的 POP3 可以不删除邮件

### IMAP

- **IMAP** 协议中**客户端**和**服务器**上的邮件保持**同步**，如果不手动删除邮件，那么**服务器**上的邮件也**不会被删除**。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。

## 1.4 因特网的目录服务（DNS）

### 1.4.1 DNS提供的服务

- **DNS**的两种含义
  - 一个由**分层的DNS服务器**实现的**分布式数据库**
  - 一个使得主机能够**查询分布式数据库**的**应用层协议**，DNS协议运行在**UDP**上，使用**53号端口**

- **域名系统（Domain Name System，DNS）**的主要任务是进行**主机名**到**IP地址**转换的**目录服务**
- DNS提供的**其他服务**
  - **主机别名**，有着复杂主机名的主机能拥有一个或多个别名。调用DNS可获得主机别名对应的主机规范名，以及主机IP地址
  - **邮件服务器别名**，邮件地址较为简单，但邮件服务器的主机名更为复杂，电子邮件应用程序调用DNS可对提供的主机名别名进行解析
  - **负载分配**，繁忙的站点通常冗余分布在多台服务器上，有着不同的IP地址。因同**一个规范主机名**会跟**一个IP地址集合**联系，当客户对映射到某个集合的名字发出DNS请求时，DNS服务器会**循环回答这些IP地址**以进行响应，从而**在多个服务器间循环分配了负载**

- **浏览器**请求某个URL时与**DNS服务器**的交互过程
  - 该浏览器所在的主机上也运行着**DNS客户端**
  - 浏览器从**URL**提取**主机名**，将其**传给DNS客户端**
  - **DNS客户端**向**DNS服务器**从发送**包含主机名的请求**
  - **DNS客户端**收到**回答报文**，包含对应于该主机名的**IP地址**
  - 浏览器接收到来自DNS的IP地址，并向该地址的端口号为80的HTTP服务器进程发起TCP连接

### 1.4.2 DNS工作原理概述

#### 分布式、层次数据库

- 大致来说，DNS服务器可分为**三种**
  - **根**DNS服务器，提供**TLD服务器的IP地址**
  - **顶级域（TLD）**DNS服务器，提供权威服务器的IP地址，每个**顶级域**（如com、org、net、edu和gov等）和所有**国家的顶级域**（如uk、fr、ca和jp等）都有顶级域服务器
  - **权威**DNS服务器，在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的DNS记录，他们可能实现自己的权威DNS服务器，或支付费用由服务提供商的一个权威DNS服务器完成

- **本地域名服务器**不属于上述的域名服务器的等级结构。当一个主机发出DNS请求报文时，这个报文就首先被送往该主机的本地域名服务器。本地域名服务器起着**代理**的作用，会将该报文转发到上述的域名服务器的等级结构中。**本地域名服务器离用户较近**，一般不超过几个路由器的距离，也有可能就在同一个局域网中

#### DNS域名解析过程

- 域名解析包含两种查询方式，分别是**递归查询**和**迭代查询**
- **递归查询**：如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户端的身份，向其他根域名服务器继续发出查询请求报文，即**替主机继续查询**，而不是让主机自己进行下一步查询
- **迭代查询**：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的**IP 地址**，要么告诉本地服务器**下一步应该找哪个域名服务器进行查询**，然后让**本地服务器**进行后续的查询
- 实践中，**从请求主机到本地域名服务器的查询是递归查询，而其余的查询是迭代查询**

![](2.png)

#### DNS缓存

- 在一个请求链中，如果某个**DNS服务器**接受一个DNS回答（某主机名到IP地址的映射），它能**将映射缓存到本地存储器中**
- 主机/主机名到IP地址不是永久的 ，DNS服务器会在**一段时间后丢弃缓存**的信息
- 不但在**本地域名服务器**中需要高速缓存，在**用户主机**中也很需要。许多用户主机在启动时从本地域名服务器下载域名和IP地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到域名时才向域名服务器查询。同理，主机也需要保持高速缓存中内容的正确性。

![](3.png)

## 1.5 文件传送协议FTP

- **FTP** 使用 **TCP** 进行连接，它需要**两个连接**来传送一个文件：
  - **控制连接**：服务器打开**端口号 21** 等待客户端的连接，客户端主动建立连接后，使用这个连接将**客户端的命令**传送给**服务器**，并传回服务器的应答
  - **数据连接**：用来传送一个**文件数据**

- 根据数据连接**是否服务器端主动建立**，FTP 有**主动**和**被动**两种模式：
  - **主动模式**：**服务器端主动建立数据连接**，其中**服务器端**的端口号为 **20**，**客户端**的端口号**随机**，但是必须大于 1024，因为 0~1023 是熟知端口号
  - **被动模式**：**客户端主动建立数据连接**，其中**客户端**的端口号**由客户端自己指定**，**服务器端**的端口号**随机**
- **主动模式**要求**客户端开放端口号给服务器端**，需要去配置客户端的防火墙
- **被动模式**只需要服务器端开放端口号即可，**无需客户端配置防火墙**。但是被动模式会导致**服务器端的安全性减弱**，因为开放了过多的端口号

## 1.6 动态主机配置协议DHCP

- **DHCP（Dynamic Host Configuration Protocol）**提供了即插即用的联网方式，用户无需手动配置IP地址等信息
- DHCP配置的内容包括**IP地址、子网掩码、网关IP地址**
- 工作过程
  - **客户端**发送**Discover报文**，目的地址为**255.255.255.255:67**，源地址为**0.0.0.0:68**，放入**UDP**中并被**广播**到同一子网的所有主机上。如果客户端和DHCP服务器不在同一个子网，则需要使用中继代理
  - **DHCP服务器**收到Discover报文后，**发送Offer报文**给客户端，包含客户端所请求的所有信息
  - 客户端可能受到**多个**不同DHCP服务器提供的Offer报文，它**选择**其中一个，并发送**Request报文**给该DHCP服务器
  - **DHCP服务器**收到Request报文后，**发送Ack报文**，表示客户端此时可以使用它提供的信息

![](4.jpg)

> 由于此过程中，客户端没有IP地址，因此**每一步都是通过广播**的形式发送


## 其他问题
### 常用端口号

- 域名系统协议**DNS**，端口号**53**
- 文件传送协议**FTP**，端口号**20/21**
- 超文本传输协议**HTTP**，端口号**80**
- 简单邮件传送协议**SMTP**，端口号**25**
- 邮件读取协议**POP3**，端口号**110**
- 网际报文存取协议**IMAP**，端口号**143**
- 动态主机配置协议**DHCP**，端口号**67/68**

### Web页面请求过程

> 转载声明：以下内容摘自[林深时不见鹿的博文](https://blog.csdn.net/weixin_45629285/article/details/120930370)，仅用于整理复习使用，不作任何商业用途，侵删

- 常问问题：**从地址栏输入URL到显示页面都发生了什么？**

#### DNS解析

- 我们通过浏览器请求Web页面时，在地址栏输入该Web页面的地址，它是外部服务器的域名
- 实际上，浏览器是通过该服务器的IP地址与其建立连接的。因此浏览器先向本地DNS服务器发送DNS请求报文，查询该域名对应的IP地址（此处需要补充**DNS发送报文的细节**）
- 本地DNS服务器收到请求报文后，从中解析出域名，并查询本地存储是否包含该IP地址，若包含则直接返回给浏览器
- 若没有则向根DNS服务器发起DNS查询，根DNS服务器返回顶级域DNS服务器的IP地址给本地DNS服务器（迭代查询）
- 本地DNS服务器向该顶级域DNS服务器发送DNS查询，顶级域DNS服务器返回权威DNS服务器的IP地址给本地DNS服务器
- 本地DNS服务器向该权威DNS服务器发送DNS查询，它将返回该域名对应的服务器的IP地址
- 本地DNS服务器得到IP地址后，先在本地存储器保存一个副本，并返回给浏览器

#### TCP连接

- 用户浏览器通过DNS得到该域名对应的IP地址，向该IP地址的Web服务器端进程发起TCP连接请求，经过三次握手建立TCP连接

#### HTTP请求报文

- 用户浏览器通过TCP连接向该Web服务器上端口号为80的HTTP服务器端进程发送HTTP请求报文

#### HTTP响应报文

- Web服务器收到该数据报后，得到TCP报文段，得到端口号为80，因此将TCP报文端的数据载荷部分交付给同一服务器上的HTTP服务器端进程
- HTTP服务端进程解析HTTP请求报文，查找所请求的对象，并通过HTTP响应报文返回给用户浏览器
- HTTP响应报文通过TCP连接传输给用户主机

#### 浏览器渲染

- 用户主机收到数据报后，得到TCP报文段，并将数据载荷部分交付给HTTP客户端进程，HTTP客户端进程解析HTTP响应报文，并在网页浏览器中进行显示

#### TCP连接断开

- 用户主机和Web服务器通过**四次挥手**终止TCP连接

