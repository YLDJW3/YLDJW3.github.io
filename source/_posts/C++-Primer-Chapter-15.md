---
title: C++ Primer Chapter 15
date: 2022-02-21 12:32:51
tags: C++
categories: C++
mathjax: true
---

**C++ Primer第15章笔记**

<!--more-->

# 第15章 面向对象程序设计

## 15.1 OOP概述

- **面向对象**程序设计的三个概念：**数据抽象、继承和动态绑定**
  - 通过**数据抽象**，可以将类的**接口**与**实现**分离
  - 通过**继承**，可以定义**相似的类型**并对相似关系建模
  - 通过**动态绑定**，可以在一定程度上**忽略相似类型的区别**

### 继承

- 通过继承联系在一起的类形成了**层次关系**
- 层次关系的**根部**是一个**基类**（base class），其他类**直接或间接地**从基类**继承而来**，继承得到的类称为**派生类**（derived class）
- **基类**负责定义层次关系中所有类**共同拥有的成员**，每个**派生类**定义**各自特有的成员**

- 基类将**类型相关的函数**与**派生类不做改变直接继承的函数**区分对待。若**基类**希望派生类各自定义适合自身的版本，则将这些函数声明成**虚函数**（virtual function）

- 派生类通过**类派生列表**，明确指出它是**从哪些基类继承而来的**，形式是**冒号**后加以**逗号分隔**的**基类列表**，每个基类前可以有**访问说明符**

  ```c++
  class Bulk_quote: public Quote {
  	//...  
  };
  ```

- **派生类**必须在其内部对所有**重新定义的虚函数**进行声明，可以在前面加上`virtual`关键字，也可以**显式地注明使用哪个成员函数改写基类的虚函数**，即在该函数的**形参列表后增加`override`关键字**

### 动态绑定

- 通过**动态绑定**，可以用同一段代码**处理不同类的对象**
- 函数的运行版本**由实参决定**，即在**运行时选择函数的版本**，所以动态绑定也称为**运行时绑定**
- C++中，当**使用基类的引用或指针**调用一个**虚函数**时将发生动态绑定

## 15.2 定义基类和派生类

### 定义基类

- **基类**通常应该定义一个**虚析构函数**

#### 成员函数与继承

- 基类必须把**派生类直接继承而不要改变的函数**，与希望**派生类进行覆盖的函数**进行区分
- 基类将**希望派生类进行覆盖的函数**定义为**虚函数**，派生类可以对这些函数进行**重新定义**，即提供自己的新定义**覆盖**从基类继承而来的旧定义

- 任何**构造函数以外**的**非静态函数**都可以是虚函数，但`virtual`只能用于**类内部的声明语句**，不能用于类外部的函数定义
- 如果基类把函数声明为虚函数，则在**派生类**中该函数也**隐式**地是**虚函数**
- 当使用**指针**或**引用调用虚函数**时，该调用将被**动态绑定**，该调用可能执行**基类的版本**，也可能执行**某个派生类的版本**
- 成员函数如果**没有声明为虚函数**，则其解析过程发生在**编译而非运行**时

#### 访问控制与基类

- 派生类可以继承定义在基类中的成员，但其成员函数不一定有权访问基类继承而来的成员
- **派生类**能访问基类的`public`成员，**不能访问基类的`private`成员**
- 若基类希望其**派生类有权访问**成员，而**其他用户不能访问**，则**用`protected`访问运算符**说明这样的成员

### 定义派生类

- 派生类通过**类派生列表**指明其从哪个基类继承而来，其形式是冒号加上逗号分隔的基类列表，基类前面可以有**访问说明符**（`public`、`private`、`protected`）
- 访问说明符的作用是，控制派生类从基类**继承而来的成员**是否**对派生类的用户可见**
- 若一个派生是公有的（访问说明符为`public`），则**基类的公有成员也是派生类接口的组成部分**，能将**公有派生类型的对象**绑定**到基类的引用或指针**上

#### 派生类中的虚函数

- 派生类通常覆盖它继承的虚函数，**若没有覆盖则派生类会直接继承其在基类中的版本**

- 派生类能够显式地注明使用**哪个成员函数覆盖了继承的虚函数**，即在形参列表后面，或`const`成员函数的`const`限定符后，或引用成员函数的引用限定符后，**加上`override`关键字**

#### 派生类对象及派生类向基类的转换

- 派生类对象包含多个**组成部分**，一个**含有派生类自己定义的成员**的**子对象**，该派生类继承的**基类的子对象**（若有多个基类，则有**多个子对象**）
- C++标准没有明确规定派生类的对象在内存中的分布，即继承自基类的部分和类自定义的部分**不一定是连续存储**的
- 我们可以把**派生类的对象**当作**基类的对象**使用，也可以将**基类的指针或引用**绑定到**派生类对象**，这是基于**派生类对象中含有与其基类对应的组成部分**这一事实
- 这种转换称为**派生类到基类的转换**，编译器会隐式执行这一转换

#### 派生类构造函数

- 派生类对象含有从基类继承而来的成员，但不应该直接初始化这些成员，而应该使用**基类的构造函数**初始化**基类部分**

- 如果派生类的构造函数没有调用基类的构造函数，则其基类部分将被**默认初始化**
- 若派生类的构造函数的**初始化列表**，调用基类的构造函数，则**首先初始化基类部分**，然后**按声明顺序依次初始化派生类的成员**

#### 派生类使用基类的成员

- 派生类的作用域**嵌套**在基类的作用域内
- 派生类可以**访问基类的**`public`和`protected`成员，直接使用，**无需作用域运算符**

#### 继承与静态成员

- 如果基类定义了一个**静态成员**，则整个继承体系中**只存在该成员的唯一定义**

- 静态成员也遵循**访问控制规则**，若基类的静态成员是`private`的，则派生类无权访问

- 若基类静态成员是`public`的，则派生类可**通过基类**使用它或**通过派生类**使用它，且可以通过**类名加作用域运算符**，或者**类对象**的方式访问

  ```c++
  class Base {
      public:
      	static int i;
  };
  class Derived: public Base {};
  Base b;
  Derived d;
  // 使用基类的静态成员可通过以下四种方式
  Base::i
  Derived::i
  b.i
  d.i
  ```

#### 派生类的声明

- 派生类的**声明**只包含类名，**不包含类派生列表**

#### 被用作基类的类

- 若某个类被用作**基类**，则它**必须已经定义**，不能只声明

- 因此**基类不能派生它本身**

- 一个类可以是**基类**，**同时也是一个派生类**

  ```c++
  class Base {};
  class D1: public Base {};
  class D2: public D1 {};
  ```

  - `Base`是`D1`的**直接基类**，同时也是`D2`的**间接基类**，间接基类由派生类通过直接基类继承而来

- 每个类都会继承直接基类的所有成员，对于**最终的派生类**来说，它将包含它的**直接基类的子对象**，以及**每个间接基类的子对象**

#### 防止继承的发生

- 若我们定义一个类时，不希望它被继承，可在**类名后紧跟关键字**`final`

  ```c++
  class A final {};
  ```

  

### 类型转换与继承 

- 把**引用**或**指针**绑定到一个对象上的规则
  - 通常情况，引用或指针的类型必须**与对象类型一致**
  - **`const`类型转换**规则，可以将一个`const`引用或指针类型绑定到对应类型的非`const`对象上
  - 存在继承关系的类，可以将**基类的引用或指针**绑定到**派生类对象**上

- 和内置指针一样，**智能指针也支持**派生类向基类的类型转换，可以将一个派生类对象的指针存储在基类的智能指针中

#### 静态类型与动态类型

- 变量或表达式的静态类型，与该表达式表示对象的动态类型的区别？
  - 表达式的**静态类型**在**编译时是已知**的，它与变量声明时的类型或表达式生成的类型一致
  - **动态类型**是变量或表达式表示的**内存中的对象的类型**，直到**运行时才可知**

- 如果表达式既**不是引用也不是指针**，则它的**动态类型**永远与**静态类型**一致

#### 不存在从基类向派生类的隐式类型转换

- 派生类向基类的转换，是基于派生类对象包含一个基类部分的事实

- 即使一个**基类指针或引用**绑定到一个**派生类对象**上，也不能执行基类向派生类的转换

- 如果我们已知某个**基类向派生类的转换是安全的**，可以通过`static_cast`进行显式转换

  ```c++
  Bulk_quote bulk;
  Quote* p = &bulk;
  Bulk_quote *bp = p;		// 错误, 无法执行基类向派生类的转换
  Bulk_quote *bp2 = static_cast<Bulk_quote*>(p);
  // 编译正确, 但程序员必须确保该基类向派生类的转换是安全的
  ```


#### 对象之间不存在类型转换

- 派生类向基类的转换**只对指针或引用类型有效**
- 派生类类型和基类类型之间不存在这样的转换

- 我们可以向**基类的拷贝/移动操作**传递一个派生类的对象，这是因为拷贝/移动构造函数/赋值运算符接受**引用类型**，这时实际运行的**构造函数/赋值运算符**是**基类中定义**的
- 此时，只有派生类对象中的**基类部分会被拷贝、移动或赋值**，而**派生类部分将被忽略**

#### 总结：存在继承关系的类型之间的转换规则

- 从派生类向基类的转换只对**指针或引用类型**有关
- **基类向派生类**的转换**不存在**隐式类型转换
- 由于继承体系中的大多数类仍然定义了拷贝控制成员，因此通常能将**派生类对象拷贝、移动或赋值给一个基类对象**，此时派生类对象的**基类部分被处理**，而**派生类部分被忽略**

## 15.3 虚函数

### 对虚函数的调用可能在运行时才被解析

- 当某个**虚函数**通过**指针或引用**调用时，编译器产生的代码直到**运行时**才能确定应该调用**哪个版本的函数**
- 动态绑定只有当我们**通过指针或引用调用虚函数**时才发生

- 如果通过**普通类型的表达式**调用虚函数时，在**编译时就会确定**调用的版本，如**通过对象进行函数调用**

### 派生类中的虚函数

- 一旦某个函数被声明为虚函数，则其所有派生类中它都是虚函数，可以不用再次通过`virtual`指明
- 如果派生类**覆盖**了某个继承而来的虚函数，则其**形参类型**必须与覆盖的基类虚函数**完全一致**，且**返回类型**也必须与基类函数**匹配**（特别地，如果**返回类型是类本身的指针或引用**，则派生类覆盖虚函数时，可以返回**基类的指针或引用**，也可以返回**派生类的指针或引用**，前提是从派生类向基类的转换是可访问的）

### `final`和`override`说明符

- 如果派生类定义了一个函数，**与基类的虚函数名字相同**，但**形参列表不同**，这是**合法**的，且它们是相互独立的两个函数
- 为了防止覆盖虚函数时出错，可通过`override`关键字说明派生类中的覆盖虚函数，此时如果用`override`标记了某个函数，但它**没有覆盖已存在的虚函数**，则**编译将出错**

> `override`是为了防止派生类覆盖基类虚函数时，由于形参列表编写错误导致定义了一个新的函数的错误

- 把某个函数指定为`final`，则之后任何试图覆盖该函数的操作都将引发错误

### 虚函数与默认实参

- 虚函数也可以有默认实参
- 如果调用虚函数使用了默认实参，则**实参值**将由本次调用的**静态类型**决定

- 因此，如果**通过基类的指针或引用调用虚函数，将使用基类中定义的默认实参**，即使我们运行的是派生类中的函数版本，传入该函数的实参仍然是基类函数定义的默认实参
- 如果虚函数使用了默认实参，**基类和派生类中定义的默认实参最好一致**

### 回避虚函数的机制

- 有时，我们希望对虚函数的调用**不要进行动态绑定**，而是**强迫执行虚函数的某个特定版本**，可以通过**作用域运算符**实现该目的

  ```c++
  double undiscounted = baseP->Quote::net_price(42);
  // 无论baseP实际指向的对象类型到底是什么, 都将执行Quote中的版本
  ```

- 若使用了回避虚函数的机制，则该**函数调用将在编译时解析**

- 当一个**派生类中的虚函数**需要**调用它覆盖的基类的虚函数版本**时，想要回避虚函数的机制

- 若派生类虚函数想要调用基类版本，但却**没有使用作用域运算符**，则调用该派生类虚函数时将导致**无限递归**

## 15.4 抽象基类

### 纯虚函数

- 如果我们在基类中定义的虚函数是没有实际意义的，它希望每个派生类都覆盖该虚函数，而其自身的版本永远不要被调用，将该函数定义为**纯虚函数**可以实现该目的
- **纯虚函数**告诉用户这个函数**没有实际意义**，纯虚函数**无需定义**，而是在**声明语句**的**分号前加上`=0`**进行说明
- `=0`只能出现在类内部的虚函数声明语句中
- 可以为纯虚函数提供定义，但是必须在类的外部

### 含有纯虚函数的类是抽象基类

- **含有**纯虚函数的类，或**未经覆盖而直接继承**纯虚函数的类是**抽象基类**
- **抽象基类**负责**定义接口**，派生类负责覆盖该接口
- 我们**不能创建**一个**抽象基类的对象**

- **重构**负责重新设计类的体系，从而**将操作/数据从一个类移动到另一个类中**，对于面向对象的应用程序，重构很普遍

## 15.5 访问控制与继承

- 每个类分别控制着其成员对于派生类是否可访问

### 三类用户

- 不考虑继承的话，一个类可以有两种不同的用户：**普通用户**和**类的实现者**
  - **普通用户**编写代码**使用类的对象**，只能访问类的`public`成员
  - **类的实现者**负责编写**类的成员**和**友元**代码，能访问类的所有成员
- 考虑继承时，则有**第三类用户**，即**派生类**，派生类及派生类的友元可以访问类的`protected`成员

### `protected`

- 受保护的成员对于类的**普通用户**是**不可访问**的，对于**派生类的成员和友元**是**可访问**的

- `protected`的重要性质，**派生类的成员或友元**只能通过**派生类对象**访问基类的`protected`成员，**不能通过基类对象**访问基类的`protected`成员

- **派生类的普通用户**不能访问基类的`protected`成员

- 对于上述句子的理解可参考[知乎-晶龙的代码](https://www.zhihu.com/question/37051531/answer/70303204)

  ```c++
  class Base {
      Base() {
          a = 10;
      }
  protected:
      int a;
  };
  
  class Derived : Base {
      Base baseObject;
      
      void foo() {
          a = 11;             // target object is self (kind of Derived)
          baseObject.a = 12;  // target object is kind of Base
      }
  };
  ```

  - `Derived`类的`foo`成员第一句是正确的，而第二句是错误的
  - 这是因为虽然`Derived`继承了`Base`，但此处的`baseObject`是一个普通的`Base`对象，则此时**并非作为派生类成员**使用该`protected`成员，而是**作为基类的普通用户**使用该`protected`成员，所以导致错误

### `public`、`private`和`protected`继承

- 某个类对其继承而来的成员的访问权限受到两个因素影响，一是**基类中该成员的访问说明符**，二是**派生类的派生列表中的访问说明符**
- 派生访问说明符对于**派生类的成员及友元**能否访问其直接基类的成员**没有影响**
- 派生访问说明符用于控制**派生类的普通用户**，以及**派生类的派生类**对基类成员的访问权限
- `public`**继承**，成员将**遵循原有**的访问说明符
- `private`**继承**，基类的成员是**私有的**
- `protected`**继承**，**基类的`public`成员变为`protected`**，因此**派生类的成员和友元可以**使用基类的`public`和`protected`成员，而**派生类的普通用户不能**使用

### 派生类向基类转换的可访问性

- 假定`D`继承自`B`
  - 只有是**`public`继承**时，**用户代码才可以**使用派生类向基类的转换，若为`private`或`protected`继承，用户代码不能使用该转换
  - `D`的**成员函数和友元总是能够**使用派生类向直接基类的转换
  - 如果为**`public`继承或`protected`继承**，则`D`的**派生类的成员和友元**可以使用`D`向`B`的转换
- 如果**基类的公有成员**是可以访问的，则**派生类向基类的类型转换**也是可以访问的，反之则不行

> 疑问：对于`protected`继承类A的类B，其`public`派生类C的成员，能否访问基类A的`public`成员？
>
> 回答：类C的成员能否访问，但是类C的用户不可以

### 友元与继承

- 友元关系不能传递，**友元关系也不能继承**

### 改变个别成员的可访问性

- 派生类可以为那些**它可以访问的名字**提供`using`声明，以**改变派生类的用户对其的访问**

- `using`声明中**名字的访问权限**由该`using`**声明语句之前的访问说明符决定**，如`using`位于`public`部分则该名字能被派生类的普通用户访问

  ```c++
  class Base {
    	protected:
      	int i;
  };
  class Derived: public Base {
      public:
      	using Base::i;		
      	// i的访问权限变为public, Derived类的普通用户可以使用i成员
  };
  ```

### 默认的继承保护级别

- **默认派生运算符**由定义派生类所用的关键字决定
  - 使用`class`定义的派生类是`private`继承的
  - 使用`struct`定义的派生类是`public`继承的
- **私有派生**的类最好显式地通过`private`声明出来

## 15.6 继承中的类作用域

- 每个**类**定义自己的**作用域**，在其中我们定义**类的成员**
- 若存在**继承**关系，**派生类**的作用域**嵌套**在其**基类**的作用域内。如果一个名字在派生类的作用域内无法解析，则编译器将继续在外层的基类作用域中寻找该名字的定义

### 编译时进行名字查找

- 一个**对象、引用或指针**的**静态类型**决定了该对象的**哪些成员是可见的**

- 即使我们用**基类的指针或引用**指向了**派生类的对象**，我们**无法**通过该指针或引用访问**派生类独有的成员**

  ```c++
  // 假设基类为Base, 派生类为Derived, Derived定义了新的数据成员v
  Derived d;
  Base* p = &d;
  cout << p->v << endl;	// 错误, p的静态类型是Base*, 不存在数据成员v
  ```

### 名字冲突与继承

- 回忆：定义在**内层作用域**的名字将**隐藏**定义在**外层作用域**的名字
- 派生类也能重用定义在其直接基类或间接基类中的名字，此时定义在**派生类的名字**将**隐藏**定义在**基类的名字**
- 这种情况下，如果我们想在派生类**访问被隐藏的基类成员**，可以通过**作用域运算符**访问
- 因此，**除了覆盖**继承而来的**虚函数**之外，派生类最好**不要重用其他定义在基类中的名字**

### 继承关系中的函数调用解析过程

- 当我们调用`p->mem()`或`obj.mem()`，将按以下步骤解析
- 确定`p`的**静态类型**，该类型必定是类类型
- 在静态类型**对应的类中查找**`mem`，若找不到则在**直接基类中查找**，不断往上**直到到达继承链的顶端**，如果仍然**找不到将报错**
- 若找到，则进行**常规的类型检查**，以确认本次调用是否合法
- 若调用合法，则编译器将根据调用的**是否虚函数**而产生不同的代码
  - 若`mem`为**虚函数**，且我们**通过指针或引用调用**，则将进行**运行时解析**，即运行时确定到底该运行该虚函数的哪个版本，依据指针或引用所指对象的动态类型
  - 若`mem`**不是虚函数**，或者我们**通过对象进行调用**，则编译器将产生**常规函数调用**

### 名字查找先于类型检查

- 声明在**内层作用域**的函数并**不会重载**声明在**外层作用域**的同名函数

- 如果派生类的成员与基类的成员同名，则派生类将在其作用域内**隐藏**该基类成员（**无论形参列表是否一致**，都将隐藏）

- 代码示例

  ```c++
  struct Base {
      int memfcn();
  };
  struct Derived: Base {
      int memfcn(int);
  };
  
  Derived d; Base b;
  b.memfcn();			// 调用Base版本
  d.Base::memfcn();	// 通过作用域运算符访问被隐藏的成员, 调用Base版本呢
  d.memfcn();			// 类型检查不通过, 调用非法
  d.memfcn(10);		// 调用Derived版本
  ```

### 虚函数与作用域

- 如果派生类没有覆盖其基类的某个虚函数，则派生类会**直接继承其在基类中的版本**

- 基类与派生类中的虚函数必须有相同的形参列表，否则**无法通过基类的指针或引用调用派生类的虚函数**

> - 这里有一个容易混淆的概念，对于虚函数，如果派生类没有覆盖，则它会直接**继承基类中的版本**。假如派生类又定义了同名的形参列表不一样的函数，则此时派生类有了两个同名的函数。相当于该函数名在派生类重载了（这与基类的版本会被隐藏不矛盾）
>
> - 代码示例如下
>
>   ```c++
>   class Base {
>     virtual int fcn();  
>   };
>         
>   class Derived: public Base {
>       int fcn(int);
>   }
>         
>   Base b; Derived d;
>   Base* bp1 = &b, bp2 = &d;
>   bp1->fcn();		// 调用Base版本
>   bp2->fcn();		// 调用Derived从Base继承的版本
>   ```

### 覆盖重载的函数

- 派生类可以覆盖函数的0个或多个实例，如果派生类希望所有的重载版本对于它来说都是可见的，则它**必须覆盖所有的版本或都不覆盖**
- 如果只想覆盖其中的一部分版本，可以为重载的成员提供一条`using`声明语句，这样就不用覆盖基类中的每一个重载版本了 
- `using`声明语句指定一个名字，而不指定形参列表，因此**一条`using`声明语句**就可以把该函数在**基类中的所有重载实例**都添加到**派生类作用域**中

## 15.7 构造函数与拷贝控制

### 虚析构函数

- 继承关系对基类拷贝控制最直接的影响，是**基类通常应该定义一个虚析构函数**

- 当我们`delete`动态分配的对象的指针时将执行析构函数，若该指针指向继承体系中的某个类型，则可能出现**指针的静态类型**与**被删除对象的动态类型不符**的情况。我们通过在基类中将析构函数定义为虚函数，**确保执行正确的析构函数版本**
- 如果基类的析构函数不是虚函数，则`delete`一个**指向派生类对象的基类指针**将产生**未定义**的行为
- **三/五法则**，如果一个类需要析构函数，则通常需要拷贝和赋值操作。基类析构函数是一个重要**例外**，我们**总是需要为基类定义虚析构函数**，但不一定要拷贝和赋值操作
- 虚析构函数将阻止合成移动操作。如果类**定义了析构函数**，则即使通过`=default`的形式使用了合成的版本，编译器也**不会为它合成移动操作**

### 合成拷贝控制与继承

- 继承体系中的**合成拷贝控制成员**，除了对类本身的成员依次进行初始化、赋值或销毁操作外，还会**使用直接基类**中对应的操作对一个**对象的直接基类部分**进行**初始化、赋值或销毁操作**
- 基类可能是**合成的**默认拷贝控制成员，或**自定义的**默认拷贝控制成员，唯一要求是相应的成员是**可访问**的，**不是删除的函数**
- 如果类**定义了析构函数**，则它**没有合成的移动操作**，此时如果移动该类的对象将执行拷贝操作

#### 派生类中删除的拷贝控制成员与基类的关系

- 如果**基类**的**默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数**是被**删除**的或**不可访问**的，则**派生类**的对应成员是**删除**的，因为派生类无法使用基类成员执行派生类对象的基类部分的初始化、赋值或销毁
- 如果**基类**有一个**不可访问或删除**的**析构函数**，则**派生类**的合成**默认构造函数**、**拷贝构造函数**是被删除的，因为编译器无法销毁派生类对象的基类部分
- 如果基类的**移动操作**是删除或不可访问的，则派生类中**对应操作是被删除的**，因为派生对象的基类部分无法移动
- 如果**基类的析构函数**不可访问或删除，则**派生类的移动构造函数**是删除的

#### 移动操作与继承

- **基类**定义的**虚析构函数**，会**阻止**编译器**合成移动操作**，从而**派生类也无法合成移动操作**

- 如果我们确实需要移动操作，则应该**首先在基类定义移动操作**，否则基类缺少移动操作会阻止派生类拥有自己的合成移动操作，且即使派生类定义移动操作，也可能无法解决派生类对象的基类部分移动的问题

### 派生类的拷贝控制成员

- **派生类**定义了**拷贝或移动**操作时，该操作负责拷贝或移动**包括基类部分成员**在内的**整个对象**
- 相反，**析构函数只负责销毁派生类自己分配的资源**，而对象的成员是被隐式销毁的，而派生类对象的**基类部分也是自动销毁的**

#### 定义派生类的拷贝或移动构造函数

- 默认情况下，**基类默认构造函数**初始化派生类对象的基类部分
- 如果我们想**拷贝或移动基类部分**，必须在派生类的构造函数**初始值列表**中**显式**地使用**基类的拷贝（或移动）操作**

#### 派生类赋值运算符

- 派生类的赋值运算符也**显式**地调用**基类的赋值运算符**为基类部分赋值

#### 派生类析构函数

- 析构函数的函数体执行完后，会隐式地销毁对象成员。类似地，**派生类对象**的**基类部分**也是**隐式销毁**的
- 对象**销毁的顺序与创建顺序相反**，先执行**派生类**析构函数，再执行**直接基类**的析构函数，依次类推**直至到达继承链的顶端**

#### 在构造函数和析构函数中调用虚函数

- 派生类对象构造/析构期间进入了基类的构造/析构函数时，**对象类型可看作是基类类型，而不是派生类类型**
- 这意味着如果我们在构造/析构函数调用了某个**虚函数**，则会执行**与该构造/析构函数所属类型相对应的虚函数版本**

### 继承的构造函数

- 派生类可以“继承”其**直接基类**定义的**构造函数**

- 一个类只能继承其直接基类的构造函数，**不能继承默认、拷贝和移动构造函数**

- 派生类通过**`using`声明**继承直接基类的构造函数

  ```c++
  using Base::Base;		// 继承Base的构造函数
  ```

  - 当`using`声明作用于构造函数时，`using`声明语句将令编译器产生代码，对于**基类的每个构造函数**，编译器都生成一个**与之对应的派生类构造函数**
  - 若派生类有自己的数据成员，则在继承的构造函数中它们被**默认初始化**
  - `using`声明不会改变该构造函数的**访问级别**

- 例外

  - 如果派生类定义了**形参列表相同**的构造函数，则它**不会继承该版本的基类构造函数**
  - **不能继承默认构造函数、拷贝构造函数、移动构造函数**

## 15.8 容器与继承

- 因为容器只能存放同一类型的元素，因此容器存放继承体系中的对象时，通常采取**间接存储**的方式
- 即**存放基类的指针或智能指针**，这些指针指向的**对象的动态类型**可能是**基类**类型或**派生类**类型

## 补充-虚函数表

> 本节内容转自[Leo的博客 “C++虚函数表剖析”](https://leehao.me/C-虚函数表剖析/)，做了适当精简

### 类的虚表

- 每个包含了**虚函数**的类都包含一个**虚表**

- 虚表是一个**指针数组**，每个**元素**都是**一个虚函数的函数指针**

- 普通的非虚函数的调用无需经过虚表，因此虚表**不包含普通函数的指针**

- 一个类**只有一个虚表**，该类的**所有对象共享一个虚表**

- 虚表内的条目，即**虚函数指针的赋值**发生在编译器的**编译阶段**，因此**虚表的构造**发生在代码的**编译阶段**

- 以下代码定义了类`A`

  ```c++
  class A {
  public:
      virtual void vfunc1();
      virtual void vfunc2();
      void func1();
      void func2();
  private:
      int m_data1, m_data2;
  };
  ```

- 类`A`的虚表如下

![](1.png)

### 虚表指针

- 为了指定对象的虚表，对象内部包含一个虚表的指针，**指向对象所使用的虚表**，称为**虚表指针**
- 编译器在类中添加了一个**指针`*__vptr`来指向虚表**，对象创建时便拥有了该指针，其值将在创建时被自动设置为指向类的虚表

![](2.png)

### 动态绑定

- 示例代码

  ```c++
  class A {
      public:
          virtual void vfunc1();
          virtual void vfunc2();
          void func1();
          void func2();
      private:
          int m_data1, m_data2;
  };
  
  class B : public A {
      public:
          virtual void vfunc1();
          void func1();
      private:
          int m_data3;
  };
  
  class C: public B {
      public:
          virtual void vfunc2();
          void func2();
      private:
          int m_data1, m_data4;
  };
  ```

- 基类为`A`，派生类`B`继承`A`，派生类`C`继承`B`，则它们的对象模型如下

![](3.png)

  - 三个类都包含虚函数，因此编译器为每个类都创建一个虚表，其虚表指针`*__vptr`分别指向自己的虚表
  - 类`A`包含两个虚函数，因此类`A`的虚表包含两个指针，分别指向`A::vfunc1()`和`A::vfunc2()`
  - 类`B`继承于类`A`，故类`B`可以调用类`A`的函数，同时覆盖了`vfunc1()`，因此类`B`的虚表包含两个指针，分别指向`B::vfunc1()`和`A::vfunc2()`
  - 类`C`继承于类`B`，故类`C`可以调用类`B`的函数，同时覆盖了`vfunc2()`，因此类`C`的虚表包含两个指针，分别指向`B::vfunc1()`和`C::vfunc2()`

- 对象的虚表指针用来指向自己所属类的虚表，**虚表中的指针**会指向其**继承的最近的一个类的虚函数**

#### 虚函数调用的过程

```c++
int main() 
{
    B bObject;
    A *p = & bObject;
    p->vfunc1();
}
```

- 函数调用时，发现`p`是个指针，且调用了虚函数
- 根据虚表指针`p->__vptr`访问对象`bObject`对应的虚表，虽然`p`是`A*`类型的指针，但由于`*__vptr`也是基类的一部分，所以通过`p->__vptr`可正确访问对象对应的虚表
- 在虚表中查找所调用的函数对应的条目，因此查找类`B`的虚表的`vfunc1`对应的条目
- 根据虚表中找到的函数指针，对应函数，即调用`B::vfunc1()`

#### 动态绑定的三个条件

- 通过指针或引用调用函数
- 调用的是虚函数
- 指针或引用是`upcast`向上转型的，如派生类向基类的转换

## 习题

- 给定下面的类，问调用的函数版本是哪个？

  ```c++
  class Base {
      public:
      	string name() { return basename; }
      	virtual void print(ostream& os) { os << basename; }
     	private:
      	string basename;
  };
  
  class Derived: public Base {
    	public:
      	string name() { return basename; }
      	void print(ostream& os) override { 
          	Base::print(os);
              os << basename;
          }
      private:
      	string basename;
  };
  
  Base obj1;
  Derived obj2;
  Base *bp1 = &obj1;
  Base *bp2 = &obj2;
  Base &br1 = obj1;
  Base &br2 = obj2;
  
  obj1.print();		// base, 编译时解析
  obj2.print();		// derived, 编译时解析
  bp1->name();		// base, 编译时解析(name()并非虚函数)
  bp2->name();		// base, 编译时解析
  br1.print();		// base, 动态绑定
  br2.print();		// derived, 动态绑定
  ```

  
