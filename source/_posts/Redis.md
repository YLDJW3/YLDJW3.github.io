---
title: Redis
date: 2022-03-18 23:08:51
tags: 
    - Redis
    - 面试
mathjax: true
categories: Redis
---

# 问题

- Redis应用场景有哪些？
- 为什么需要使用缓存？
- Redis支持的数据类型有哪些？底层数据结构是什么?
- 为什么说Redis是单线程模型？它由哪几部分组成？
- Redis不使用多线程的原因是什么？Redis6.0后引入多线程是为了解决什么问题？
- Redis为什么需要设置过期机制？
- Redis如何判断数据过期？
- Redis如何删除过期数据？该策略有何问题？
- Redis的内存淘汰机制是怎样的？常用的策略是什么？
- Redis的持久化机制目的是什么？
- Redis持久化方式有哪两种？
- Redis事务由哪些命令组成？redis事务与关系型数据库的事务有何区别？
- Redis缓存穿透是什么？如何解决该问题？
- Redis缓存雪崩是什么?如何解决?
- 缓存读写策略有哪几种？Redis采取哪种？
- 单机redis有何缺点？为什么要使用redis集群？
- redis集群有几种实现模式？
- redis主从模式是怎样的？有何优点？有何缺点？
- redis哨兵模式中，哨兵集群有何作用？该模式有何优点？有何缺点？
- redis自研模式中，客户端分片是怎样的，代理分片是怎样的，分别有何优点、缺点？
- redis cluster模式中
  - 分片是怎样实现的？什么是一致性哈希技术？什么是虚拟slot技术？
  - redis cluster结构是怎样的？
  - redis bus的作用是什么?
  - 节点交互的配置信息包括哪些？
- redis主从架构中数据会丢失吗？如何解决？
- redis集群的主从复制过程是怎样的？
- 什么是分布式锁？有何实现方案？
- redis实现分布式锁的方案是怎样的？
- RedLock算法是怎样的？

# Redis应用场景

## 缓存

- **缓存**：Redis常用作缓存，因为它是内存数据库，读写速度非常快

- **缓存数据的处理流程**

  **查找缓存**：如果用户请求的数据在缓存中就直接返回

  **查找数据库**：如果用户请求的数据在数据库中，则更新缓存数据并返回

  **返回空数据**：如果数据库中也不存在该数据，则返回空数据

- 为什么要用缓存？

  **高性能**：从内存中的缓存读取数据，比从磁盘读取数据更快

  **高并发**：诸如MySQL的数据库的QPS大概在1w左右，而使用Redis缓存则可达10w以上

  > QPS: Query Per Second，服务器每秒可以执行的查询次数

## 其他

- 分布式锁
- 限流
- 消息队列

# Redis支持五种数据类型

## string

- **字符串类型**：Redis构建了简单动态字符串SDS类型，可以保存二进制数据，获取字符串长度的复杂度为$O(1)$
- **常用命令**：set、get、strlen、exists、decr、incr、setex
- **应用场景**：计数，如统计用户访问次数、文章点赞转发数量

### 普通字符串操作

- **设置键值对**：set key value

- **根据key获取值**：get key

- **判断某个key是否存在**：exists key

- **返回key存储的字符串值的长度**：strlen key

- **删除某个key对应的值**：del key

### 计数器

- 字符串内容为**整数**时可以使用
- **递增**：incr number
- **递减**：decr number

### 过期

- **设置过期时间**：expire key 60，设置数据在60s后过期
- **同时设置数据值和过期时间**：setex key 60 value

> setex = [set] + [ex]pire

- **查询过期时间**：ttl key，返回还有多少秒过期

## list

- **链表类型**：Redis实现的list是双向链表，支持反向查找和遍历
- **常用命令**：rpush、lpush、rpop、lpop、lrange、llen等
- **应用场景**：发布与订阅、消息队列、慢查询

### 队列

- 通过rpush、lpop实现队列

### 栈

- 通过rpush、rpop实现栈

- lrange可以查询对应下表范围的列表元素

```
lrange myList 0 1
# 查询链表中下标从0到1(包括1)的元素
```

- llen查看链表长度

```
llen myList
```

## hash

- **哈希表类型**：内部实现为数组+链表，类似JDK1.8之前的HashMap，常用于存储对象
- **常用命令**：hset、hmset、hexists、hget、hgetall、hkeys、hvals等
- **应用场景**：系统中**对象数据**的存储

## set

- **无序集合类型**：类似于Java中的HashSet
- **常用命令**：sadd、spop、smembers、sismember、scard、sinterstore、sunion
- **应用场景**：需要存放数据不能重复，且需要获取多个数据源交集、并集的场景

- **交集**：sinterstore set1 set2 set3，求set2与set3的交集，并存放在set1中
- **并集**：sunion set1 set2，求set1与set2的并集

## sorted set

- **zset类型**：与set相比，增加了一个权重参数score，使得集合的元素能按score进行有序排列，还可以通过score的范围获取元素列表
- **常用命令**：zadd、zcard、zscore、zrange、zrevrange、zrem等

- **应用场景**：对数据根据某个权重进行排序的场景，如直播系统中的礼物排行榜等

## bitmap

- **bitmap类型**：存储连续的二进制数字，只需要1个bit就可以表示某个元素对应的值或状态，key就是对应元素本身
- **常用命令**：setbit、getbit、bitcount、bitop
- **应用场景**：保存状态信息，如是否签到、是否登录，并进一步对这些信息进行分析的场景

### 统计活跃用户

```
setbit 20220319 1 1		# id为1的用户在20220319活跃
setbit 20220319 2 1		# id为2的用户在20220319活跃
setbit 20220320 1 1		# id为1的用户在20220320活跃
bitop and desk1 20220319 20220320
bitcount desk1			# 20220319和20220310都活跃的人数
bitop or desk2 20220319 20220320
bitcount desk2			# 任意一天活跃的人数
```

# Redis单线程模型

## Reactor模式

- **两种体系**：处理Web请求时，通常有两种体系结构，分别是thread-based architecture，event-driven architecture

### thread-based结构

- **每个请求一个线程**：每接收到一个请求，便开启一个独立的线程处理

- **适用场景**：并发访问量不大的场景，因为线程需要占用一定的内存资源，且操作系统在线程之间的切换也需要一定的开销，线程数过多时会降低web服务器的性能

### event-driven结构

- **事件**：状态的改变，如tcp中socket的new incoming connection、ready for read、ready for write

- **事件处理器**：用于响应特定事件的发生，服务端接受连接与对事件的处理分离

### reactor

- **reactor设计模式**：event-driven architecture的一种实现方式

  - **并发请求**：处理多个客户端并发的向服务端请求服务的场景

  - **服务由多个方法组成**：每种服务在服务端可能由多个方法组成
  - **解耦服务、分发给事件处理器**：reactor解耦并发请求的服务，并分发给对应的事件处理器处理

- **角色**：文件描述符、同步时间分离器、初始分发器、事务处理器、具体的事务处理器
  - **文件描述符** handle
  - **同步事件分离器** Synchronous Event Demultiplexer，本质上是系统调用，如linux中的select、poll、epoll
  - **初始分发器** Initiation Dispatcher，即reactor角色，提供了注册、删除、转发event handler的方法
  - **事务处理器** Event Handler
  - **具体的事务处理器** Concrete Event Handler，实现具体的业务逻辑

## Redis单线程模型

- **Redis的事件处理模型**：Redis的文件事件处理器，它是以单线程方式运行的

- Redis如何监听大量客户端连接？

  **IO多路复用程序**：redis使用IO多路复用监听多个socket，并根据socket目前执行的任务为socket关联不同的事件处理器

  **事件驱动程序**：Redis服务器是一个事件驱动程序，服务器需要处理文件事件、时间事件。当socket准备好执行accept、read、write、close等操作时，对应的文件事件就会发生，文件事件处理器就会调用socket之前关联的事件管理器来处理这些事件

  **文件事件处理器**以单线程方式运行，但通过I/O多路复用程序监听多个套接字，实现了高性能的网络通信模型，又很好地与Redis服务器中其他同样以单线程方式运行的模块对接

- **文件事件处理器的组成**

  - **多个socket**：客户端连接

  - **IO多路复用程序**

  - **文件事件分派器**，将socket关联到相应的事件处理器

  - **事件处理器**：accept处理器、命令请求处理器、命令回复处理器等

## Redis为何不使用多线程？

- **易于维护**：单线程编程简单，且易于维护
- **性能瓶颈**：Redis的性能瓶颈不在CPU，而在**内存和网络**
- **死锁、上下文切换**：多线程存在以上问题

## Redis6.0后引入了多线程的原因

- **提高网络IO读写性能**：Redis引入多线程主要为了提高网络IO读写性能
- Redis只在网络数据读写等耗时操作上使用了多线程，而执行命令仍然是单线程顺序执行的

# Redis的过期机制

- **目的**：防止内存耗尽，如果缓存中的所有数据一直保存，则最终会导致out of memory

## Redis如何判断数据过期？

- **过期字典**：保存数据过期的时间，可看作哈希表，键指向Redis数据库中的某个键，值是一个long long类型的整数，保存了key所指向的数据库键的过期时间

- 过期字典存储在`redisDb`结构体的`expires`变量中

  ```c
  typedef struct redisDb {
      ...
  
      dict *dict;     //数据库键空间,保存着数据库中所有键值对
      dict *expires   // 过期字典,保存着键的过期时间
      ...
  } redisDb;
  ```

## 过期数据的删除策略

- **惰性删除**：在取出key时对数据进行过期检查，对CPU友好，但可能会导致大量过期key没被删除
- **定期删除**：每隔一段时间则抽取一批key，删除其中的过期键，对内存友好
- **Redis策略：定期删除 + lazy删除**

## Redis内存淘汰机制

- **目的**：redis采用定期删除 + lazy删除策略，但仍有可能漏掉许多过期key，导致内存空间耗尽，为此redis引入了内存淘汰机制

- **数据淘汰机制**

  **volatile-lru**：从已设置过期时间的数据淘汰最近最少使用的数据

  **volatile-ttl**：从已设置过期时间的数据集中挑选将要过期的数据淘汰

  **volatile-random**：从已设置过期时间的数据集中任意选择数据淘汰

  **allkeys-lru**：当内存不足以容纳新写入数据时，移除最近最少使用的key（**最常用策略**）

  **allkeys-random**：从数据集中任意选择数据淘汰

  **no-eviction**：禁止驱逐数据，当内存不足以容纳新数据时则报错

  **volatile-lfu**：从已设置过期时间的数据淘汰最不经常使用的数据

  **allkeys-lfu**：当内存不足以容纳新数据时，移除最不经常使用的键

# Redis持久化机制

- **目的**：持久化数据，即将内存中的数据写入磁盘，从而在系统故障后仍然可以恢复数据
- **Redis支持两种持久化方式**：快照RDB、只追加文件AOF
- **快照持久化**：创建快照，获取存储在内存中的数据在某个时间点上的副本
  - **备份快照**：创建快照后可对快照进行备份，将快照复制到其他服务器从而创建具有相同数据的服务器副本
  - **数据恢复**：快照留在原地可用于重启服务器时的数据恢复

- **只追加文件持久化**

  **AOF文件**：每执行一条改变数据的命令，就会将该命令写入到内存缓存中，并在某时刻同步到硬盘中的AOF文件

  **三种AOF持久化方式**（从内存缓存写入AOF文件的时机）

  - 每次数据修改时都写入AOF文件
  - 每秒同步一次，将多个命令同步到硬盘的AOF文件中（常用）
  - 操作系统决定何时同步

# Redis事务

- **MULTI命令**：开始事务，此后输入的多个命令不会立刻执行，而是放入队列中（FIFO）
- **EXEC命令**：执行事务
- **DISCARD命令**：取消事务
- **WATCH命令**：监听指定的键，调用exec命令执行事务时，若一个被watch命令监听的键被修改，则事务不会执行

- **redis事务与关系型数据库的事务区别**

  redis事务不支持rollback，因而不具备原子性，也不满足持久性

# 缓存穿透

- **含义**：大量请求的key不存在于缓存中，导致请求直接到数据上

- **场景**：攻击者故意对不存在缓冲中的key发起大量请求

- 解决方法

  **参数校验**：对于不合法参数的请求应抛出异常信息

  **缓存无效key**：如果缓存和数据库都查不到某个key的数据，则写一个到redis中并设置过期时间

  **布隆过滤器**：把所有可能存在的请求的值都存放在布隆过滤器中，用户请求时先判断用户发来的请求的值是否存在于布隆过滤器中，不存在则返回错误参数信息，存在才继续查询缓存

  - **先查询布隆过滤器，再查询缓存**
  - **误判**：布隆过滤器认为一个数据存在，它可能不存在；但布隆过滤器认为数据不存在，则一定不存在

# 缓存雪崩

- 含义

  **缓存在同一时间大面积失效**：缓存在同一时间大面积失效，导致后面的请求都直接落在数据库上，数据库在短时间内承受大量请求（如系统缓存的某个模块宕机不可用）

  **多个热点缓存在某一时刻失效**：同样地，可能导致大量请求直接落在数据库上

- **Redis服务不可用**的解决方法

  **采用redis集群**，避免单机出现问题导致整个缓存服务不可用

  **限流**，避免同时处理大量请求

- **热点缓存失效**的解决方法

  **设置不同的失效时间**，如随机设置缓存失效时间

  **设置缓存永不失效**

# 缓存读写策略

## 旁路缓存模式

- **写策略**：先更新数据库，然后**删除缓存**

- **读策略**：先从缓存读数据；若读不到则从数据库读数据，并更新缓存

- **一致性问题**

  - 写数据的过程中可以**先删除缓存，再更新数据库**吗？

    不行。可能造成数据库和缓存数据不一致问题，如（1）请求1把缓存中的A数据删除（2）请求2从数据库读取数据（3）请求1更新数据库。这样，请求2便无法读取到比自己早执行的请求1写入的数据

  - 写数据**先更新数据库，再删除缓存**便没有一致性问题吗？

    仍然存在。（1）请求1从数据库读取数据，（2）请求2写数据A到数据库，并删除缓存的A数据，（3）请求1将数据A写入缓存。这样，请求2往数据库写入了新数据，但缓存中仍然保留着旧数据

  - 解决办法

    **要求强一致性**：更新数据库的同时更新缓存，但需要加**分布式锁**保证更新缓存时不能存在线程安全问题

    **允许短暂不一致**：更新数据时同样更新缓存，给缓存加一个较短的过期时间

- **缺点**
  - 首次请求数据一定不在cache中（解决：先将热点数据提前放入cache中）
  - 写操作比较频繁的话，导致cache中的数据被频繁删除，影响缓存命中率
  - 数据不一致问题

## 读写穿透模式

- **缓存视作主要数据存储**：服务端把缓存视为主要数据存储，从中读取数据并将数据写入其中，缓存负责从数据库读取数据，将数据写入数据库

- **写策略**：先查缓存，若缓存则存在则更新缓存，缓存服务自己负责更新数据库；若缓存不存在则更新数据库
- **读策略**：读缓存，若存在则直接返回；若不存在则从数据库加载，写入缓存后返回
- **特点**：在旁路缓存模式中，若读请求的数据不在缓存中，由应用程序自己访问数据库读取并写入缓存；而在读写穿透模式，若读请求的数据不在缓存中，则缓存服务自己会从数据库读取数据并写入缓存，这一过程对用户是透明的
- **缺点**：首次请求数据一定不在缓存（解决：把热点数据提前放入缓存）

## 异步缓存写入模式

- 与读写穿透共同点：由**缓存服务负责更新缓存和数据库的读写**
- 与读写穿透的不同：读写穿透同步更新缓存和数据库，异步缓存写入模式则**只更新缓存**，不直接更新数据库，而是以**异步批量的方式更新数据库**
- **优点**：读写性能高
- **缺点**：一致性更差

# redis集群

- redis单机的缺点：服务器宕机导致服务不可用；性能瓶颈，内存限制了处理能力
- redis集群方案：主从模式、哨兵模式、自研、Clustert模式

## redis主从模式

- **复制功能**：在master数据库中的数据更新后，自动将更新的数据同步到slave数据库上，即主从模式的redis集群

- **优点**

  **高可靠性**，master数据库故障后，可以切换到slave数据库

  **读写分离**，slave数据库可以扩展master数据库节点的都能力，应对大并发量的读操作

- **缺点**

  **不具备自动容错和恢复能力**，主节点故障， 从节点需要**手动**升为主节点

## redis哨兵模式

- **哨兵集群作用**

  **监控运行状态**：监控所有服务器是否正常运行，除监控主服务器、从服务器外，哨兵服务器也相互监控

  **故障切换**：哨兵检测到master宕机后，会自动将slave切换成master，通过发布订阅模式通知其他从服务器，修改配置文件让其切换master。旧master若从故障恢复后将成为新master的slave服务器

- **优点**：解决了主从模式中master故障不能自动切换的问题

- **缺点**

  **浪费资源**，集群里所有节点都保存全量数据

  **切换时间**，主节点宕机后，投票选举结束前，redis会开启保护机制，禁止写操作，直至产生新的redis主机

  **写操作性能瓶颈**，只有master节点可以执行写请求

## redis自研模式

- 各个开发者为了解决redis哨兵模式的问题，自研的redis集群方案

### 客户端分片

- **分片逻辑**：在redis客户端实现，通过预定义的路由规则将对key的访问转发到不同的redis实例中

- **路由规则**：对key求哈希值

- **优点**：redis实例之间彼此独立，相互无关联，易于扩展，系统灵活性强

- **缺点**

  **redis群拓扑结构变化**：客户端sharding不支持动态增删节点，服务端redis实例群拓扑结构变化时，每个客户端都需要更新调整

  **运维成本**：运维成本较高，集群的数据出了任何问题都需要运维人员和开发人员一起解决

  **客户端维护分片逻辑**：不同的客户端需要编写和维护多套相同的逻辑

### 代理分片

- **目的**：redis实例群拓扑结构变化时，**不需要客户端更新调整**，而是由代理分片完成
- **实现**：**代理分片**将客户端分片模块单独分出来，作为redis客户端和服务端的桥梁
- **优点**：解决了服务端redis实例群拓扑结构变化时，每个客户端需要更新调整的问题
- **缺点**：redis客户端的请求都经过代理才能到达redis服务器，**性能损失**

## redis cluster模式

### Redis哈希槽

- **一致性哈希**技术

  **圆环**：一致性哈希将范围抽象为一个圆环，对key计算hash值后对$2^{32}$取模，则值的范围在$[0,2^{32}-1]$之间

  **分配**：将redis示例均匀分布在圆环上，通过上述方法计算key的哈希值后找到其在圆环的位置，然后将其分配到该位置按顺时针旋转的下一个redis实例。若redis实例故障，则继续按顺时针旋转直到找到下一个正常redis实例

  **缺点**：redis实例节点较少时，节点变化将导致数据倾斜，即部分节点数据过多，部分节点数据过少

  **虚拟节点**：与真实节点一起分布在圆环上，而且每个虚拟节点都会映射到某个真实节点中

- **虚拟槽**技术

  **槽数量**：redis集群一共有$2^{14}=16384$个槽

  **槽范围**：所有的master节点都有一个槽范围，槽数是可以迁移的。master节点的从节点不分配槽，只拥有读权限

  **分配**：计算key的哈希值，然后对16384取模得到对应的槽位，然后根据槽找到对应的节点

  **更方便地添加和移除节点**

  - 增加节点时，只需要把其他节点的某些哈希槽挪到新节点即可
  - 移除节点时，只需要把移除节点上的哈希槽分配到其他节点即可，不需要停止redis任何节点的服务
  - 如果使用一致性哈希技术，则增加和移除节点都需要rehash

### redis cluster结构

- **结构**：可以看作多个主从架构结合在一起

  - redis推荐redis cluster至少包含三个主节点，每个主节点至少有一个从节点，即三主三从六个节点
  - 每组节点都可看做一个主从模式，且负责不同的slot

- **主备复制**：与主从模式类似，master库数据更新后，将自动同步到slave库上

- **对外服务**：外部对redis进行读写操作时，必须访问master进行写操作，可以访问slave进行读操作

- **Redis bus**

  **去中心化**：redis cluster是一个去中心化的架构，不存在统一的配置中心，redis cluster的每个节点都保存了集群的配置信息

  **配置信息交互**：节点之间通过redis cluster bus完成配置信息的交互，最终达成一致性

  **PING/PONG**：配置信息的一致性主要依靠PING/PONG，每个节点向其他节点频繁地周期性地发送PING/PONG消息，每次PING/PONG都随机携带一部分节点信息，由于交互频繁，短时间内的几次交互后集群状态会达成一致

  **交互信息**包括

  - **数据分片slot和节点的对应关系**
  - **集群中每个节点的可用状态**
  - **集群结构变更信息**，数据分片的迁移、主备切换、单点master的发现等都会导致集群结构变化

## redis主从架构会发生数据丢失吗

- **异步复制同步丢失**：redis主节点和从节点的复制是异步的，若主节点的数据未完全复制到从节点，主节点就发生了宕机，则主节点内存中的数据会丢失

- **split brain问题**：一个集群中产生多个主节点，如由于网络原因，集群出现了分区，master与slave节点之间的联系断开，哨兵检测后认为主节点故障，重新选举某个从节点为主节点。而旧的主节点并未故障，客户端仍在其上写数据，当旧的主节点被降为从节点后，会同步新的主节点数据，导致此前客户端写入旧主节点的数据丢失
- **解决**：通过设定配置参数，规定至少有x个slave与master的同步复制延迟时间不超过y秒，若不满足该条件则master暂不接受任何客户端请求（降低系统的可用性换取数据一致性）

## redis集群的主从复制过程

- 步骤

  **设置服务器的地址和端口号**

  **建立套接字连接**：建立主从服务器之间的连接

  **发送PING命令**：检验套接字是否可用

  **身份验证**

  **同步**：从master库向slave库同步数据，分为全量复制、部分复制

  **命令传播**：当同步后主从数据库状态一致，此后若主服务器接受并执行新的写命令，则将该命令发送给从节点，从节点也接收并执行命令，保证主从节点数据的一致性

- 全量复制与部分复制

  **全量复制**：用于**初次复制**或无法进行部分复制的情况，将主节点的所有数据都发送给从节点

  **部分复制**：用于网络中断恢复后的复制，只将中断期间主节点执行的写命令发送给从节点，更加**高效**

- redis如何保证主从服务器一致

  **心跳检测机制**：命令传播阶段，slave利用心跳检测机制，定时向主服务器发送消息

- **网络问题**导致主从复制过程中停止复制会怎样？

  **断点续传**：网络重新连接后，接着上次复制的地方继续复制，而不是重新复制

  **replication buffer**：master库连接的每一个slave库对应一个replication buffer，master库执行完每一个操作命令后，将命令分别写入每一个从库对应的replication buffer

  **replication backlog**：一个**环形**区域，记录master库写入的位置和slave库读取的位置

  **master_repl_offset**：记录master库写入记录的偏移量

  **slave_repl_offset**：记录slave库读取记录的偏移量

  > 开始时两者相等，当master写入命令时master_repl_offset递增，slave读取命令时master_repl_offset递增，因此两者之间的命令就是从库未复制的命令记录

# redis的分布式问题

## 什么是分布式锁

- **锁的作用**：同步，保证共享资源在同一时刻只能被同一线程访问
- **分布式锁**：保证分布式场景下，共享资源在同一时刻只能被同一线程访问，或是用来控制分布式系统之间同步访问共享资源

- 分布式锁的特性

  **互斥性**：任意时刻，同一条数据只能被一台机器上的一个线程执行

  **高可用性**：部分节点宕机后，客户端仍可以正常地获取锁和释放锁

  **独占性**：加锁和解锁必须在同一服务器执行，不能在一个服务器上加锁，在另一个服务器上解锁

  **防锁超时**：如果客户端没有主动释放锁，服务器会在一定时间后自动释放锁，防止客户端宕机或网络异常导致宕机

## 分布式锁的实现方法

- 基于**关系型数据库**

- 基于**redis**

  **优点**：性能好，实现方便

  **缺点**：key的过期时间设置难以确定；redis集群并非强一致性

- 基于**zookeeper**

  **优点**：解决了单点问题、不可重入问题、非阻塞问题以及锁无法释放问题，实现简单

  **缺点**：性能上不如使用缓存实现分布式锁

## Redis如何实现分布式锁

- **SETNX命令**：该命令的作用是，当key不存在时设置key的值，当key存在时则不进行任何操作

- **简单流程**

  **实现**：SETNX获取锁，若获取成功则执行业务，然后删除锁并结束

  **问题**：如执行业务时代码**异常**，导致无法删除锁，则其他线程也无法获取锁

- 改进方案1：try-catch-finally

  **实现**：将删除锁操作放在finally代码块中，保证出现异常时也能释放锁

  **问题**：若执行业务时**宕机**，则仍然无法删除锁

- 改进方案2：**给锁设置过期时间**

  **问题**：线程1获取锁时设置了过期时间，但若执行业务时间超过了该过期时间，则锁到期释放后线程1仍在执行。若此时线程2获取了锁并开始执行业务，而线程1此后执行结束并删除锁，会导致线程2获取的锁被释放

- 改进方案3

  **给锁加上标识UUID**：每个线程获取锁时都会生成一个不同的UUID作为锁的标识，删除锁时，锁的标识和自己生成的UUID相等时才进行删除操作

  **守护线程**：加锁时设置一个预估的过期时间，并开启守护线程，定时检测锁的失效时间，若快要过期而访问共享资源的操作还未完成，则守护线程对该锁进行续期，重设过期时间

  **尚存在的问题**：不具备可重入性（同一线程可以重复获取锁）

- 改进方案4：**重入计数**

  **实现**：对锁进行重入计数，加锁时加1，解锁时减1，当计数归零时才释放锁

  **尚存问题**：若线程获取锁失败后，它如何得知该锁被释放而再次获取？

- 改进方案5：轮询/发布订阅

  **轮询**：客户端轮询，即周期性地检测是否可以获取锁，消耗服务器资源

  **redis的发布订阅功能**：线程获取锁失败时，**订阅锁释放消息**；线程获取锁并执行业务完成后，释放锁时**发送锁释放消息**

- 改进方案6：**多节点redis的分布式锁——RedLock算法**

## RedLock算法

- **客户端获取锁**
  - **时间戳**：获取当前时间戳
  - **获取锁**：在redis实例中按顺序获取锁，在所有实例中使用相同的键名和随机值，**锁的获取时间**设置为比锁的过期时间短得多（如果一个redis实例不可用，应尽快尝试下一个redis实例）
  - **获取成功**：客户端在超过一半的实例中获得锁，则认为获取锁成功
  - **有效时间**：锁的有效时间为锁初始设置的过期时间，减去锁的获取时间
  - **获取失败**：若客户端无法成功获取锁（无法在超过一半的redis实例中获取锁，或锁的有效时间为负数），则尝试解锁所有redis实例

- **失败重试**

  如果无法获取锁，则客户端在**随机时间**后重试

- **释放锁**

  尝试释放所有实例的锁，无需考虑是否释放成功（删除时会判断这个锁是否由自己设置，避免释放其他客户端上设置的锁）
