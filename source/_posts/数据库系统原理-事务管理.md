---
title: 数据库系统原理-事务管理
date: 2022-03-04 17:00:45
tags: 
    - 数据库
    - 面试
mathjax: true
categories: OS 
---

**数据库事务管理知识总结**

<!--more-->

# 1 事务

## 事务的概念

- **事务**是访问并可能更新各种数据项的一个**程序执行单元**

- 事务的**四个特性ACID**
  - **原子性**，事务的所有操作在数据要么全部正确地反映出来，要么完全不反应
  - **一致性**，当事务完成时，事务必须处于一致状态
  - **隔离性**，多个事务并发执行，但每个事务都感觉不到系统中有其他事务在并发地执行
  - **持久性**，如果事务成功完成后，对数据库的改变是永久的，即使出现系统也是如此

## 事务的状态

- 活跃、部分提交、失效、中止、提交
  - **活跃状态**（初始状态），事务执行时就处于此状态
  - **部分提交状态**，最后一条语句被执行之后，所做的更改仍然在内存的缓冲区中
  - **失效状态**，正常执行不能继续
  - **中止状态**，事务已回滚并且数据库恢复到它在事务开始前的状态
  - **提交状态**，所有操作成功完成后，从部分提交状态进入提交状态

- 事务进入中止状态后，系统有两种选择
  - **重启事务**，事务中止的原因是硬件错误或并非内部逻辑错误的软件错误，则重新执行该事务
  - **杀死事务**，事务中止的原因是内部逻辑错误

## 事务的隔离性

- 事务并发执行的好处
  - 提高**吞吐量**和**资源利用率**
  - 减少**等待时间**
- 事务的执行顺序称为**调度**，表示**指令在系统中执行的时间顺序**。一组事务的一个调度必须包含这些事务的**全部指令**

- 调度是**串行**的，指一个单独事务的指令在该调度中是一起出现的
- 并发执行
  - 数据库系统并发执行多个事务，则相应的调度不再是串行的，两个事务的各种指令可能是交叉的
  - 如果并发执行的控制完全由操作系统负责，则可能出现不一致状态。保证所执行的任何调度都能使数据库处于一致性状态是数据库系统的任务
  - 数据库系统负责完成此任务的是**并发控制部件**

## 可串行化

> 前提条件：只考虑对数据的read与write指令

- 考虑调度S，含有分别属于$T_i$和$T_j$的两条连续指令$I$与$J$，如果I与J引用不同的数据项，则交换I与J不会影响调度中任何指令的结果
- 如果I与J引用相同的数据项$Q$，则两个指令的次序可能是重要的，可能情况包括
  - $I=read(Q)$，$J=read(Q)$，I与J的次序不重要
  - $I=read(Q)$，$J=write(Q)$，I与J的次序重要，如果$I$先执行则$T_i$不会读入$T_j$写入的值，如果$J$先执行则$T_j$不会读入$T_i$写入的值
  - $I=write(Q)$，$J=read(Q)$，I与J的次序重要，同上
  - $I=write(Q)$，$J=write(Q)$，I与J的次序重要，直接影响调度$S$所产生的数据库状态中$Q$的最终值
- **冲突指令**：如果$I$与$J$是不同事务在相同数据项中执行的操作，且至少其中一条指令是write操作，则说$I$与$J$是**冲突**的

- **非冲突指令**：$I$和$J$是调度$S$的连续指令，若$I$和$J$是属于不同事务的指令，且$I$和$J$不冲突，则可以交换$I$与$J$的次序以产生一个新的调度$S'$

- **冲突等价**：如果调度$S$经一系列的非冲突指令的交换而转换成调度$S'$，则$S$和$S'$是冲突等价的

- **冲突可串行化**：如果调度$S$与一个串行调度是冲突等价的，则调度$S$是冲突可串行化的
- 确定一个调度是否冲突可串行化（**优先图+拓扑排序**）
  - 调度的**优先图**$G=(V,E)$，其中$V$是顶点集，表示参与调度的所有事务，#E#是边集，由满足下列三个条件之一的所有$T_i \rightarrow T_j$组成
    - $T_j$执行read(Q)前，$T_i$执行write(Q)
    - $T_j$执行write(Q)前，$T_i$执行read(Q)
    - $T_j$执行write(Q)前，$T_i$执行write(Q)
  - 优先图存在边$T_i \rightarrow T_j$，等价于任何串行调度中事务$T_i$必须先于$T_j$进行
  - 如果一个调度$S$的优先图是**无环**的，则调度$S$是**冲突可串行化**的
  - 通过**拓扑排序**，可以得到事务的**可串行化次序**

## 事务的隔离性和原子性

- 如果事务$T_i$失效了，撤销该事务的影响以确保事务的原子性，任何依赖于$T_i$的事务$T_j$（即$T_j$读取了$T_i$写的数据）也要中止

- **可恢复调度**：如果$T_j$读取了事务$T_i$写过的数据，则**$T_i$的提交操作**应该在事务**$T_j$的提交操作之前**
- **级联回滚**：因单个事务失效而导致一系列事务回滚的现象称为级联回滚，需要撤销大量的工作
- **无级联调度**：如果$T_j$读取了先前由$T_i$所写的一个数据项，则**$T_i$的提交操作**必须在**$T_j$的读操作之前**

## 事务的隔离性级别

- **可串行化**，保证可串行化的执行
- **可重复读**，只允许读取已提交的数据，而且一个事务两次读取一个数据项期间，其他事务不能更新该数据项
- **已提交读**，只允许读取已提交的数据
- **未提交读**，允许读取未提交数据
- 不允许**脏写**，如果一个数据项已被其他尚未提交或中止的事务写过，则不允许对该数据项再执行写操作

## 隔离性级别的实现

- **并发控制策略**，保证多个事务并发执行时，不管操作系统在事务之间如何分配分时资源，都**只产生可接受的调度**。其目标是提供**高度并发性**的同时，保证所产生的所有调度都是**冲突可串行化**的或**视图可串行化的**、**可恢复**并且**无级联**的

### 锁

- 事务可以**只封锁其访问的数据项**，这个时间要足够长以保证可串行化，又不能过长以保证一定的性能
- 通过**共享锁、排他锁**可进一步改进。共享锁用于事务**读取**的数据，排他锁用于事务**写**的数据
  - 许多事务可以**同时持有**同一数据项的**共享锁**
  - 但只有当其他任何事务在一个数据项上**不持有任何锁**，才能持有该数据项的**排他锁**

### 时间戳

### 多版本和快照隔离

- 通过维护数据项的多个版本，允许一个事务读取一个数据项的旧版本
- **快照隔离技术**
  - 每个事务开始时有其**自己的数据库版本或快照**
  - 如果事务更新数据库，**更新**只出现在其**私有版本**
  - 事务提交，则和这些更新相关的信息被保存，这些更新才被应用到真正的数据库中
  - 事务T进入部分提交状态时，只有**其他并发事务没有修改其想要更新的数据项**时，T才能进入提交状态，否则该事务被**中止**

- 快照隔离特点
  - 事务读数据时无需等待
  - **只读**事务**不会被中止**，修改数据的事务可能被中止
  - **大部分**事务是**只读**的，且大多事务**读数据的情况多于更新**，因此快照隔离相比于锁能**改善性能**

# 2 并发控制

## 2.1 基于锁的协议

### 锁

- **共享锁S**、**排他锁X**

- **相容函数**，A、B代表任意锁模式，假设事务$T_i$请求数据项$Q$上的A模式锁，而事务$T_j$当前已持有数据项$Q$上的B模式锁，若事务$T_i$可以立即获得$Q$的A模式锁，则称A模式锁与B模式锁是相容的，即$comp(A,B)$具有true值

- 共享锁与共享锁是相容的，共享锁与排他锁是不相容的
- 锁的申请，事务通过`lock-S(Q)`指令**申请**数据项Q上的**共享锁**，通过`lock-X(Q)`指令**申请**数据项Q上的**排他锁**，通过指令`unlock(Q)`指令对数据项Q**解锁**

- 当事务$T$向**并发控制管理器**申请锁时，在其他事务所持有的该数据项的所有不相容模式的锁被释放前，并发控制管理器不会**授予**该锁，$T$必须**等待**

- **死锁**发生时，系统必须**回滚**两个事务中的一个

- **封锁协议**：规定事务何时可以对每个数据项进行加锁和解锁

### 锁的授予

- 饿死现象
- 通过以下方式授予锁来避免事务饿死，当事务$T_i$申请对数据项$Q$加模式锁$M$时，并发控制管理器授予该锁的条件是
  - 其他事务在数据项$Q$上**没有**持有与模式锁**$M$不相容的锁**
  - **不存在**正在等待对$Q$加锁而且**先于$T_i$提出锁申请**的事务（FCFS）

### 两阶段封锁协议

- **两阶段封锁协议**是一种保证**可串行化**的封锁协议，每个事务分两个阶段提出加锁和解锁申请
  - **增长阶段**，一个事务可以获得锁，但不可以释放锁
  - **缩减阶段**，一个事务可以释放锁，但不可以申请锁
- **封锁点**，两阶段封锁协议中，事务获取最后一个锁的位置

- 两阶段封锁协议**保证可串行化**、保证**不发生死锁**，但**可能发生级联回滚**

- **两阶段严格封锁协议**，在两阶段封锁协议基础上，要求事务所持有的**所有排他锁**，必须在事务**提交后方可释放**
- **强两阶段封锁协议**，要求事务**提交前保留所有的锁**，事务可以按提交的次序串行化

- **锁转换**
  - **升级**，表示共享锁到排他锁的转换，`upgrade(Q)`，只发生在**增长阶段**
  - **降级**，表示排他锁到共享锁的转换，`downgrade(Q)`，只发生在**缩减阶段**

### 封锁的实现

- **锁管理器**可视为一个进程，从事务处**接受消息**，以**应答**的形式**发送消息**

- **锁表**
  - 以数据项名称为索引的**散列表**
  - 每个**数据项**维护一个**记录的链表**，每个**请求**对应链表的**一个记录**，按请求**到达顺序**排列
  - 记录中保存**哪个事务**提出请求、请求**什么模式**的锁、该请求**是否被授予**等信息

- 锁管理器**处理请求**的机制
  - 一条请求消息到来时，若相应数据项的链表存在，则在该**链表末尾增加**一条记录，否则创建一个仅包含对于该请求的记录的**新链表**
  - 对当前没被封锁的数据项的锁请求总是被授予；对已被封锁的数据项的请求，只有当该请求与该数据项持有的锁**相容**，且先前的锁请求都被授予**（FCFS）**的条件下，才**对该请求授予**
  - 锁管理器收到来自一个事务的**解锁**消息时，讲对应于该事务的数据项链表中的**记录删除**，并检查之后的记录**是否授予锁**
  - 如果事务**中止**，则**删除**该事务产生的任何**等待请求**，如果数据库管理系统**撤销**该事务则**持有的锁将被释放**

### 基于图的协议

## 2.2 死锁处理

### 死锁预防

- **防止循环等待**
  - 每个事务在**开始执行前封锁它所有**的数据项，要么全部封锁、要么全不封锁，缺点是很难预知要使用的所有数据项
  - 或者，增加一种次序，要求事务**只能按次序规定的顺序**来封锁数据项，要求它访问的数据项集合是已知的

- 抢占与事务回滚
  - 如果事务$T_j$申请的锁被事务$T_i$所占有，则授予$T_i$的锁可能通过回滚$T_i$而被抢占
  - 使用**时间戳**决定事务是应该等待还是回滚，若事务回滚，应该保持其原来的时间戳
  - **等待-死亡机制**是**非抢占**式的，若$T_i$申请的数据项被$T_j$持有时，仅当$T_i$比$T_j$更老才等待，否则**$T_i$回滚（死亡）**
  - **伤害-等待机制**是**抢占**式的，若$T_i$申请的数据项被$T_j$持有时，仅当$T_i$比$T_j$更年轻时才等待，否则**$T_j$回滚（$T_j$被$T_i$伤害）**
- **锁超时**
  - 若事务等待超过一定时间，则事务超时，**自己回滚并重启**

### 死锁检测与恢复

- 死锁检测，**等待图**包含**环路**时则系统存在**死锁**
- 等待图的顶点集V由事务组成，边集E中的某条有向边$T_i \rightarrow T_j$表示$T_i$正在等待事务$T_j$释放$T_i$所需要的数据项
- 从死锁中恢复，需要**回滚一个或多个事务**，包括的动作有
  - **选择牺牲者**，可根据代价选择
  - **回滚**：部分回滚或完全回滚
  - **饿死**：如果根据代价因素，则可能存在某个事务总是被选为牺牲者而永远得不到执行，因此可在代价中引入回滚次数

## 2.3 多粒度

- **多级粒度机制**是一种数据粒度的层次结构，小粒度数据嵌套在大粒度数据项中，如**多粒度树**
  - **根节点**表示整个**数据库**
  - **area类型**节点表示数据库的**域**
  - 每个域包含的**文件**用**file类型**节点表示
  - 每个文件包含的**记录**用**record类型**节点表示

- 多粒度树中，每个节点可以单独加锁（共享锁和排他锁），当给某个节点加锁时，**隐含**地**封锁这个节点的所有后裔节点**

### 意向锁模式

- **意向锁**模式
  - 如果 一个节点加上了意向锁，代表**要在树的较低层进行显式加锁**
  - 给某个节点进行**显式加锁**前，会给它的**所有祖先节点加上意向锁**
  - 与共享模式关联的意向锁称为IS，与排他模式关联的意向锁称为IX
- 意向锁的相容函数
  - **意向锁之间相互兼容**
  - IX锁与X、S不兼容
  - IS锁与S兼容，与X不兼容
- 以**MySQL InnoDB**为例
  - MySQL InnoDB设置**表锁**（IS、IX、S、X）、**行锁**（S、X）
  - 当想读取某一行时，先给表加上IS锁，再给行加上S锁
  - 当想写入某一行时，先给表加上IX锁，再给行加上X锁
  - 如果事务$T_i$需要读整个数据库，即获取了表锁S，此后事务$T_j$想要写入某一行，先获取表锁IX，由于IX与S不相容，因此$T_j$必须等待$T_i$释放表锁S后，才能获取表锁IX并获取行锁X
  - 此处的**相容与不相容**都是**针对同一个节点**讨论的，表锁IS/IX不会与行锁S/X不相容
- 多粒度协议要求**封锁按自顶向下**的次序获得，**解锁按自底向上**的次序释放

## 2.4 插入、删除操作与谓词读

- delete(Q)从数据库删除数据项Q
- insert(Q)将一个新的数据项Q插入数据库中并赋予Q一个初值

### 删除

- delete(Q)与read、write、delete和insert都冲突
- 两阶段封锁协议下，一个数据项可以被删除前，需要**获得**该数据项的**排他锁**

### 插入

- insert(Q)与read、write、delete冲突
- 两阶段封锁协议下，如果$T_i$执行insert(Q)操作，将在新创建的数据项Q上被**赋予排他锁**

### 谓词读和幻象

- 幻象现象的原因是**谓词读**与**插入或更新**相冲突，导致**新/更新的元组满足谓词**

- 如**谓词读**

  ```sql
  select count(*)
  from instructor
  where dept_name = 'Physics';
  ```

  与**插入操作**是冲突的

  ```sql
  insert into instructor
  	values(11111, 'Feynman', 'Physics', 94000);
  ```


## 2.5 基于时间戳的协议

### 时间戳

- 封锁协议：一对冲突事务的执行时次序，由这对事务都申请且不相容的第一个锁的时间来决定
- 时间戳协议：实现决定事务的次序，如采用时间戳排序
- 对每个事务$T_i$，把唯一、固定的时间戳与其关联，时间戳$TS(T_i)$是事务开始前由DBMS给定的
- 实现时间戳的两种方法
  - 采用系统时间
  - 采用逻辑计数器
- 每个**数据项Q**也与两个时间戳值相关联
  - **W-timestamp(Q)**，**成功执行write(Q)**的任意事务的**最大时间戳**
  - **R-timestamp(Q)**，**成功执行read(Q)**的任意事务的**最大时间戳**
  - 每当有新的read(Q)或write(Q)指令时，就会更新上述时间戳

### 时间戳排序协议

- 如果事务$T_i$请求read(Q)
  - $TS(T_i)\lt W\_timestamp(Q)$，则$T_i$试图读取一个已被覆盖的数据，数据库系统拒绝该请求并回滚$T_i$
  - $TS(T_i)\geq W\_timestamp(Q)$，系统执行read操作，并更新$R\_timestamp(Q)$
- 如果事务$T_i$请求write(Q)
  - $TS(T_i)\lt R\_timestamp(Q)$，则$T_i$写入的Q值是之前所需要的，系统回滚$T_i$
  - $TS(T_i)\lt W\_timestamp(Q)$，则$T_i$写入的Q值是过时的，系统回滚$T_i$
  - 否则，系统执行write操作，更新$W\_timestamp(Q)$
- 当事务触发时间戳协议的并发控制并被**回滚**时，系统会**分配一个新的时间戳**并**重启事务**

### Thomas写规则

- 如果事务$T_i$请求write(Q)，而$TS(T_i)\lt W\_timestamp(Q)$，则系统**忽略该write操作**，因为其写入的值已过时
- Thomas写规则使得调度是**非冲突可串行化**的，但是保证了**视图可串行化**
- 其他规则不变

## 2.6 基于有效性检查的协议

- **有效性检查协议**将事务分为两或三个阶段执行
  - 读阶段，读取各数据项的值并保存在$T_i$的局部变量，write操作只对局部变量进行，不对数据库进行真正的更新
  - 有效性检查阶段，进行有效性检查测试，若测试失败则终止事务
  - 写阶段，若通过有效性检查，则将write操作的局部变量结果考入数据库（只读事务没有写阶段）
- 事务$T_i$具有三个时间戳
  - $StartTS(T_i)$表示事务开始执行的时间
  - $ValidationTS(T_i)$表示完成读阶段并开始有效性检查阶段的时间
  - $FinishTS(T_i)$表示完成其写阶段的时间
- 通过$ValidationTS(T_i)$时间戳决定可串行化的次序，$TS(Ti)=ValidationTS(Ti)$，如果$TS(Tj)<TS(Ti)$，则产生的调度必须等价于事务$Tj$出现在$Ti$之前的一个穿行调度
- **有效性检查**，事务$T_i$的有效性检查要求所有满足$TS(T_k)\lt TS(T_i)$的事务$T_k$都必须满足以下两个条件的任意一个
  - $FinishTS(T_k) \lt StartTS(T_i)$
  - $T_k$**所写**的数据项集合与$T_i$**所读**的数据项集合**不相交**，且$StartTS(T_i) \lt Finish(T_k) \lt ValidationTS(T_i)$

### 乐观锁与悲观锁

- **基于有效性检查**的协议是**乐观**的并发控制，**封锁协议**和基于**时间戳**的协议是**悲观**的并发控制

## 2.7 多版本机制MVCC

- 上述并发控制机制通过**延迟**一项操作，或**中止**发出操作的事务保证**可串行化**
- **多版本并发控制机制**中，每个`write(Q)`操作**创建Q的一个新版本**，事务发出一个`read(Q)`操作时，并发控制管理器**选择Q的一个版本**进行读取
- 对于读取版本的**选择**能以**保证可串行化**的方式进行，且事务应该**尽可能快速**地判定应该读取数据项的哪个版本（性能）

### 多版本时间戳排序

### 多版本两阶段封锁

## 2.8 快照隔离

### 快照隔离中的多版本

- 事务的时间戳
- 版本的时间戳

### 更新事务的有效性检查步骤

- **更新丢失**，两个并发执行的事务潜在地更新同一个数据项，由于它们以隔离的方式操作并使用各自的私有快照，因此两个事务都看不到对方的更新，则第一个更新的写操作被第二个覆盖
- **先提交者胜**，当事务$T_i$开始有效性检查时
  - 检查是否存在于$T_i$并发的任何事务，对于$T_i$打算写的某些数据项，该事务已将更新写入数据库。即检查$T_i$打算写的每个数据项$d$，是否存在一个版本的时间戳介于$StartTS(T_i)$和$CommitTS(T_i)$之间
  - 如果发现了，则中止$T_i$
  - 如果没发现，则$T_i$**提交并将更新**写到数据库
- **先更新者胜**（读操作不受次影响）
  - $T_i$更新数据项时，请求数据项的一个写锁，如果没有并发事务持有该锁，则获得锁后
    - 如果这个数据项已被并发事务更新，$T_i$中止
    - 否则$T_i$继续执行操作，包括可以提交
  - 如果有其他并发事务$T_j$持有该锁，则等待直至$T_j$中止或提交
    - 如果$T_j$提交，则$T_i$中止
    - 如果$T_j$中止，则$T_i$获得锁后执行上述检查
- 先提交者胜与先更新者胜的对比
  - **先提交者胜**，如果事务冲突则**第一个进行检查**的事务将成功写出更新，随后的事务被迫中止
  - **先更新者胜**，则**第一个获得锁**的事务被允许提交并执行更新，随后试图更新的事务被中止

### 串行化问题和解决方案

- 快照隔离并**不能保证可串行化**
- **写偏斜**：一对事务中的每一个都**读取对方所写的一个数据项**，但两个事务所**写**的数据项**集合不存在任何共同的数据项**，这种情况称为写偏斜

- **可串行化快照隔离**，跟踪事务之间的所有冲突，如在事务优先图中寻找环路，并在找到环时回滚事务

## 补充 并发一致性问题

### 丢失更新

- 两个事务都同一个数据进行写入，先提交的事务的写操作被后提交事务的写操作覆盖

### 读脏数据

- $T_i$读到未提交事务$T_j$写入的数据，若随后$T_j$撤回，则$T_i$读到的是脏数据

### 不可重复读

- 事务$T_i$对数据项Q进行了多次读取，而事务$T_j$在$T_i$的两次读取之间修改了数据项Q，导致$T_i$前后的读取结果不一致

### 幻影读

- 事务$T_i$执行谓词读，而事务$T_j$进行的insert或update导致某个元组满足了谓词，则$T_i$再次进行相同谓词读的结果不一致

# 3 恢复系统

## 回顾: xv6文件系统的故障恢复机制

- 故障导致文件系统不一致问题

  文件系统的操作一般包含多个步骤，若在多个步骤的某个中间位置发生故障，导致存储在磁盘上的文件系统处于不一致状态

- 文件系统的目标
  - **原子性**：关于文件系统的系统调用确保原子性，如create/write系统调用，其效果要么完全出现，要么完全不出现
  - **快速恢复**：故障重启后，文件系统的修复只需要较小的工作量
- 日志
  - 磁盘分割为两部分，一部分是**日志系统**（较小），一部分是**文件系统**
- 更新文件系统的**四步骤**
  - **log write**，更新文件系统并不直接更新其本身，而是将数据写入到log，记录这个更新的数据及写入的磁盘位置
  - **commit op**，当文件系统操作结束后，所有操作都存在log中，则提交对文件系统的操作，并在log中将更新对文件系统的commit计数值
  - **install log**，log中存储了写入文件系统的所有内容，因此执行操作时将log中的数据写入磁盘块
  - **clean log**，若所有操作都成功执行，则清除log，同时将日志系统中相应的操作次数设置为0

- 故障恢复
  - 若由于故障导致重启，则文件系统执行恢复过程
  - 文件系统查看日志的commit记录值，如果为0则无需操作并清除log；如果大于0，则说明log包含了完整的操作，则将log中存储的数据写入文件系统中
- 故障场景分析
  - **在log write和commit log之间故障**，由于没有commit，因此操作次数为0，恢复阶段文件系统忽略该操作并清除log，相当于**故障在文件系统调用前发生**
  - **在commit log和install log之间故障**，由于commit计数值非0，代表log包含完整的操作，因此将log写入到文件系统相应位置，相当于**故障在文件系统调用后发生**
  - **在install log和clean log之间故障**，由于commit计数值非0，因此恢复阶段将log写入到文件系统相应位置，由于**写入操作的幂等性**，因此再次写入数据不会造成影响

## 3.3 恢复与原子性

### 日志记录

- **日志**是日志记录的序列
- **更新日志记录**描述一次数据库的写操作，包括以下字段
  - **事务标识**，执行write操作的事务的唯一标识
  - **数据项标识**，数据项在**磁盘上的位置**，包括该数据项所驻留的**块的块标识**和**块内偏移量**
  - **旧值**，数据项的**写前值**
  - **新值**，数据项**写后应取的值**
  - 更新日志记录标识为$<T_i,X_j,V_1,V_2>$
- 其他日志记录，包括**开始、提交、中止**
  - <$T_i$ start>，事务$T_i$开始
  - <$T_i$ commit>，事务$T_i$提交
  - <$T_i$ abort>，事务$T_i$中止
- 事务执行写操作时，数据库被修改前创建该写操作的日志记录并加到日志中
- **日志**存储在**稳定存储器**中，**日志记录**创建后立即写入稳定存储器上**日志的尾部**

### 数据库修改

- 事务在对数据库修改前创建日志记录，日志记录使得系统
  - 在事务必须**中止**的情况下能够对事务所做的修改进行**撤销**
  - 在事务已经提交但在修改被存到磁盘上的数据库前**系统崩溃**的情况下，对事务所做的修改进行**重做**

- 事务在进行**数据项修改**时所采取的步骤
  - 事务在**主存中私有的部分空间**执行某些计算
  - 事务**修改主存的磁盘缓冲区**包含数据项的数据块
  - 数据库系统执行**output操作**，将数据块写到**磁盘**中
- 如果一个事务执行了对**磁盘缓冲块**或**磁盘本身**的更新，则说这个**事务修改了数据库**，而事务在主存中私有部分的更新不算数据库修改
- 如果事务直至**提交时都没有修改数据库**，则它采用了**延迟修改**技术
- 如果事务**活跃时就发生数据库修改**，则它采用了**立即修改**技术

- 撤销和重做操作
  - **撤销操作**使用一条**日志记录**，将该日志记录中指定数据项置为日志记录中包含的**旧值**
  - **重做操作**使用一条日志记录，将该日志记录中指定数据项置为日志记录中包含的**新值**

### 并发控制和恢复

- 如果事务$T_1$修改的数据项在提交前又被另一事务$T_2$修改，则撤销$T_1$会导致$T_2$也被撤销。为了避免该情况，恢复算法通常要求如果数据项被一个事务修改了则该事务提交或中止前不允许被其他事务修改该数据项。该要求通过对**更新的任意数据项获取排他锁**，并**持有**该排他锁**直至事务提交**来保证

### 事务提交

- 当事务的**commit日志记录被输出到稳定存储器**后，就说这个事务**提交**了
- 此时日志中有足够的信息保证，即使发生**系统崩溃**，事务所做的**更新也可以被重做**
- 事务提交时**并非**必须将所修改的数据项**立即输出到稳定存储器**，而是可以在**之后的某个时候**再输出

### 使用日志来重做和撤销事务

- **恢复机制**使用两个恢复过程，利用**日志**找到每个被事务$T_i$**更新过的数据项的集合**，以及它们相应的**新值和旧值**

- $redo(T_i)$，将事务$T_i$更新过的所有数据项的值都**置成新值**。通过**重做**来执行更新的顺序非常重要，通常**对日志进行一次扫描**，并对扫描过程中遇到的**每条日志记录执行重做动作**，确保更新顺序被保持
- $undo(T_i)$，将事务$T_i$更新过的所有数据项的值**恢复成旧值**
  - 撤销操作不仅将数据项恢复成旧值，而且作为撤销过程的一部分，**写日志记录以记下所执行的更新**，称为**redo-only日志记录**。它们不需要包含所更新数据项的旧值（旧值实际上是正在回滚的事务所写入的值，新值是恢复该数据项的原始值）
  - 对事务$T_i$的**撤销操作完成后**，**写一条<$T_i$ abort>日志记录**，表明undo完成了

- 如果事务在正常的处理中被回滚，或在恢复过程中没发现事务的commit记录或abort记录，都将执行$undo(T_i)$以撤销该操作
- 每个事务的日志**最终**都会有**一条commit记录或abort记录**

- 系统崩溃后的**恢复过程**
  - 如果日志中**包含事务的start记录**，以及**commit记录或abort记录中的一个**，事务将被**重做**（重做包含abort记录的事务将导致该事务被撤销）
  - 如果日志中**包含事务的start记录**，但**不包含**事务的**commit或abort记录**，则事务将被**撤销**

### checkpoint

- 恢复过程原则上需要搜索整个日志并决定事务是否重做或撤销，问题在于
  - 搜索过程太**耗时**
  - 大多数需要重做的事务已将其更新写入数据库中，因此重做会使恢复过程变得更长
- **检查点执行过程**
  - 检查点执行过程中**不允许任何更新**
  - 将当前位于主存的**所有日志记录**输出到**稳定存储器**
  - 将所有**修改过的缓冲块输出到磁盘**
  - 将一条**检查点日志记录 <checkpoint $L$>**输出到稳定存储器，其中**$L$是执行检查点时正在活跃的事务列表**

- 考虑在**检查点前已完成的事务**$T_i$，该事务的**commit记录或abort记录出现在checkpoint记录前**，因此$T_i$所做的任何数据库修改都必然已在检查点前或作为检查点的一部分被写入数据库，恢复时就**不必对$T_i$执行redo操作了**
- 对于执行检查点时**活跃的事务列表L**中的事务$T_i$，如果其没有提交，则为了**撤销**该事务可能用到**检查点日志记录前的该事务的所有日志记录**

- 引入检查点机制后的**恢复过程**
  - 首先反向搜索系统日志并找到最后一条checkpoint记录
  - 从此处开始扫描日志记录，只需对**活跃事务列表L中的事务**，以及**检查点checkpoint后开始执行的事务**进行redo或undo操作
  - 如果该事务的日志记录包含commit或abort则**重做**
  - 如果既不包含commit也不包含abort则**撤销**该事务
- 引入检查点机制后的**日志记录清理**
  - 由于只需要对检查点执行时活跃的事务以及检查点后开始执行的事务进行重做或撤销，因此检查点前完成执行事务的日志记录可以清理
  - 具体来说，系统在日志中搜索**最后一个检查点**，并找到其活跃事务**列表L中最早开始的事务**的开始日志记录<$T_i$ start>，该记录前的日志记录可以**清理**

## 3.4 恢复算法

### 事务回滚

- 从后往前扫描日志，对于找到的$T_i$的每条更新日志记录$<T_i,X_j,V_1,V_2>$:
  - 将$V_1$写入数据项$X_j$
  - 往日志写入一条redo-only日志记录$<T_i,X_j,V_1>$，$V_1$表示回滚时数据项$X_j$被恢复的值，该日志记录也称为**补偿日志记录**

- 一旦发现该事务的**开始日志记录**$<T_i \ start>$，则**停止**反向扫描，并写入$<T_i \ abort>$**中止日志记录**

- 现在，事务所做的或我们为事务所做的（redo-only日志记录）每个更新动作，都已被记录到日志中

### 系统崩溃后的恢复算法

- 恢复动作分为两阶段进行
- **重做阶段**
  - 反向扫描日志记录找到**最后一个checkpoint**
  - 此阶段还需要确定在崩溃发生时未完成，因而要回滚的事务，**回滚事务列表undo-list初始化**为该checkpoint的**活跃事务列表L**
  - 从该checkpoint开始**正向扫描**并重新执行所有日志记录（包括系统崩溃前已被回滚，或系统崩溃前还未提交的事务的是日志记录），具体地
    - 遇到**更新**日志记录$<T_i,X_j,V_1,V_2>$则将$V_2$的值**写入**数据项$X_j$
    - 遇到**redo-only**日志记录$<T_i,X_j,V_1>$则将$V_1$的值**写入**数据项$X_j$
    - 遇到**开始**日志记录$<T_j \ start>$则将$T_j$**加入undo-list**
    - 遇到**提交、中止**日志记录则将**事务从undo-list移除**
- **撤销阶段**，利用我们在重做阶段得到的undo-list撤销相应的事务
  - **反向扫描**日志记录，若发现undo-list事务的日志记录，则执行**撤销**操作，并**写一个redo-only日志记录**
  - 若发现undo-list事务的**开始日志记录**，则该事务已回滚完成，**写入abort日志记录**，并将其**从undo-list移除**
  - 扫描直至**undo-list为空**，则**撤销阶段结束**

### 提交处理的优化

- 组提交，事务完成后等待一段时间，然后同一提交正在等待的一组事务，**减小写日志开销**

## 3.5 缓冲区管理

### 日志记录缓冲

- 输出一个块到稳定存储器的**代价较大**，最好一次输出多条日志记录
- 将日志记录写道**主存的日志缓冲区**，并集中**多条**日志记录，再用**一次输出操作**输出到**稳定存储器**中

- **先写日志规则**

  - 事务的**提交日志记录**$<T_i \ commit>$**输出到稳定存储器后**，事务$T_i$进入**提交状态**

  - 提交日志记录$<T_i \ commit>$输出到稳定存储器**前**，与事务$T_i$有关的**所有日志记录必须已经输出到稳定存储器**
  - 主存中的**数据块**输出到**数据库（非易失性存储器）**前，与该**块中数据有关的所有日志记录**必须已经输出到**稳定存储器**

### 数据库缓冲

- **强制策略**：事务**提交时**必须将其**修改过的块都输出到磁盘**
- **非强制策略**：事务修改过的**某些块还没写回**磁盘，也**允许他提交**

- **非抢占策略**：活跃事务修改过的块都不应该写出到磁盘
- **抢占策略**：允许系统将修改过的块写到磁盘，即使这些修改的事务还未提交
- 只要**遵循先写日志规则**，可以**使用抢占策略**
- **非抢占策略不适合执行大量更新的事务**，因为缓冲区可能已更新过但又不能被移出到磁盘的块所占满，导致事务不能继续进行

- **缓冲块上的锁**
  - 事务对一个**数据项执行写操作**前，要获得**数据项所在块上的排他锁**，该锁在更新执行完后立即**释放**
  - 当一个**块要被输出到磁盘**时
    - 获得该块上的**排他锁**，以确保没有任何事务正在对该块执行写操作
    - 将日志记录输出到**稳定存储器**，直至**块相关的所有日志记录都输出**完成
    - 将该**块输出到磁盘**
    - 块输出完成，则**释放**该锁

### 操作系统在缓冲区管理中的作用

- 数据库系统**保留一部分主存作为缓冲区**，并对它进行管理，而**不是让操作系统管理**
  - 限制了主存的灵活性，缓冲区必须足够小
- 数据库系统**在操作系统提供的虚拟内存中实现缓冲区**
  - 不应由操作系统自己写数据库缓冲块，而是由数据库系统强制输出缓冲块
  - 但实际上几乎所有操作系统都完全控制虚拟内存，操作系统保留了磁盘空间用于存储当前不在主存的虚拟内存页，该磁盘空间称为**交换区**

