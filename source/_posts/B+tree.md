---
title: B+tree
date: 2022-04-08 20:27:12
tags:
    - Database System
    - 面试
mathjax: true
categories: Database System
---

**数据库索引数据结构——B+树总结**

<!--more-->

# B+树

## 索引的概念

- 一个表的属性集合，用于加快查询速度
- DBMS必须保证表格数据与索引的内容在逻辑上是同步的
- 索引能够加快查询速度，但索引本身占据存储空间，且对数据项进行增删改时维护索引也需要开销，因此如何建立索引是查询速度与维护索引的开销之间的trade-off

## B树的家族

- B树
- B+树
- B*树
- B-link树

## B+树的属性

- perfectly balanced，M-way search tree，M路指的是每个节点最多有M个子节点
- 除了根节点，每个节点至少是half-full的，即每个节点的keys数量都在$[M/2-1, M-1]$之间
- 对于内部节点，若它包含k个keys，则有k+1个非空子节点
- 每个叶子节点都有sibling pointers，分别指向其相邻的两个叶子节点

## B+树的结构

- B+树的每个节点恰好是一页
- 对于每个内部节点，都包含k个keys和k+1个非空子节点，其中第i个key与第i+1个key之间的指针指向的子树的值均在$[key_i,key_{i+1})$范围内

![](B_plus_inner_node.svg)

- 对于叶子节点，每个节点都保存了两个sibling pointers，分别指向左侧叶子节点和右侧叶子节点，应用中实际存储的是左/右侧叶子节点的page id

![](B_plus_tree_leaf_node.drawio.svg)

- 对于叶子节点，它包含n个keys和n个数据项，实际存储是keys和数据项是分开存储的，因为它们的数据大小不一致

- 节点存储的值是什么？

  方法一：主索引存储数据项本身，辅助索引存储主键

  方法二：存储指向数据项的指针，则在B+树进行索引查找后，还需要再进行一次I/O才能获得数据项

## B树与B+树的区别

- B树在内部节点也存储数据项，B树只在叶子节点存储数据项
- B树的key最多只会出现一次，因此节省空间
- B+树的内部节点无data域，当节点大小一致时，每个节点能保存的条目更多，因而索引范围更大，磁盘I/O的次数更少

## B+树的插入和删除

### 插入

- 找到对应的叶子节点，若叶子节点非满则插入并返回
- 若叶子节点已满，尝试将部分数据项分配给相邻节点
- 若无法通过重新分配数据项实现插入，则需要将当前节点分裂为两个节点

### 删除

- 找到对应的叶子节点，删除数据项
- 若叶子节点仍然为at least half-full，则完成
- 若叶子节点数据项不足一半，则尝试将相邻节点的数据项分配给本节点
- 若无法通过重新分配数据项实现插入，则需要将当前节点跟一个sibling leaf node进行合并

## 聚集索引与非聚集索引

- 聚集索引/主索引：数据项排列的顺序与索引排列的顺序一致，一般在主键上建立聚集索引。B+树叶子节点存储的值就是数据项本身

- 非聚集索引/辅助索引：数据项排列的顺序与索引排列的顺序不一致，B+树叶子节点存储的是数据项的主键，**可能**需要通过回表查询获取数据项

- 使用辅助索引也无需进行回表查询的情况——覆盖索引

  ```sql
  SELECT score FROM student WHERE student_id <= 1000
  # 查询学号小于等于1000的学生的分数
  ```

  假设我们在搜索码<student_id, score>上建立了索引，则查询时可以利用搜索码的前缀<student_id, *>进行查找，同时到达叶子节点时，我们只依靠索引的信息就能够获取score，从而得到最终需要查询的数据，无需回表查询

  ![](covering_index.drawio.svg)

## 范围查询

- **部分索引查询**：B+树的索引可以在多个属性值上组成的搜索码上建立，此时B+树支持部分索引查询，即如果查询的搜索码是索引搜索码的某个前缀，则可以使用该索引进行查询
- **范围查询**：进行范围查询时，总是先找到匹配的最左侧数据项，然后通过叶子节点的sibling pointers遍历数据项直至不满足条件

## 节点大小选取

- 磁盘I/O速度：磁盘I/O越慢，则更应该减小I/O次数，通过增大节点大小，可以增加一个节点能够存储的数据，从而减小I/O次数

- workload

  如果workload以leaf node scans为主，则适宜选取更大的节点大小，从而一次磁盘I/O能够读得更多数据项

  如果workload以root-to-leaf traversals为主，则应该减小节点大小，否则在节点内部搜索对应的子节点指针时更费时

## 合并节点的时机

- 在工程应用中，可能不会在每次节点少于half-full时都进行合并，而是视具体应用场景而定。如一种做法是不进行合并，直至整个节点为空时才进行合并

## Non-unique key

- 方法一：允许存储重复的keys
- 方法二：B+树中的keys仍然是唯一的，每个键对应的值以链表的方式保存
- 方法三：通过在key后面加上record id保证key的唯一性（record id是DBMS存储数据项时自动分配的隐藏字段）

## 节点内部的查询

- 线性搜索
- 二分搜索

## B+树的优化

### 前缀压缩

- 一个节点的多个keys具有公共前缀，提取该公共前缀后，keys可以只存储剩下的部分

### 后缀裁切

- 内部节点的作用是对查询进行正确的路由，为了达到该目的无需存储整个搜索码，而是可以裁切去某一段后缀
- 如：搜索码apple和banana，只需各自的第一个字符a、b即可进行正确路由

### bulk insert

- 假如在创建B+树时就可得知所有数据项，则无需按照B+树的插入规则逐项插入，而是直接利用各个数据项建立叶子节点，并自底向上地建立B+树

### pointer swizzling

- 通常情况下，索引中的节点通过保存其他节点的page id以指向该节点，假如其他节点的page已经存在buffer pool中，则我们可以通过裸指针直接指向该page

## 前缀树

