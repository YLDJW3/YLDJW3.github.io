---
title: C++ Primer Chapter 12
date: 2022-02-17 20:41:00
tags: C++
categories: C++
mathjax: true
---

# 第12章 动态内存

- 目前，我们使用的对象都有严格定义的生存期
  - **全局对象**在程序启动时分配，在程序结束时销毁
  - **局部自动对象**在进入其定义所在的程序块时被创建，离开时销毁
  - **局部static对象**在第一次使用前分配，在程序结束时销毁
- 此外，C++还支持**动态分配对象**，动态分配对象**只有被显式地释放时才会销毁**
- 为了保证动态对象的正确释放，C++定义了两个**智能指针**类型管理动态对象

- 静态内存、栈内存和堆内存
  - **静态内存**用于保存局部static对象、类static数据成员、定义在任何函数外的变量
  - **栈内存**用于保存定义在函数内的非static对象
  - **动态内存（堆内存）**用于保存动态分配的对象，它们是在程序运行时分配的对象

<!--more-->

## 12.1 动态内存与智能指针

- C++通过**一对运算符**进行动态内存的管理
  - `new`在动态内存中为对象分配空间并返回一个指向该对象的指针
  - `delete`接受一个动态对象的指针，销毁该对象，并释放与之关联的内存

- 动态内存使用的问题
  - 忘记释放内存，可能导致**内存泄漏**
  - 在尚有指针引用内存的情况下释放了动态对象，产生**引用非法内存的指针**

### `shared_ptr`类

- 智能指针定义在`memory`头文件中

- 默认初始化

  ```c++
  shared_ptr<string> p1;
  ```

  - 智能指针是模板，需要提供“指针可以提供的类型”
  - 默认初始化的智能指针中保存着**空指针**

- 智能指针的操作
  - 将智能指针作为**条件**使用，检测其是否为空
  - 解引用`*p`
  - 箭头运算符`p->mem`
  - `p.get()`，**返回其中保存的指针**
  - `swap(p,q)`，**交换**`p`和`q`中的指针
  - `p.swap(q)`，成员函数版本

#### `make_shared`函数

```c++
make_shared<T>(args);
```

- **最安全的分配和使用动态对象的方法**，调用`make_shared`分配一个对象，初始化它，返回指向此对象的`shared_ptr`

- 如果我们不传递任何参数，对象执行**值初始化**

- 使用**auto**定义的对象保存`make_shared`返回的智能指针

  ```c++
  shared_ptr<string> p1 = make_shared<string>("hello");
  auto p2 = make_shared<string>("hello");
  ```

#### `shared_ptr`的拷贝和赋值

- 当对`shared_ptr`拷贝或赋值时，每个`shared_ptr`都会记录**有多少个其他`shared_ptr`指向相同的对象**

- 可以认为每个`shared_ptr`都有一个关联的计数器，称其为**引用计数**
  - 每拷贝一个`shared_ptr`，计数器都会递增
  - 当给`shared_ptr`赋予一个新值，或`shared_ptr`被销毁时，计数器会递减
- 拷贝`shared_ptr`的操作
  - 用一个`shared_ptr`初始化另一个`shared_ptr`
  - 将它作为**参数**传递给一个函数
  - 作为函数的**返回值**
- 一旦一个`shared_ptr`的计数器变为0，它会**自动释放自己所管理的对象**

- 实际上，有多少个指针共享对象**不一定是通过计数器实现的**，这取决于标准库的具体实现，但我们可以以计数器的方式理解其工作原理

#### `shared_ptr`自动销毁所管理的对象

- 当指向一个对象的最后一个`shared_ptr`被销毁时，`shared_ptr`类会自动销毁此对象，这是通过特殊的成员函数**析构函数**实现的

- **析构函数**控制该类型的对象**销毁时做什么操作**，一般用来**释放该对象所分配的资源**
- `shared_ptr`的析构函数会**递减它所指向的对象的引用计数**，如果引用计数变为0，`shared_ptr`的析构函数会**销毁对象，并释放它占用的内存**

#### `shared_ptr`会自动释放相关联的内存

- 应保证`shared_ptr`在无用之后不再保留，如**将`shared_ptr`存放于一个容器中**，而只使用其中一部分，那么没用的元素应该用`erase`删除

#### 使用了动态生存期资源的类

- 程序使用动态内存出于以下三种原因之一
  - 程序**不知道自己需要使用多少对象**，如容器类
  - 程序**不知道所需对象的准确类型**
  - 程序需要**在多个对象间共享数据**

- 某些类**分配的资源具有与原对象相互独立的生存期**，如希望**多个对象共享相同的状态**，则某个对象被销毁时不能单方面地销毁底层数据

### 直接管理内存

- 运算符`new`分配内存，运算符`delete`释放`new`分配的内存
- 相对于智能指针，使用`new`和`delete`管理内存更易出错，它们不能依赖类对象拷贝、赋值和销毁操作的任何默认定义

#### 使用`new`动态分配和初始化对象

- `new`**无法**为其分配的对象**命名**，而是返回一个指向该对象的指针

  ```c++
  int *pi = new int;	// pi指向一个动态分配的、未初始化的无名对象
  ```

- 默认情况下，动态分配的对象时**默认初始化**的

  ```c++
  string *ps = new string;
  ```

- 可以使用**直接初始化**方式初始化一个动态分配的对象，可以使用**构造方式（圆括号）**，或**列表初始化（花括号）**

  ```c++
  int *pi = new int(1024);
  string *ps = new string(10, 'a');
  string *pv = new vector<int>{1, 2, 3};
  ```

- **值初始化**，在类型名后跟一对**空括号**

  ```c++
  string *ps = new string();
  int *pi = new int();
  ```

- 使用`auto`，若我们提供了一个**括号包围的单一初始化器**，可以使用`auto`定义指针类型，C++将从初始化器推断想要分配的对象的类型

  ```c++
  auto p = new auto(obj);
  // p指向一个与obj类型相同的对象
  ```

#### 动态分配的const对象

- 可以使用`new`分配`const`对象，**必须进行初始化**，返回的是指向`const`的指针

  ```c++
  const int *p = new const int(1024);
  ```

#### 内存耗尽

- 假如程序用光了它可用的内存，则`new`表达式会失败
- 默认情况下，若`new`不能分配所要求的内存空间，将抛出`bad_alloc`类型的异常

##### 定位`new`

- `placement_new`，**定位`new`**

  ```c++
  int *p1 = new int;					// 若分配失败, 抛出bad_alloc异常
  int *p2 = new (nothrow) int;		// 若分配失败, new返回空指针
  ```

- 定位`new`表达式允许我们向`new`传递额外的参数，我们传递标准库名为`nothrow`的对象，它告诉`new`**不能抛出异常**，此时将**返回空指针**

- `bad_alloc`和`nothrow`都定义在头文件`new`中

#### 释放动态内存

- `delete`**销毁给定指针指向的对象，释放对应的内存**

  ```c++
  delete p;
  ```

- `delete`表达式接受一个指针，它必须**指向一个动态分配的对象或是空指针**

- **释放一个并非`new`分配的内存，或将相同的指针值多次释放，其行为是未定义的**，编译器无法分辨一个指针所指向的内存是否已经被释放，也无法分辨一个指针指向的是静态还是动态分配的对象

#### 动态对象的生存期直到被释放时为止

- 一个由**内置指针**管理的动态对象，直到被**显式释放前都是存在的**

#### 动态内存管理的常见错误

- **忘记`delete`内存，内存泄漏**
- **使用已经释放掉的对象**
- **同一块内存释放两次**

#### `delete`之后重置指针值

- `delete`一个指针后，指针值就无效了，但在一些机器上该指针**仍保存着已被释放的动态内存的地址**
- **空悬指针**，指向一块曾经保存数据对象但现在已经无效的内存的指针
- 如果我们需要保留`delete`后的指针，可在`delete`后将`nullptr`赋予该指针（**重置指针值**）
- 当**有多个指针指向该动态对象**时，重置某个指针值，但其他指向该（已被销毁的）动态对象的指针仍然保存该地址，是空悬指针

### `shared_ptr`和`new`结合使用

#### `shared_ptr`的初始化

- 用`new`返回到指针来初始化智能指针

- `shared_ptr`的构造函数是`explicit`的，必须采用**直接初始化**的形式，**不能将一个内置指针隐式转换为一个智能指针**

  ```c++
  shared_ptr<int> p1(new int(1024));
  shared_ptr<int> p2 = new int(1024);		// 错误, shared_ptr的构造函数是exclipit的
  ```

- 出于同样的理由，返回智能指针类型的函数不能`return`内置指针

- 默认情况下，初始化智能指针的普通指针**必须指向动态内存**，因为智能指针默认使用`delete`释放它所关联的对象。而`delete`非动态内存的行为是未定义的

- 若我们**提供自己的操作来代替**`delete`，则可以将智能指针绑定到一个指向其他类型的资源的指针上

  ```c++
  shared_ptr<T> p(q);		// 用内置指针初始化智能指针p
  shared_ptr<T> p(u);		// p从unique_ptr u接管了对象的所有权, u被置为空
  shared_ptr<T> p(q, d);  // 用内置指针初始化智能指针p, 同时用可调用对象d来代替delete
  ```

#### 不要混合使用普通指针和智能指针

- 将一个`shared_ptr`绑定到一个普通指针时，我们就将内存管理的责任交给该`shared_ptr`，此后**不应再使用内置指针访问`shared_ptr`所指向的内存了**
- 使用内置指针访问智能指针所负责的对象是很危险的，因为**无法知道对象何时被销毁**

#### 不要用`get`初始化另一个智能指针或为智能指针赋值

- 名为`get`的函数返回一个**内置指针**，指向智能指针管理的对象
- `get`函数设计的**目的**：向不能使用智能指针的代码的函数**传递一个内置指针**
- **使用`get`返回的指针的代码不能`delete`此指针**，只有确保代码不会`delete`指针的情况下才能使用`get`
- **不要用`get`初始化另一个智能指针或为另一个智能指针赋值**，因为这样会导致**两个独立创建的智能指针指向相同的内存**，任意一个智能指针的引用计数变为0都会销毁所指对象，但此时代码仍可能尝试通过另一个智能指针访问该对象，导致未定义的行为

#### `reset`成员函数

- `reset`成员函数将智能指针**置为空**，若此时引用计数为0，**释放智能指针所指向的对象**

  ```c++
  p.reset();			// 解除对所指对象的绑定, 将p置为空
  p.reset(q);			// 解除绑定, 令p指向q所指向的对象
  p.reset(q, d);		// 解除绑定, 令p指向q所指向的对象, 且用d代替delete
  ```

#### `unique`和`use_count`成员函数

- `p.use_count()`，返回与`p`共享对象的智能指针数量 
- `p.unique()`，若`p.use_count()`为1则返回true，否则为false

### 智能指针和异常

- 使用**异常处理**的程序，**必须确保在异常发生后资源能被正确地释放**，其中一种方法是使用智能指针
  - 对于局部对象，无论是正常结束或发生异常导致函数退出，**局部对象都会被销毁**
  - 对于**直接管理的内存**，若发生异常，则由于**无法执行`delete`操作，导致内存泄漏**
- 智能指针与**哑类**
  - 对于**分配了资源**，但**没有定义析构函数**来释放资源的类，它要求用户显式地释放所使用的资源
  - 用户可能**忘记释放资源**，或**在资源分配和释放间发生了异常**，导致资源泄漏

#### 使用自定义的释放操作

- 默认情况下，`shared_ptr`指向动态内存，当其销毁时默认地执行`delete`操作

- 我们可以**定义一个函数代替**`delete`，而`shared_ptr`销毁时将调用该函数完成资源释放操作。这个函数称为**删除器**，他必须能完成对`shared_ptr`所保存指针进行释放的操作

  ```c++
  shared_ptr<Connection> p(&c, [](Connection* p) { p->disconnect(); });
  ```

  

#### 智能指针使用的标准规范

- 不使用**相同的内置指针值，初始化**（或`reset`）多个智能指针
- 不`delete` `get()`返回的指针
- 不使用`get()`初始化或`reset`另一个智能指针

- 如果使用智能指针管理的资源不是`new`分配的内存，应该传递给它一个**删除器**

### `unique_ptr`类

#### 定义和初始化`unique_ptr`

- `unique_ptr<T> u`，定义一个**空的**`unique_ptr`

- `unique_ptr<T, D> u`，定义一个空的`unique_ptr`，释放其所指对象时将调用类型为`D`的可调用对象

- `unique_ptr<T, D> u(d)`，定义一个空的`unique_ptr`，释放其所指对象时将调用类型为`D`的可调用对象`d`

- `unique_ptr`**拥有**其所指向的对象，某一时刻只能有一个`unique_ptr`指向一给定对象，因此`unique_ptr`**不支持拷贝或赋值操作**

- 初始化`unique_ptr`必须采用**直接初始化**形式，将其**绑定到一个`new`返回的指针上**

  ```c++
  unique_ptr<int> p(new int(42));
  ```

#### `release`和`reset`转移指针的所有权

- 我们**不能拷贝或赋值**`unique_ptr`，但可以通过`release`或`reset`将指针的所有权从一个`unique_ptr`转移给另一个`unique_ptr`

- `p.release()`，`p`放弃指针的所有权，将`p`置为空，并**返回指针**，返回的指针通常用于给另一个`unique_ptr`初始化或赋值

- `p.reset()`，**释放`p`所指对象，并将`p`置为空**

- `p.reset(nullptr)`

- `p.reset(q)`，放弃指针的所有权，**将`p`指向`q`所指对象**

- `p=nullptr`，释放`p`所指对象，将`p`置为空

  ```c++
  p1.reset(p2.release());
  // 将p1指向的对象释放, 并指向原p2指向的对象, p2被置为空
  ```

#### 传递`unique_ptr` 参数或返回`unique_ptr`

- 不能拷贝或赋值`unique_ptr`的例外，可以拷贝或赋值一个将要被销毁的`unique_ptr`，常用的是**从函数返回`unique_ptr`**

#### 向`unique_ptr`传递删除器

- `unique_ptr`默认情况下使用`delete`释放它所指对象，我们可以重载一个`unique_ptr`中默认的删除器
- `unique_ptr`管理删除器的方式，与`shared_ptr`不同。重载`unique_ptr`的删除器会**影响其类型和构造方式**
- 必须在尖括号中`unique_ptr`指向类型后，加上删除器的类型
- **创建或`reset`**此类型`unique_ptr`时，必须**提供一个指定类型的可调用对象作为删除器**



### `weak_ptr`类

- `weak_ptr`是一种不控制所指对象生存期的智能指针，它**指向一个`shared_ptr`管理的对象**
- 将一个`weak_ptr`绑定到一个`shared_ptr`**不会改变**`shared_ptr`**引用计数**，因此最后一个指向对象的`shared_ptr`被销毁时该对象就会被销毁，即使`weak_ptr`指向对象也不影响
- `weak_ptr<T> wp`定义一个空的`weak_ptr`
- `weak_ptr<T> wp(sp)`，定义一个`weak_ptr`，与`sp`指向相同的对象，我们**只能用**`shared_ptr`**初始化一个**`weak_ptr`
- `w=p`，`p`可以是`shared_ptr`或`weak_ptr`
- `w.reset()`，将`w`置为空
- `w.use_count()`，返回与`w`共享对象的`shared_ptr`的数量
- `w.expired()`，若`w.use_count()`为0则返回true
- `w.lock()`，若`expire`为true则返回一个空的`shared_ptr`，否则返回一个指向`w`的对象的`shared_ptr`

#### 使用`lock`访问`weak_ptr`的对象

- 由于`weak_ptr`的对象可能已经被销毁，因此必须通过`lock()`访问其对象

  ```c++
  if (shared_ptr<T> sp = wp.lock()) {
      //...
  }
  ```

## 12.2 动态数组

### `new`和数组

#### 使用`new`分配数组

- 让`new`分配一个对象数组，可以在类型名后**紧跟一对方括号**`[]`，在其中**指明要分配的对象的数目**，`new`分配要求数量的对象并**返回指向第一个对象的指针**

  ```c++
  int *p = new int[10];
  ```

- 指明要分配的对象的数目时，**不必是常量**

  ```c++
  int n = 10;
  int *p = new int[n];		// n可以是变量
  ```

- 使用**表示数组类型的类型别名**，则`new`表达式**不需要方括号**

  ```c++
  typedef int arrT[42];
  int* p = new arrT;		
  // int *p = new int[42];
  // 以上两条语句与是等价的
  ```

#### 分配数组得到一个元素类型的指针

- `new`分配数组的返回类型**并非数组类型**，而是**指向该数组元素类型的指针**
- 因为分配的内存不是数组类型，因此无法对动态数组**调用`begin`和`end`**
- 出于同样理由，无法对动态数组**使用范围for语句**

#### 初始化动态分配对象的数组

- 默认情况下，`new`分配的动态数组是**默认初始化**的
- 若在`new`分配数组后加上一对圆括号，则执行**值初始化**
- 还可以通过提供一个元素初始化器的**列表**进行初始化
  - 如果初始值数目小于数组大小，则剩余元素被**值初始化**
  - 如果初始值数目大于数组大小，则抛出`bad_array_new_length`**异常**

#### 动态分配一个空数组

```c++
int n = 0;
int* p = new int[n];
```

- 若`new`分配动态数组时，**大小为为0**，仍然是合法的
- `new`返回一个**合法的非空指针**，它保证与`new`返回的其他任何指针都不同。对于零长度数组来说，此指针像**尾后指针**一样
- 此指针**不能解引用**

#### 释放动态数组

- 特殊形式的`delete`，在`delete`后加上一对方括号

  ```c++
  delete[] p;
  ```

- 即使使用了数组类型别名，仍然要加上方括号对

  ```c++
  typedef int T[10];
  int *p = new T;
  delete p;		// 错误, 释放动态数组必须加上方括号对
  delete[] p;		// 正确
  ```

- `delete[]`语句将销毁动态数组中的每个元素，并释放对应的内存，数组中的元素是**按逆序销毁的**

- 如果在`delete`一个指向动态数组的指针时**忽略了方括号**，或者在`delete`一个指向单一对象的指针时错误使用了方括号，**其行为是未定义的**

#### 智能指针和动态数组

##### `unique_ptr`

- `unique_ptr`提供了可管理`new`分配的数组的版本

- 定义时，**在对象类型后面加一对方括号**

  ```c++
  unique_ptr<int[]> up(new int[10]);
  ```

- `unique_ptr`销毁所管理的指针时，会**自动调用`delete[]`**

- `unique_ptr`支持**下标运算符**，`u[i]`返回数组中位置`i`处的对象

  ```c++
  unique_ptr<int[]> up(new int[10]);
  for (size_t i = 0; i < 10; ++i)
      cout << up[i] << endl;
  ```

##### `shared_ptr`

- `shared_ptr`不支持直接管理动态数组，若希望使用`shared_ptr`，则**必须提供自定义的删除器**

  ```c++
  shared_ptr<int> sp(new int[10], [](int* p) { delete[] p; });
  ```

- 若不提供自定义的删除器，则会产生**未定义**的行为，因为`shared_ptr`使用`delete`销毁所指对象

- `shared_ptr`未定义下标运算符

### `allocator`类

- `new`将内存分配和对象构造组合在一起，`delete`将对象析构和内存释放组合在一起
- 没有默认构造函数的类无法通过`new`动态分配数组

#### `allocator`将内存分配和对象构造分离

- 定义在头文件`memory`中，将内存分配和对象构造分离

- 其分配的内存是**原始的、未构造的**

- 定义`allocator`时要**指明它分配的对象的类型**

  ```c++
  allocator<T> a;  // 定义allocator对象, 可以为类型为T的对象分配内存
  ```

- 用`allocator`**分配内存**

  ```c++
  a.allocate(n);		// 分配一段原始的、未构造的内存, 保存n个类型为T的对象
  ```

- 使用`allocator`**构造对象**

  ```c++
  a.construct(p, args);		// p是一个类型为T*的指针, 指向一块原始内存, args被传递给类型为T的构造函数
  ```

- **还未构造对象就使用原始内存，其行为是未定义的**

- 使用`allocator`**销毁对象**，用完对象后必须对每个元素调用`destroy`，它接受一个指针，对指向的对象执行该类型的**析构函数**

  ```c++
  a.destroy(p);		// p为T*类型的指针, 对p指向的对象执行析构函数
  ```

- 使用`allocateor`**释放内存**

  - `p`必须指向由`allocate`分配的内存
  - `n`必须与调用`allocate`分配内存时提供的大小参数相匹配

  ```c++
  a.deallocate(p, n);		// 释放从p开始的内存, 这块内存保存了n个类型为T的对象
  ```

#### 拷贝和填充未初始化内存的算法

- 标准库为`allocator`类定义了两个伴随算法（`copy`和`fill`），可以**在未初始化内存中创建对象**
- `uninitialized_copy(b, e, b2)`，从迭代器范围$[b, e)$拷贝元素到迭代器`b2`指定的未构造的原始内存中，假定`b2`指定的原始内存足够大
- `uninitialized_copy_n(b, n, b2)`，从迭代器`b`开始的范围中，拷贝n个元素到`b2`指定的原始内存中，假定`b2`指向的内存足够大
- `uninitialized_fill(b, e, t)`，在$[b,e)$指定的原始内存中创建对象，对象的值均为`t`的拷贝
- `uninitialized_fill_n(b, n, t)`，在`b`指定的原始内存中创建`n`个对象，对象的值均为`t`的拷贝，假定`b`指向的内存足够大

## **习题**

- 在此代码结尾处，`b1`和`b2`各包含多少个元素（`StrBlob`的定义详见P405）

  ```c++
  StrBlob b1;
  {
      StrBlob b2 = {"a", "an", "the"};
      b1 = b2;
      b2.push_back("about");
  }
  ```

  `b1`包含4个元素，`b2`被销毁

- 以下函数是否有错误？

  ```c++
  bool b() {
      int* p = new int;
      //...
      return p;
  }
  ```


- `process`是一个接受`shraed_ptr<int>`参数的函数，下列四个调用是否合法？

  ```c++
  auto p = new int();
  auto sp = make_shraed<int>();
  
  process(p);		// 非法
  process(sp);	// 合法	
  process(new int());	// 非法, shared_ptr的构造函数是explicit的
  process(shared_ptr<int>(p));	// 合法, 但此后不应再使用p
  ```

- 下列`unique_ptr`声明中，哪些是合法的？哪些可能导致后续程序出错？

  ```c++
  int ix = 1024;
  int *pi = &ix;
  int *pi2 = new int(2048);
  typedef unique_ptr<int> IntP;
  
  IntP p0(ix);		// 非法
  IntP p1(pi);		// 编译合法, 但pi并非动态内存
  IntP p2(pi2);		// 编译合法, pi2可能成为空悬指针
  IntP p3(&ix);		// 编译合法, 并非动态内存
  IntP p4(new int(2048)); // 合法
  IntP p5(p2.get());		// 编译合法, 独立定义使得两个unique_ptr指向同一个对象
  ```

  

