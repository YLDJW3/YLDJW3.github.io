---
title: 计网-运输层
date: 2022-02-24 19:40:17
tags: 
    - Computer Network
    - 面试
mathjax: true
categories: Computer Network
---

**计网运输层重要知识总结**

<!--more-->

# 2 运输层

## 2.1 概述和运输层服务

- 运输层协议为不同主机上的应用进程提供了**逻辑通信**，即应用进程利用运输层提供的逻辑通信功能彼此发送报文，而不用考虑承载这些报文的物理基础设施的细节
- 运输层协议**位于端系统**，而不是路由器
- 它将应用层报文转换为运输层分组，也称为**运输层报文段（segment）**，实现的方法可以是将**报文**划**分为较小的块**，每块加上一个**运输层首部**以生成**运输层报文段**，同时将其传递给网络层，**网络层**将其封装为**网络层分组**（即**数据报**）

### 运输层和网络层的关系

- **网络层**提供了**主机之间**的逻辑通信，**运输层**为**不同主机**上的**进程之间**提供逻辑通信
- **运输层协议**只工作在**端系统**中，将应用进程的报文移动到网络边缘（网络层）

- 运输层能提供的**服务**包括
  - **网络层**协议可能使**分组丢失、篡改和冗余**，但**运输层协议**仍能为应用程序提供**可靠数据传输服务**
  - 网络层不能保证运输层报文段的机密性，但**运输层协议**能够使用**加密**来确保应用程序报文不被入侵者窃取

### 因特网运输层概述

- 因特网提供的两种运输层协议为UDP和TCP
  - **UDP（用户数据报协议）**，为调用它的应用程序提供**不可靠、无连接**的服务
  - **TCP（传输控制协议）**，为调用它的应用程序提供**可靠、面向连接**的服务

## 2.2 多路复用与多路分解

### 基本概念

- 在**源主机**从**不同套接字**中收集**数据块**，并为每个数据块封装上**首部信息**从而生成**报文段（Segments）**然后将报文段**传递给网络层**，称为**多路复用**

- 在**接收端**，将运输层**报文段**中的**数据**交付到**正确的套接字**的工作称为**多路分解**
- 实际上，多路复用和多路分解的概念存在与各种计算机网络中。一般地，多路复用和多路分解与**某层的单一协议**何时被位于接下来的**更高层的多个协议使用**有关

- 运输层对多路复用的要求
  - **套接字**有**唯一标识符**
  - **报文段**有特殊**字段**指示该报文段**将要交付到的套接字**

- 运输层报文段包含**源端口号字段**和**目的端口号字段**
  - **端口号**是一个16bit的数，大小在**0-65535之间**
  - **0-1023**范围的端口号称为**周知端口号**，保留给周知应用层协议使用
  - 开发新的 用程序时，必须**分配一个端口号**

### 无连接的多路复用与多路分解

- 通常，应用程序的**客户端**让运输层**自动地分配端口号**，而**服务器端**则分配一个**特定的端口号**

- 一个**UDP套接字**是由一个**二元组**全面标识的，包含**目的IP地址**和**目的端口号**
  - 如果两个UDP报文段有不同的源IP地址或源端口号，但有**相同的目的IP地址和目的端口号**，那么将通过**相同的目的套接字**被定向到**相同的目的进程**

- **源端口号**的作用：作为**返回地址**的一部分使用，当客户端向服务器端发送了一个报文段后，如果服务器端想回发一个报文段，将从它收到的报文段中的源端口号取值，与客户端IP地址组成完整的返回地址

### 面向连接的多路复用与多路分解

- **TCP套接字**是由一个**四元组**标识的，即**源IP地址、源端口号、目的IP地址、目的端口号**
- 服务器可以支持很多并行的TCP套接字，每个套接字与一个进程相联系

### Web服务器与TCP

- Web服务器为**每条连接**都生成一个**新进程**，每个这样的进程都有自己的连接套接字
- 事实上，连接套接字并非与进程之间一一对应，当今的**高性能Web服务器**通常**只使用一个进程**，为每个**新的客户连接**创建一个具有**新连接套接字**的**新线程**

## 2.3 无连接运输: UDP

- 为什么使用UDP？

  - **能更为精细地控制何时发送数据**。只要应用进程将数据传递给UDP，UDP就会将数据打包至UDP报文段，并**立即传递给网络层**；而TCP有**拥塞控制**机制，当源和目的主机的链路变得拥堵时会**遏制运输层TCP发送方**。某些**实时应用**使用UDP，并将超出UDP服务外的功能作为应用的一部分实现
  - **无需连接建立**。TCP在开始数据传输之前需要经过**三次握手**，引入了**建立连接的时延**；而UDP却不需要任何准备即可进行数据传输

  - **无连接状态**。TCP需要**在端系统中维护连接状态**，包括接收和发送缓存，拥塞控制参数，序号与确认号的参数等；UDP不维护连接状态。某些专门服务器运行在UDP上以支持**更多活跃客户**
  - **分组首部开销小**。每个**TCP报文段**都有**20字节的首部**开销，而**UDP报文段**仅有**8字节**的首部开销

### UDP报文段结构

- **数据字段**是应用层数据
- **首部**包含4个字段：**源端口号**、**目的端口号**、**长度**和**检验和**
  - **长度**字段指示UDP报文段的**字节数**（**首部加数据**）
  - 接收方使用**检验和**检查该报文段中**是否出现了差错**

### UDP检验和

- UDP检验和提供了**差错检测**功能，确定当UDP报文段从源向目的地移动时，其中的比特是否发生改变
- **发送方**的UDP对**报文段首部**的**3个16bit字的和**进行**反码运算**，求和时遇到**溢出会被回卷**，得到的结果被放在UDP报文段的**检验和字段**

> 回卷指如果产生溢出，则将溢出的**1与16bit字继续求和**，该过程将**循环，直至计算结果不溢出**

- **接收方**的UDP对**报文段首部**的**4个16bit字求和**，如果得到的结果是65535（即**所有位都为1**），则说明**没有引入差错**

- 否则，UDP报文段出错，接收方**丢弃**该报文段，或者将受损的报文段交给应用程序并给出**警告**，UDP**无差错恢复能力**



## 2.4 可靠数据传输原理

- **可靠数据传输**为上层实体提供了一种服务抽象，数据可以通过一条**可靠的信道**进行传输，传输数据比特**不会受损或丢失**，并且是**按其发送顺序进行交付**的

- 实现这种服务抽象的是**可靠数据传输协议**，其**下层协议可能是不可靠的**

### 2.4.1 构造可靠数据传输协议

#### 经完全可靠信道的可靠数据传输：rdt1.0

- 条件**假设**
  - 信道完全可靠，**不会出错**
  - 接收方接收数据的速率能够与发送方发送数据的**速率一样快**
- 发送端，较高层的应用调用`rdt_send`，传递`data`，发送端生成分组`packet`并将其交给网络层
- 接收端，较低层的协议调用`rdt_rcv`传递分组`packet`，接收端接收分组`packet`，提取其中数据`data`并交付给对应的套接字

```c++
class Data { /* */ };
class Packet { /* */ };

void rdt_send(Data& data) {
    Packet packet = make_pkt(data);
    udt_send(packet);
}

void rdt_rcv(Packet& packet) {
    extract(packet, data);
    deliver_data(data);
}
```



#### 经具有比特差错信道的可靠数据传输: rdt2.0

- 条件**假设**
  - 信道中，分组的比特可能**受损**，但是接收端将按其发送的**顺序**收到分组

- **肯定确认**与**否定确认**
- **自动重传请求 (ARQ) 协议**，基于重传机制的可靠数据传输协议
  - **差错检测**，通过额外的比特检测分组的比特是否受损
  - **接收方反馈**，接收方提供明确的反馈信息给发送方，如肯定确认 (ACK)、否定确认 (NAK)
  - **重传**，接收方收到有差错的分组时，发送方重传该报文

- rdt2.0**内容**
  - 发送端有两个状态
    - 状态1：等待上层调用
    - 状态2：等待接收端的ACK或NAK
  - 发送端的状态转移
    - 状态1->状态2：接收到上层调用时，打包数据，发送一个分组
    - 状态2->状态2：接收到NAK，重传分组
    - 状态2->状态1：接收到ACK，回到状态1等待上层应用调用
  - 接收方的状态只有一个
    - 等待来自下层的调用
  - 接收方的状态转移时，行为不同
    - 如果比特受损，发送NAK
    - 如果分组没有出错，发送ACK
- rdt2.0**问题**
  - 发送方协议等待来自接收方的ACK或NAK时，不能发送报文，因此称为**停等协议**
  - 更严重的问题是，**没有考虑ACK或NAK报文比特受损的问题**

- 解决
  - 在**ACK和NAK报文**中也引入**差错检测**，当检测到报文比特受损时，采取以下措施的一种
  - 增加足够的校验和比特，以满足**差错恢复**功能
  - 收到受损的ACK或NAK分组时，**重传当前数据分组**。此举会在信道中引入**冗余分组**，接收端也要处理所收到的分组是**新分组**还是**上一次重传的分组**的问题。解决方法是引入**序号**。

#### 经具有比特差错信道的可靠数据传输: rdt2.1

- 引入**序号**，序号值为0或1，由此接收端可区分收到的分组是**新分组**还是**上次重传的分组**

- **序号**其实是数据**分组的字段**，由**发送方**对分组进行编号并填写该字段

- rdt2.1内容

  - 发送端状态为4个
    - 等待来自上层的调用（序号0）
    - 等待ACK或NAK（序号0）
    - 等待来自上层的调用（序号1）
    - 等待ACK或NAK（序号1）
  - 发送端状态转移
    - 状态1->状态2：接到上层调用，打包数据，序号字段为0，发送数据分组
    - 状态2->状态2：回答分组受损，或收到NAK，则重传当前数据分组
    - 状态2->状态3：收到没受损的ACK分组，进入状态3，等待上层调用
    - 状态3->状态4：接到上层调用，打包数据，序号字段为1，发送数据分组
    - 状态4->状态4：回答分组受损，或收到NAK，则重传当前数据分组
    - 状态4->状态1：收到没受损的ACK分组，进入状态1，等待上层调用
  - **接收端状态**有2个
    - 等待下层调用（序号0）
    - 等待下层调用（序号1）
  - 接收端状态转移
    - 状态1->状态2：下层调用，提取数据，没有受损且序号为0，则回传ACK报文
    - 状态1->状态1：下层调用，若分组受损，回传NAK报文；若序号为1，回传ACK报文
    - 状态2->状态1：下层调用，提取数据，没有受损且序号为1，则回传ACK报文
    - 状态2->状态2：下层调用，若分组受损，回传NAK报文；若序号为0，回传ACK报文

  > Q：为什么在状态1收到序号为1的报文，或在状态2收到序号为0时，要回传ACK报文？
  >
  > A：序号不符，说明这是由于发送端收到的ACK报文受损，导致发送端对该分组进行了重传，因此收到的是上一个分组的重传，此时应该回传ACK，从而让发送端接着发下一个分组

#### 经具有比特差错信道的可靠数据传输: rdt2.2

- 上述协议中的**NAK报文可以被取代**
  - 具体来说，我们将ACK分为ACK0和ACK1
  - 发送端发送一个序号为0的分组后，期望收到一个ACK0，此时假如它收到了ACK1，则说明它要重传当前分组
  - 假如接收端位于状态1，收到了受损的分组，或收到了序号为1的分组，则回发一个ACK1

#### 经具有比特差错的丢包信道的可靠数据传输: rdt3.0

- **发送方**负责**检测和恢复丢包**。它设定一个**定时器**，如果在规定时间内**没收到对应的ACK**，则**重传该分组**
- 由于没收到ACK并不一定是因为丢包，也可能是因为时延或ACK丢失，因此信道中引入了**冗余数据分组**，该问题可通过上述**序号**机制解决

- 定时器机制
  - 发送端**发送分组**时，**启动**计时器（包括第一次发送和重传）
  - 定时**中断**，**重传**
  - **收到**相应的**ACK**，**终止**计时器

### 2.4.2 流水线可靠数据传输协议

- rdt3.0性能问题
- 以**不停等**方式，允许发送方**发送多个分组而无需等待确认**，该技术被称为**流水线技术**

- 必须增加**序号范围**，因为每个输送中的分组必须有一个唯一的序号，而现在存在多个输送中的未确认报文
- 发送方和接收方应该**缓存多个分组**。发送方必须缓存所有发送但未接收的分组，以便重传
- 如何处理丢失、损坏及时延过大的分组，决定了所需的序号范围和缓存大小。解决**流水线差错恢复**的两种方法
  - **回退N步（GBN）**
  - **选择重传（SR）**

### 2.4.3 回退N步（GBN）

- 流水现中**发送但未确认的分组**不能超过**最大允许数N**
- 序号范围
  - **基序号 (base)**为最早的**未确认序号**
  - **下一个序号 (nextseqnum)**为最小的**未使用序号**
  - 把序号范围分为以下4端
    - $[0, base-1]$，已确认分组序号
    - $[base, nextseqnum-1]$，已发送未确认分组的序号
    - $[nextseqnum, base+N-1]$，当前允许使用的分组序号
    - $[base+N, ...)$，当前不能使用的序号
- 滑动窗口协议
  - 因为**允许未确认分组**的**序号范围**为$[base, base+N-1]$，可以看作一个**大小为N的窗口**，它会随着分组的确认不断向前**滑动**
  - 因此N被称为**窗口长度**，而**GBN协议**也被称为**滑动窗口协议**
- 分组序号字段的比特数决定了序号范围
  - 如果分组**序号字段**的**比特数为k**，则可用**序号范围**是$[0, 2^k-1]$
  - 所有涉及序号的运算都必须用**模$2^k$运算**（由于分组数可能远超$2^k$，因此序号被**循环使用**，$2^k-1$序号的下一个为0）
- GBN协议引入了**变量`base`和`nextseqnum`**
- GBN发送方响应三种类型的事件
  - **上层调用**，如果发送窗口已满则告知上层稍后再试，或缓存数据稍后发送，或使用同步机制允许上层仅当窗口未满时才调用`rdt_send()`；如果窗口未满，则产生分组并发送，并更新`nextseqnum`
  - **收到ACK**，如果收到序号为$n$的ACK，则代表接收方已正确接收到**序号为$n$的分组**及**之前的所有分组**，这里采用了**累积确认**机制
  - **定时中断**，GBN中的定时器代表**最早的已发送未确认分组所用的计时器**，定时中断意味着该分组丢包，发送方**重传所有已发送但未确认的分组**。
  - **定时器的行为**。发送分组时，如果定时器未启动则将其启动。收到ACK时，如果还有未确认的分组，则重新开始定时器，如果没有未确认的分组，则终止计时器。触发定时中断时，重传所有已发送未确认发组并重启计时器
- GBN接收方行为
  - 维护变量`expectedseqnum`，表示**下一个按序接收的分组序号**
  - 如果收到的分组序号等于`expectedseqnum`，将其交付给上层，同时回传ACK报文
  - 如果收到的分组序号不等于`expectedseqnum`，直接**丢弃该分组**

### 2.4.4 选择重传（SR）

- **GBN**存在的**问题**：**单个分组的差错**会引起**发送方重传大量分组**

- 选择重传协议让发送方**仅重传它怀疑**在接收方**出错的分组**，避免不必要的重传

- SR与GBN的区别是
  - 发送方**滑动窗口**中**部分分组可能已被确认**
  - 接收方将**确认一个正确分组**，不管其是否按序到达，失序的分组将被**缓存**直至所有丢失分组都被接收
  - 发送方为**每个分组都设定一个计时器**
  - **接收方**也需要维护**大小为N的窗口**，**基序号`rcv_base`**表示它期望收到的下一个分组序号
    - 当收到序号为`[rcv_base, rcv_base_+N-1]`的正确分组，将缓存并回传ACK
    - 特别地，若收到序号为`rcv_base`的分组将交付给上层并前移窗口
    - **序号在`[rcv_base-N, rcv_base-1]`的正确分组，将回传ACK**，这是由于发送方和接收方**窗口不同步**决定的，接收方必须给这些分组回传ACK
- SR协议的**窗口长度**必须小于等于**序号空间大小的一半**，即

$$
N \leq 2^{k-1}
$$

### 可靠数据传输机制及用途总结

- **检验和**，检验分组是否**比特受损**

- **定时器**，解决**丢包**问题，如果**超时则重传分组**，引入了冗余数据分组

- **序号**，解决冗余数据分组，分组序号空隙使接收方检测出分组丢失问题，分组序号重复使接收方检测出冗余分组

- **确认**，接收方告诉发送方分组已被正确接收

- **否定确认**，接收方告诉发送方某个分组未正确接收

- **窗口、流水线**，**流水线**允许发送方**发送多个分组而不必等待确认**；为了应对差错、丢包等问题，设定窗口，**发送方只允许发送序号在窗口内的分组**，窗口长度可根据接收方接收和缓存报文的能力、网络的拥塞程度等设定

  > 为了应对差错、丢包等问题，发送方可能需要重传所有发送未确认的分组（GBN），或者接收方必须缓存所有窗口内的分组（SR），而无论使用哪种协议发送方都得缓存所有发送未确认的分组，因此必须设定窗口大小N



## 2.5 传输控制协议TCP

- TCP报文段的结构是怎样的？
- TCP报文段的序号和确认号是怎样的？
- Telnet的工作原理是怎样的？
- TCP如何估计往返时间，如何设置超时重传的时间间隔？
- TCP如何提供可靠数据传输服务？
- TCP如何管理超时时间间隔？
- 什么是快速重传？
- TCP是GBN还是SR？
- TCP的流量控制是怎样的？
- TCP的三次握手、四次挥手是怎样的？
- TCP连接状态的FSM是怎样的？
- TCP的拥塞控制原理是怎样的？

### 2.5.1 TCP连接基本概念

- **全双工服务**、**点对点**、**三次握手**

- **发送缓存**：当客户进程通过套接字传递数据流，数据被TCP存储在该连接的发送缓存，TCP从发送缓存中取出数据将其传递到网络层
- TCP从缓存中取出并让如报文段中的数据数量受限于**最大报文段长度**（Maximum Segment Size，**MSS**），MSS是指报文段里**应用层数据的最大长度**，而**不是包括首部的TCP报文段的最大长度**

- **TCP连接**的组成包括，一台**主机上的缓存、变量**和与进程连接的**套接字**，与另一台主机上的缓存、变量和与进程连接的套接字

### 2.5.2 报文段结构

- **TCP报文段**由**首部字段**和**数据字段**组成
  - **MSS**限制了**数据字段**的最大长度
  - **首部字段**一般是**20字节**，包含
    - **源端口号**、**目的端口号**
    - **32bit的序号字段**
    - **32bit的确认号字段**
    - **4bit的首部长度字段**
    - **6bit的标志字段**，包括**CWR、ECE**、URG、**ACK**、PSH、**RST**、**SYN**、**FIN**，其中URG和PSH未被使用
    - **16bit的接收窗口字段**，指示接收方愿意接受的字节数量
    - **检验和**、**紧急数据指针**，其中紧急数据指针未被使用
    - 可选与变长的**选项字段**

- 序号和确认号
  - TCP把数据看作无结构的、有序的字节流，**序号**建立在传送的**字节流**之上，而不是传送的报文段的序列上，一个**报文段的序号**是其**首字节的字节流编号**
  - TCP连接的双方都可以**随机**地选择**初始序号**
  - **确认号**是接收端**希望**从发送端**收到的下一个字节的序号**

- Telnet是用于远程登录的应用层协议，基于TCP连接，用户键入的**每个字符**都被发送至远程主机（因此Telnet中**TCP报文段的长度一般为21**，**数据**占据**1字节**，首部占据20字节），远程主机将回送每个字符的副本给用户，并显示在Telnet用户的屏幕上

- **捎带**：客户到服务器的数据的确认，被装载在一个承载服务器到客户的数据的报文段中，这种确认是被捎带在服务器到客户的报文段中的

### 2.5.3 往返时间的估计与超时

- TCP采用**超时/重传**机制处理报文段的丢失问题，需要解决的是
  - 如何设置**超时间隔长度**？超时间隔必须大于往返时间
  - 如何**评估往返时间**？
  - 是否应为所有未确认的报文段**各设置一个定时器**？

#### 估计往返时间

- 报文段的**样本RTT**是从某报文段发出到该报文段确认被收到之间的时间量，表示为**SampleRTT**
- 大多数TCP的实现，仅在某个时刻做一次SampleRTT的测量，而不会为每个发送的报文段测量一个SampleRTT，且不为已被重传的报文段计算SampleRTT

- 由于路由器的拥塞和端系统负载变化，SampleRTT也会随之改变，因此维持**SampleRTT的均值EstimatedRTT**，$\alpha=0.125$是其典型值

$$
EstimatedRTT= (1-\alpha)EstimatedRTT+\alpha \cdot SmapleRTT
$$

- 新增RTT偏差$DevRTT$，用于**估算$SampleRTT$偏离$EstimatedRTT$的程度**，$beta=6$

$$
DevRTT=(1-\beta)DevRTT+\beta\cdot |SampleRTT-EstimatedRTT|
$$

#### 设置和管理重传超时间隔

- TCP将**超时间隔**设置为EstimatedRTT加上一定余量，即

$$
TimeoutInterval=EstimatedRTT+4\cdot DevRTT
$$

- **初始TimeoutInterval**一般设置为**1秒**
- 当**超时重传**时，超时间隔会**加倍**

### 2.5.4 可靠数据传输

- TCP在**IP不可靠**的尽力而为服务上，创建了一种**可靠数据传输服务**，确保进程从其接收缓存中读出的数据流是**无损坏**、**无间隙**、**非冗余**、**按序**的数据流

- 如果为每个发送未确认的报文段都设定一个计时器，则开销太大，TCP使用**单一的重传计时器**，其超时间隔未`TimeoutInterval`

- TCP**发送方**的简化描述
  - **从上层应用接收数据**，生成具有序号`NextSeqNum`的TCP报文段，若计时器未运行则启动计时器，并向网络层传递报文段，更新`NextSeqNum`
  - 定时器**超时**，**重传**具有**最小序号**但**未确认的报文段**，启动计时器
  - **收到ACK**，且ACK字段值为y，如果`y>SendBase`（说明这不是冗余ACK），则**更新`SendBase=y`（累积确认）**，在此基础上如果当前仍有未确认的报文段则**重启计时器**，否则终止计时器

- **超时间隔加倍**
  - 每次TCP**超时重传**时都会将下一次的**超时间隔设定为先前值的两倍**
  - 但是，**收到上层应用调用**或**收到ACK**时`TimeoutInterval`将**重新由最近的`EstimatedRTT`和`DevRTT`值计算**

- **快速重传**

  - **冗余ACK**，指**再次确认**某个报文段的ACK

  - 当接收方收到报文段的序号大于他期望的下一个报文段序号，即**数据流中存在间隔**，它会对已经接收到的**最后一个按序字节**数据进行**重复确认（冗余ACK）**
  - 如果TCP发送方接收到对相同数据的**3个冗余ACK**（即收到对该数据的4个ACK），他认为这个报文段之后的下一个报文段已经丢失，TCP**不等待**该报文段的**定时器**超时，而是**执行快速重传**

- **回退N步** + **选择重传**
  - TCP是**累积确认**的，发送方只需要维持**已发送未确认的字节的最小序号**`SendBase`，和**下一个要发送的字节的序号**`NextSeqNum`
  - 同时，TCP**接收方**会将正确接受但失序的**报文段缓存**起来，发送方重传时不必将窗口中的所有报文段重传

### 2.5.5 流量控制

- **流量控制**是一个**速度匹配服务**，让发送方的**发送速率**与接收方的**读取速率相匹配**

- TCP**发送方**维护一个**接收窗口**变量，指示**接收方还有多少可用的缓存空间**

- TCP接收方为该连接分配一个**接收缓存**，其**大小为`RcvBuffer`**，其应用进程从该缓存中读取数据，定义变量
  - `LastByteRead`，代表应用进程从缓存读出的最后一个字节的序号
  - `LastByteRcvd`，代表接收方放入接收缓存的数据流的最后一个字节的序号
  - TCP不允许分配的缓存溢出，因此

$$
LastByteRcvd - LastByteRead \leq RcvBuffer
$$

- **接收窗口**用`rwnd`表示，根据接收缓存的可用空间设置
  $$
  rwnd=RcvBuffer-(LastByteRcvd-LastByteRead)
  $$

  - `rwnd`是动态变化的
  - 接收方在向发送方发送的TCP报文段的接收窗口字段放入`rwnd`，以告知其接收缓存还有多少可用的空间

  - 特别地，当接收缓存已满时，接收窗口`rwnd`的值为0

- 对于发送方，跟踪两个变量`LastByteSent`和`LastByteAcked`，表示最后一个发送的字节的序号，以及最后一个确认的字节的序号，而`LastByteSent-LastByteAcked`表示其发送但未确认的字节数，发送方应该保证
  $$
  LastByteSent-LastByteAcked \leq rwnd
  $$

- 特别地，当`rwnd`为0时，代表接收缓存已满。此时若发送方不发送任何TCP报文段，而接收方也没有任何数据要发送给发送方，则当接收方的应用程序读出部分数据，即接收缓存空间恢复后，发送方也无法获取该信息。因此规定，当**接收窗口为0时，发送方继续发送只有一个字节数据的报文段**

- 由于UDP不提供流量控制，因此接收缓存已满时，再收到的报文段中的数据将被丢弃

### 2.5.6 TCP连接管理

#### TCP连接的创建过程：三次握手

- 第一次握手：**客户端**TCP向服务器端TCP发送一个特殊的TCP报文段，**不包含应用层数据**，报文段首部的**SYN比特位置为1**，称为**SYN报文段**。客户端**随机**选择一个**初始序号 (`client_isn`)**，将其放置于该起始的SYN报文段的**序号字段**中
- 第二次握手：**服务端**接收到该SYN报文段，**分配TCP缓存和变量**，并向该客户TCP发送允许连接的报文段，**不包含应用层数据**，**SYN比特**被置为1，**确认号字段**置为`client_isn+1`，并选择服务端自己的**初始序号`server_isn`**，将其置于TCP报文段首部的**序号字段**，该报文段称为**SYNACK报文段**
- 第三次握手：客户TCP收到SYNACK报文段后，给连接**分配缓存和容量**，客户主机向服务端发送**另一个报文段**，对服务器的允许连接的报文段进行**确认**，即将`server_isn+1`放入报文段的确认号字段，SYN比特置为0。该报文段**可以携带应用层数据**

#### 为什么需要三次握手，而不是两次握手？

- 两次握手机制可能导致**历史失效连接**的建立
  - 设想客户端向服务端发送了一个**SYN报文段**（第一次握手），由于某些原因该报文段**滞留**在网络中但**未丢包**
  - **客户端**由于长时间未收到SYNACK报文段因此已**退出连接**
  - 一段时间后，网络恢复，**服务端**收到该**SYN报文段**并**发送SYNACK报文段**，并分配缓存和变量。服务端为连接分配了资源，但它无法收到来自客户端的任何报文段
- 通俗地讲，**第二次握手**能让**客户端**知道双方的**连接是畅通的**，**第三次握手**能让**服务端**知道双方的连接是畅通的

#### TCP连接的终止过程：四次挥手

- **客户**TCP向服务器进程发送特殊的TCP报文段，**设置标志位FIN**，称为**终止报文段**
- **服务器**收到该报文，回送一个**确认报文段**
- **服务器**向客户发送自己的**终止报文段**，设置标志位FIN
- **客户**收到该终止报文段，回送一个**确认报文段**。此时，两台主机上用于该连接的所有资源都被释放

#### 为什么需要四次挥手

- **客户**向服务端发送**终止报文段**，隐式地指明**客户已经没有任何数据要发送**了
- **服务端**此时可能**仍有要向客户端发送的数据**，因此它不能直接回送终止报文段，它会先对客户的终止报文段进行**确认**
- **服务端**已经完成所有数据的发送了，此时它可以向用户发送**终止报文段**
- **客户**收到服务端的终止报文段，由于它肯定已经没有要处理的数据了，因此它对该报文段进行**确认**，并且**终止连接**
- 理解：由于TCP是**全双工**的，因此**两个方向的连接需要单独关闭**，关闭一个方向的连接需要一个终止报文段和一个ACK，因此总共需要四次挥手

#### TCP的有限状态自动机模型FSM

- **客户端**

  - 初始状态为`CLOSED`，当主动发送**SYN报文段**（第一次挥手）后，进入`SYN_SENT`状态
  - 位于`SYN_SENT`状态时，如果收到服务端回送的**SYNACK报文段**，回送**ACK**（第三次挥手），进入`ESTABLISHED`状态
  - 位于`ESTABLISHED`状态时，如果想终止连接，向服务端发送**终止报文段**，进入`FIN_WAIT1`状态
  - 位于`FIN_WAIT1`状态时，如果收到服务端**对终止报文段的确认**，则进入`FIN_WAIT2`状态
  - 位于`FIN_WAIT2`状态时，如果收到**服务端的终止报文段**，则**回送ACK**，并进入`TIME_WAIT`状态
  - 位于`TIME_WAIT`状态时，如果刚刚对终止报文段的确认丢失，则**重传ACK**。经过一定时间后（30秒、1分钟或2分钟），关闭连接并进入`CLOSED`状态

  > TIME_WAIT状态的作用：假如客户端发送完ACK后立刻关闭
  >
  > - 如果该**ACK丢失**，则服务端会**重发FIN报文段**，此时由于客户端已关闭连接，它会**回应一个RST**，引起异常
  > - 此外，如果客户端关闭该连接后又**立刻在同一个端口上建立通信**，上次的连接**残留的数据包**会被误以为是本次连接的数据
  >
  > TIME_WAIT的时间是怎么决定的
  >
  > - TIME_WAIT的时间是**2MSL**，**MSL是Maximum Segment Lifetime**，指任何报文**在网络上存在的最长时间**，超过这个时间报文将被丢弃
  > - 当客户端发送确认服务端的FIN报文段后，如果ACK丢失，则最多经过1MSL服务端会重发FIN报文段，最多再经过1MSL该重发的FIN报文段会到达客户端
  >   - 如果2MSL内收到了该重传的FIN报文段，客户端会重传ACK，并重置计时器
  >   - 如果2MSL内没收到重传的FIN报文段，就可以认为服务端已经收到了ACK，客户可以关闭TCP连接

- **服务器端**

  - 初始状态为`CLOSED`，当服务器的应用程序创建一个**监听套接字**时，进入`LISTEN`状态
  - `LISTEN`状态下，收到客户的**SYN报文段**（第一次握手），将**回应SYNACK报文段**（第二次握手），并进入`SYN_RCVD`状态
  - `SYN_RCVD`状态下， 收到客户的**ACK报文段**（第三次握手），将进入`ESTABLISHED`状态
  - `ESTABLISHED`状态下，若收到客户的**FIN报文段**，将**确认**，并进入`CLOSE_WAIT`状态
  - `CLOSE_WAIT`状态下，此时服务器端需要**处理完要发送的数据**，然后**发送FIN报文段**，并进入`LAST_ACK`状态
  - `LAST_ACK`状态下，如果收到客户端**对自己FIN报文段的确认**，即可关闭TCP连接，进入`CLOSED`状态

## 2.6 TCP拥塞控制机制

- TCP使用端到端拥塞控制，让每个发送方根据感知到的网络拥塞程度限制其发送速率
- 如果TCP发送方没感知到拥塞，则增加发送速率；若感知到有拥塞，则降低发送速率
- 关键问题
  - TCP发送方**如何限制**其发送速率？
  - TCP发送方**如何感知**网络的拥塞程度？
  - TCP发送方采用**何种算法**改变发送速率？

### TCP发送方限制发送速率的方法

- 维护额外变量拥塞窗口`cwnd`，结合流量控制中的接收窗口`rwnd`，TCP发送方的已发送未确认字节数被限制为
  $$
  LastByteSent - LastByteAcked \leq min\{cwnd, rwnd\}
  $$

- 忽略接收窗口，忽略发送时延和丢包，则每个RTT的起始点，发送方能向连接发送的字节数为$cwnd/RTT$ 字节/秒，因此**通过改变`cwnd`就能改变发送速率**

### TCP感知网络拥塞的方法

- 报文段丢失意味着拥堵，因此**丢包时降低TCP发送速率**
- ACK指示网络正向接收方交付发送方的报文段，因此**收到ACK时提高TCP发送速率**
- **带宽检测**，除非出现丢包事件，否则TCP将**增加其速率**

### TCP拥塞控制算法

- 主要包括慢启动、拥塞避免、快速恢复三个部分（部分资料里把**快速重传**也算作拥塞控制）

#### 慢启动

- TCP连接开始时，设置`cwnd`的**初始值为1 MSS**，则初始发送速率为MSS/RTT
- **每接收到1个ACK**时，就**增加1个MSS**

- 慢启动阶段发送速率将**指数增长**

- 慢启动的状态转移

  - 发生1个由**超时**指示的**丢包事件**后，**变量慢启动阈值`ssthresh`**被设置为`cwnd/2`，`cwnd`设置为1并**重新开始慢启动过程**

  - 若**`cwnd`大于等于`ssthresh`**，将结束慢启动并进入**拥塞避免模式**
  - 若检测到**3个冗余ACK**，TCP执行**快速重传**，进入**快速恢复**状态

#### 拥塞避免

- 进入**拥塞避免**，意味着`cwnd`已经达到上次遇到拥塞时的值的一半，此时不能将其翻倍，而是**每个RTT**增加**1个MSS**（注意慢启动时，对**每个ACK增加1个MSS**，因此理想时每个RTT都会使`cwnd`翻倍）
- 拥塞避免的状态转移
  - 发生1个由超时指示的丢包事件，更新`ssthresh`，`cwnd`设置为1并重新开始慢启动
  - 发生3个冗余ACK，将`cwnd`减半，`ssthresh`设为`cwnd`减半后的值，然后`cwnd`加上3个MSS（对应3个冗余ACK），进入快速恢复状态

#### 快速恢复

- 对收到的**每个冗余ACK**，**增加一个MSS**
- 当**丢失报文段的一个ACK**到达时，TCP降低`cwnd`并进入**拥塞避免**状态
- 如果超时，`ssthresh`设置为`cwnd/2`，`cwnd`设置为1并进入慢启动状态

### 拥塞控制总结

- 当发生**超时**指示的丢包，执行以下变量更新然后进入**慢启动模式**

  ```c++
  ssthresh = cwnd / 2;
  cwnd = 1;
  ```

- 当发生**三次冗余ACK**指示的丢包，执行以下变量更新，进行**快速重传**，进入**快速恢复**模式

  ```c++
  ssthresh = cwnd / 2;
  cwnd = ssthresh;
  cwnd += 3 * MSS;
  ```

- 快速恢复过程，如果**收到缺失报文段的ACK**，则进入**拥塞避免**模式

  ```c++
  cwnd = ssthresh;
  ```

- 不同模式下`cwnd`的**增长模式**

  - **慢启动**，对于每个ACK增加一个MSS
  - **拥塞避免**，对于每个RTT增加一个MSS（实践中常用的方法，是对每个ACK增加$MSS*MSS/cwnd$）

  > 因为一个RTT传输的报文数为cwnd/MSS，因此一个RTT增加量为
  >
  > $\frac{cwnd}{MSS} \times \frac{MSS \cdot MSS}{cwnd}=1MSS$

  - **快速恢复**，对于每个冗余ACK增加一个MSS

