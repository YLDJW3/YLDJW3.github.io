---
title: C++ Primer Chapter 7
date: 2022-02-13 22:11:23
tags: C++
categories: C++
mathjax: true
---

# 第七章 类

## 7.1 定义抽象数据类型

### 实现Sales_data类

#### 接口

- `isbn`成员函数，用于返回对象的ISBN编号
- `combine`成员函数，用于将一个Sales_data对象加到另一个对象上
- `add`函数，执行两个Sales_data对象的加法
- `read`函数，从`istream`中读取数据到Sales_data对象中
- `print`函数，将Sales_data对象的值输出到`ostream`

#### 定义成员函数 

- **成员函数的声明必须在类的内部，定义则既可在类的内部，也可在类的外部**

##### 定义在类内部的成员函数默认是inline的

##### `isbn`函数

- 返回`Sales_data`的书本编号

```c++
std::string isbn() const { return bookno; }
```

#### this

- 成员函数通过**一个名为`this`的额外的隐式参数访问调用它的那个对象**，当我们调用成员函数时，用请求该函数的对象的地址初始化`this`
- 在成员函数内部，我们可以直接使用调用该函数的对象的成员。**任何对类成员的直接访问，都被看做this的隐式引用**，所以当`isbn`使用`bookno`时，就像我们使用了`this->bookno`一样

```c++
std::string isbn() const { return this->bookno; }
// 尽管没必要, 但isbn可如上定义
```

- `this`是一个**常量指针**，不允许改变`this`的地址，任何自定义名为`this`的参数或变量的行为都是非法的

#### const成员函数

- `isbn`函数形参列表后紧跟着`const`，这里**const的作用是修改隐式`this`指针的类型**
- 形参列表的const表明`this`是一个指向常量的指针，因此`this`是**一个指向常量的常量指针**
- 使用const的成员函数称为**常量成员函数**

#### 类作用域

- 类本身是一个作用域
- 编译器分两步处理类，先编译成员的声明，再处理成员函数体。因此**成员函数体可随意使用类中的其他成员**，无需在意声明次序

#### 在类外部定义的成员函数

- 成员函数必须在类内声明，但允许在类外进行定义
- 类外部定义的成员函数必须**包含它所属的类名**

##### `avg_price`成员函数

```c++
double Sales_data::avg_price() const {
    if (units_sold == 0)
        return 0.0;
    else
        return revenue / units_sold;
}
```

<!--more-->

#### 定义一个返回this对象的函数

##### `combine`成员函数

```c++
Sales_data& Sales_data::combine(const Sales_data& rhs) {
    units_sold += rhs.units_sold;
    revenue += rhs.revenue;
    return *this;
}
```

- `combine`应该返回指向调用该函数的对象的引用，而`this`存放了该对象的地址，因此对其解引用即可得到指向该对象的引用

#### 定义类相关的非成员函数

- 如果函数在概念上属于类，但不是类的成员函数，那么**一般也和类在同一个头文件中声明**，这样用户使用类接口的任何部分都只需引入一个头文件

##### 定义`read`函数和`print`函数

```c++
std::ostream &print(std::ostream& os, const Sales_data& item) {
    os << item.isbn() << " " << item.units_sold << " " << item.revenue << " " << item.avg_price();
    return os;
}

std::istream &read(std::istream& is, Sales_data& item) {
    double price = 0;
    is >> item.bookno >> item.units_sold >> price;
    item.revenue = price * item.units_sold;
    return is;
}
```

- `read`和`print`接收的都是IO类型的引用，这是因为IO类不能被拷贝，只能通过引用传递
- 此外，输入输出会改变流的内容，因此无法声明为对常量的引用，只能是普通引用

##### 定义`add`函数

```c++
Sales_data add(const Sales_data& item1, const Sales_data& item2) {
    Sales_data item = item1;
    item.combine(item2);
    return item;
}
```



### 构造函数

- 类定义了其对象被初始化的方式，通过一个或几个特殊的成员函数控制其对象初始化的过程，这些函数称为**构造函数**
- 构造函数用于**初始化类对象的数据成员**，只要类的对象被创建，就会执行构造函数

- 构造函数的基本特点

  - 构造函数**没有返回类型**

  - 函数名**与类名相同**
  - **可以有多个构造函数**，与其他重载函数类似
  - 构造函数**不能声明为const**，即使是const对象在初始化过程也可以向其写值

#### 合成的默认构造函数

- 如果类**没有显式地定义任何构造函数**，则**编译器会隐式地定义一个默认构造函数，称为合成的默认构造函数**
- 默认构造函数的行为
  - 如果没有**类内初始值**，就执行**默认初始化**

#### 不能依赖于合成的默认构造函数

- 只有类没有定义任何构造函数时，编译器才会隐式地定义合成的默认构造函数
- 对于**内置类型或复合类型**，若没有提供类内初始值，将执行**默认初始化**，**其值是未定义的**
- 有时候编译器不能为某些类合成默认的构造函数

- 因此，定义了其他构造函数后，应该**自定义一个默认构造函数（形参列表为空）**

#### 给`Sales_data`定义构造函数

- 默认构造函数

  ```c++
  Sales_data() = default;
  ```

##### `=default`的含义

- C++11规定如果需要默认行为，可以通过在参数列表后写上`=default`来要求编译器生成构造函数
- `=default`既可以与声明一起出现在类的内部，也可以作为定义出现在类的外部
- 这时候，编译器生成构造函数会执行默认初始化，因此**只有保证数据成员的值不会是未定义时，才使用`=default`**

##### 构造函数初始值列表

```c++
Sales_data(const std::string& b, unsigned u, double p): bookno(b), units_sold(u), revenue(p*u) {}

Sales_data(const std::string& b): bookno(b) {}
```

- 构造函数初始值列表，用于为新创建对象的一个或几个数据成员赋初值
- 数据成员**名字后面紧跟括号括起来的成员初始值**，不同成员的初始化通过**逗号隔开**

- 若某个数据成员被构造函数初始值列表忽略时，它将以合成默认构造函数相同的方式进行初始化，及若有类内初始值则初始化为该值，否则默认初始化。因此没有提供类内初始值的内置类型，不应被构造函数初始值列表忽略

##### 在类外定义构造函数

```c++
Sales_data::Sales_data(std::istream& is) {
    read(is, *this);
}
```

### 拷贝、赋值、析构

- 类还需要控制拷贝、赋值和销毁对象时发生的行为
- 若不主动定义，则编译器将替我们合成。

#### 某些类不能依赖于合成的版本

- 某些类中合成的版本无法正常工作，特别是**类需要分配对象之外的资源时**



## 7.2 访问控制与封装

### 什么是封装？封装有何优点？

- 实现了类的接口与实现的分离，类对外隐藏了其实现细节，类的用户只需使用接口即可，无法访问实现部分
- 封装的优点是
  - 确保用户代码**不会无意间破坏封装对象的状态**
  - 被封装的类的具体实现细节可随时改变，而**无需调整用户级别的代码**

### 访问说明符

- C++通过**访问说明符**加强类的封装性

- **public说明符**后的成员在整个成员内可以被访问
- **private说明符**后的成员只能被类的成员函数访问

- 一个类可以包含0或多个访问说明符，每个访问说明符的出现次数也没有限制

### class和struct的区别

- class和struct都可用于定义类
- 唯一区别是默认访问权限
  - struct在第一个访问说明符前的成员是public的
  - class在第一个访问说明符前的成员是private的

### 友元

- 想让其他类或非成员函数访问类的非公有成员，则可以**让其他类或函数成为自己的友元（friend）**

#### 把函数作为友元

- 在类定义中**增加一条以`friend`关键字开头的函数声明**

#### 友元声明的位置

- 友元声明必须在类定义内部，但在哪个位置不限，它不是类成员，不受访问说明符的约束
- 但最好把友元声明**集中在类定义的开始，或类定义的结束位置**

#### 友元声明

- 友元声明并非通常意义上的函数声明，因此除了在类内部进行友元声明，**使用该函数前还需要有该函数本身的声明**
- 一般将该函数本身的声明与类定义放在同一个头文件中

## 7.3 类和其他特性

### 定义类型成员

- 类可以自定义某种类型在类中的别名，该**类型名字也是类的成员，存在访问限制**，可以是public或private中的一种
- 定义类型的成员**必须先定义后使用**，这与普通成员不一样

### 令成员作为内联函数

- 定义在类内部的成员函数自动inline
- 在**类内部声明函数时**，通过inline声明该成员函数为内联
- 还可以**在类外部定义时**，通过inline声明该成员函数为内流

### 重载成员函数

- 与非成员函数类似

### 可变数据成员

- 通过在变量声明中假如`mutable`关键字，使得该成员为可变数据成员
- **可变数据成员永远不会是const的，即使它是const对象的成员**
- **可以通过const成员函数，改变可变数据成员的值**

### 类数据成员的初始值

- 当我们提供类内初始值时，**必须用`=`的初始化形式，或者`{}`括起的直接初始化形式**

### 返回`*this`的成员函数

- 对于普通成员函数，返回`*this`就是返回指向本类型对象的引用

- 对于**const成员函数**，返回`*this`意味着返回**指向本类型常量对象的引用**。也就是说从const成员函数返回`*this`，得到的是常量引用

- 基于const的重载，有时候我们希望得到的是普通引用，而非常量引用，因此对于返回`*this`的成员函数，假如它不修改对象，那么可以定义重载函数，一个是const成员函数，另一个是普通成员函数

  ```c++
  const Screen& display() const { reutrn *this; }
  Screen& display() { return *this; }
  // 如上所示, const对象调用将匹配第一行版本, 非常量对象调用将匹配第二行版本
  ```

  

### 类类型

- **每个类定义了唯一的类型**，即使两个类的成员完全一样，这两个类也是不同的类型

#### 类的声明

- 类可以仅声明而先不定义它
- 在类声明后、定义前，它是一种**不完全类型**

#### 不完全类型可使用的场景

- 定义指向该类型的指针或引用
- 声明（但不能定义）以该类型作为参数或返回类型的函数

#### 类的成员类型不能是该类自己

- 由于上述不完全类型的原因，**类的成员类型不能是类自己**
- 但类的成员可以是指向该类的指针或引用

### 友元

- 除了把普通函数定义为友元外，还可以**把其他类定义为友元，还可以把其他类的成员函数定义为友元**

#### 类之间的友元关系

- 指定友元类，可在类定义的开头位置添加以下友元声明，则类C成为友元类

  ```c++
  friend class C;
  ```

- 如果一个指定了友元类，则友元类的成员函数可以访问此类的private和public成员
- 友元不具有传递性。每个类负责控制自己的友元类或友元函数。

#### 令成员函数作为友元

- 将某个类的某个成员函数声明为友元，则该类的该成员函数能否访问此类的private和public成员

- 需要明确指出该成员函数属于哪个类

  ```c++
  friend int C::func(int);
  // 该友元是C类的成员函数func
  ```

##### 令成员函数作为友元的定义步骤

- 假设**想要令类A的成员函数f作为类B的友元**，必须按照以下方式设计程序
  - 定义类A，声明函数f，但不能定义它
  - 定义类B，包含对`A::f`的友元声明
  - 定义类A的成员函数f，此时它才可以使用类B的成员

#### 友元与重载函数

- 假如类想要让一组重载函数成为自己的友元，则必须**对其中的每个函数分别声明**

#### 友元声明与作用域

- 类和非成员函数的声明不一定在它们的友元声明之前
- 因此，我们在调用友元函数前需要确保它已经被声明
- 即使友元函数的定义连同友元声明，出现在了类的内部，它也需要在声明后才能使用

```c++
struct X {
    friend void f() { /* 友元函数定义在类的内部*/ }
    X() { f(); }	// 非法, 友元函数并未声明
    void g();
    void h();
};
void X::g() { return f(); }	// 非法, 友元函数并未声明
void f();			// 这是函数f第一次被声明
void X::h() { return f(); }	// 合法, 该友元函数已经被声明
```

#### 关键在于，友元声明的作用只改变访问权限，它无法取代普通意义上的声明



## 7.4 类的作用域

### 作用域和定义在类外部的成员

- 一个类就是一个作用域，因此定义在类外部的成员函数，必须通过`类名::函数名`的形式定义
- **一旦遇到类名，定义的剩余部分（函数形参列表、函数体）就位于类作用域之内了**，可以直接使用类的其他成员，无需再次通过作用域运算符取得

- 特别地，返回类型出现在类名前，因此**如果返回类型是类成员，需要通过作用域运算符取得授权**

### 名字查找与类的作用域

#### 类的定义分两步处理

- 先编译成员的声明
- 直到类全部可见后，才编译函数体
- 因此，成员函数体可以使用类中声明或定义的任何名字，不管声明或定义的次序

#### 类型名的特殊之处

- 一般地，假如内层作用域使用了外层作用域的名字，该名字仍可以在内层作用域中重新定义
- 在**类中**，假如**使用了外层作用域中的某个类型名，则不能重新定义该名字**
- 最好在类的开始处，进行类型名的定义

### 成员定义中的普通块作用域的名字查找

- 成员函数中使用的名字按以下方式解析
  - 首先，在**成员函数内**查找该名字的声明，只查找该名字使用前的部分
  - 然后，在**类内**继续查找，所有成员都将考虑
  - 最后，在**成员函数定义之前的作用域内**继续查找

## 7.5 构造函数深入

### 初始化与赋值的区别

- 考虑以下构造函数

  ```c++
  class A {
      A (const string &s, unsigned cnt, double price): bookno(s), units_soldj(cnt), revenue(price*cnt) {}
  }
  ```

- 该构造函数使用了构造函数的初始值列表为数据成员初始化，考虑以下构造函数，在构造函数将初始值赋给了各个数据成员，两者看似拥有一样的效果

  ```c++
  class A {
    A (const string &s, unsigned cnt, double price) {
        bookno = s;
        units_sold = cnt;
        revenue = price * cnt;
    }   
  };
  ```

- 但实则是有区别的，对于**const成员、引用类型和未提供默认构造函数的类成员**，必须通过构造函数初始值列表对其初始化，而非赋值。如下例所示

  ```c++
  class A {
      public:
          A (int i) {
  			cnt = i;		// 非法, cnt是const int, 无法对其赋值
          }
      private:
      	const int cnt;
  };
  ```

### 成员初始化的顺序

- 构造函数初始值列表只说明用于初始化成员的值，不限定初始化的具体执行顺序
- **成员的初始化顺序与它们在类中定义的顺序一致**
- 因此，尽量**避免使用某些成员初始化其他成员**

### 构造函数的默认实参

- 假如一个构造函数**为所有数据成员都提供了默认实参**，那么它实际上定义了**默认构造函数**

### 委托构造函数

- C++11允许我们定义**委托构造函数**，它使用其所属类的其他构造函数执行自己的初始化过程

- 成员初始值列表只有一个唯一入口，就是**类名本身，紧跟圆括号括起的参数列表**，该列表必须与类中另外一个构造函数匹配

  ```c++
  X(int i, double j): v1(i), v2(j) {}
  X(): X(0, 0) {}			// 委托给第一个构造函数
  X(int i): X(i, 0) {}	// 委托给第一个构造函数
  ```

- 委托构造函数初始化时，**被委托的构造函数的初始值列表和函数体依次被执行**

### 默认构造函数的作用

- 当对象被默认初始化或值初始化时，自动执行默认构造函数
- 默认初始化发生的场景
  - 块作用域内，不使用任何初始值定义一个非静态变量，或数组时
  - 当一个类含有类类型成员，且使用了合成的默认构造函数时
  - 类类型的成员没有在构造函数初始值列表中显式地初始化时
- 值初始化发生的场景
  - 数组初始化时，提供的初始值数量少于数组大小
  - 不使用初始值定义一个局部静态变量时
  - 通过形如`T()`表达式显式地请求值初始化时，其中T是类型名

### 隐式的类类型转换

- 如果**构造函数只接受一个实参**，则它实际上定义了转换为此类类型的隐式转换机制，这种构造函数可称为**转换构造函数**

- 如Sales_data类有接受一个string的构造函数，则**在需要使用Sales_data的地方可以通过一个string替代**

  ```c++
  string book = "123-145-1839";
  item.combine(book);
  ```

  - item是一个Sales_data对象, 其combine函数应该接受一个Sales_data对象, 此处传入string也能成功调用

#### 编译器做的事

- 此处编译器用给定的string自动创建了一个`Sales_data`对象，这个临时的`Sales_data`对象被传递给`combine`

#### 只允许一步类类型转换

- 编译器**只会自动地执行一步类型转换**，假如我们想用一个字符串字面值代替Sales_data对象，那么编译器要先将其转换为string对象，再转为Sales_data对象，这是编译器无法完成的，因此会错误

#### 类类型转换并非总是有效的

#### 抑制隐式的类类型转换

- 这种类类型转换可能并非我们想要的，想要阻止编译器的自动转换，可以**通过在构造函数声明时加上`explicit`加以阻止**
- `explicit`**只对接受一个实参的构造函数有效**
- 只需在类内部声明构造函数时指定`explicit`，**在内外定义时无需指定**

#### explicit构造函数只能用于直接初始化，不能拷贝初始化

- 当我们执行拷贝初始化时（使用`=`），也会发生隐式转换
- 当构造函数被指定为explicit时，将无法使用拷贝初始化，只能直接初始化

#### static_cast可以使用explicit构造函数

- 尽管explicit阻止了编译器的隐式转换，当可以通过显式转换的形式进行强制转换

  ```c++
  string book = "123-145-1839";
  item.combine(static_cast<Sales_data>(book));
  ```

- 此外，还可通过该构造函数创建一个临时对象

  ```c++
  string book = "123-145-1839";
  item.combine(Sales_data(book));
  ```

### 标准库中含有explicit构造函数的类

- 接受一个单参数的`const char*`的string构造函数不是explicit的
- 接受一个单参数的vector构造函数是explicit的
- 原因是，一般地，我们可以用字符串字面值代替string，这种隐式转换是合理的；但是，我们不能用一个整数代替vector，因此单参数的vector构造函数是explicit的

### 聚合类

- **聚合类**的条件
  - **所有成员都是public的**
  - **没有定义任何构造函数**
  - **没有类内初始值**
  - **没有基类，没有virtual函数**
- 聚合类使得用户可以直接访问其成员，并且具有特殊的初始化语法形式
- 聚合类的初始化
  - 使用**列表初始化**，初始值的顺序必须与声明的顺序一致
  - 如果列表的元素个数少于类的成员变量，则靠后的成员变量被**值初始化**

### 字面值常量类（skip）

## 7.6 类的静态成员

### 静态成员

- 当我们需要成员与类本身直接相关，而不是与类的各个对象关联时，需要使用类的静态成员
- **类的静态成员存在于任何对象之外**，类的对象不包含任何与静态数据成员有关的数据

### 声明静态成员

- 成员声明前加上`static`关键字
- 静态成员可以是public或private的，可以是常量、引用、指针、类类型等
- **类的静态数据成员只有一个，被所有该类的对象共享**
- **类的静态成员函数**不与任何对象绑定在一起，**不含有this指针，也不能声明成const的**

### 使用静态成员

- 可使用**作用域运算符**直接访问静态成员

  ```c++
  double r = Account::rate();		// rate()是Account类的静态成员函数
  ```

- 虽然静态成员不属于任何一个对象，但仍**可以通过类的对象、引用或指针访问静态成员** 

  ```c++
  Account ac1;
  r = ac1.rate();		// 通过Account类的对象访问静态成员
  ```

- **类的成员函数**不需要使用作用域运算符，**可直接访问静态成员**

### 定义静态成员

- 既可以在类的内部、也可以在外部定义静态成员函数，在外部定义时，**不能重复static关键字**，它只出现在类内的成员函数声明
- **一般地，在类的外部定义并初始化每个静态成员**

### 静态成员的类内初始化

- 应该在类外定义并初始化静态成员。但也可以**在类内声明静态成员时，提供类内初始值**，要求初始值必须是**字面值常量类型的`constexpr`**
- 如果提供了类内初始值，那么在类外定义该静态成员时不能再指定一个初始值了
- **即使提供了类内初始值，最好也在类外定义该初始值**

### 静态成员和普通成员的区别

- 静态成员可以是不完全类型的，特别地，**静态成员可以是它所属的类类型的**。而普通成员不能时它所属的类类型的
- 我们**可以使用静态成员作为默认实参**，而不能使用普通成员作为默认实参

## 习题

- 定义类A和类B，其中函数f是B的成员，是A的友元

  ```c++
  class B {
    public:
      void f();
  };
  
  class A {
      friend void B::f();
      private:
     		int i = 10;
  }
  
  void B::f() {
      A a;
      cout << a.i << endl;
  }
  ```

  - 先定义类B，声明f但不定义它
  - 然后定义类A，友元声明
  - 最后在类B外定义成员f，可以使用类A的private和public成员

- 说明以下代码的`Type`和`initVal`分别使用了哪个定义，代码存在错误吗?

  ```c++
  typedef string Type;
  Type initVal();
  class Exercise {
      public:
      	typedef double Type;
      	Type setVal(Type);
      	Type initVal();
      private:
      	int val;
  };
  // 这里返回类型的Type指string, 形参的Type指double
  // 应该将返回类型修改为Exercise::Type
  Type Exercise::setVal(Type parm) {
      val = parm + initVal();
      return val;
  }
  ```

- 为什么接受单参数的string构造函数不是explicit的，而接受单参数的vector构造函数是explicit的

