---
title: OS-进程管理
date: 2022-02-25 22:40:13
tags: 
    - OS
    - 面试
mathjax: true
categories: OS
---

**OS进程管理章节总结**

<!--more-->

# 第二章 进程管理

## 2.1 进程与线程

### 进程的概念

- 进程是**资源分配**的基本单位
- 进程实体由**程序段**、**数据段**和**PCB**三部分构成
- **进程控制块** (Process Control Block, **PCB**) 描述进程的基本信息和运行状态，所谓的**创建**进程和**撤销**进程，实则是指创建进程的PCB、撤销进程的PCB

### 进程状态的切换

- 进程状态包括：**创建**态、**就绪**态、**运行**态、**阻塞**态、**结束**态
- **就绪**态，进程已获得除了处理机以外的一切资源，等待被调度，通常以**就绪队列**的结构组织就绪态的进程
- **运行**态，进程正在处理机上运行
- **阻塞**态，进程正等待某一事件而暂停运行，如等待资源可用，或等待I/O事件
- **创建**态，申请空白的PCB，初始化，为进程**分配所需资源**，然后转入就绪态
- **结束**态，进程结束运行，进入结束态，完成**资源释放和回收**工作
- 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过**调度算法**从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度
- 阻塞状态是**缺少需要的资源**从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态

### 进程控制

- 进程**创建**，父进程创建子进程，为子进程**分配PID**，子进程**继承**父进程的所有**资源**
- 进程**终止**，正常结束/异常结束/外界干预，**终止该进程及所有子孙进程**执行，将所有**资源归还**给父进程或操作系统
- 进程**阻塞**，处于运行态的进程主动阻塞，进程PCB插入**相应事件的等待队列**
- 进程**唤醒**，某个事件（如某资源释放）发生时，相关进程 （释放该资源的进程）**唤醒等待该事件的进程**
- 进程**切换**，CPU从一个进程的运行转到另一个进程的运行
  - **保存旧进程的context**，包括**PC**和**其他寄存器**
  - 更新旧进程的PCB信息
  - 将旧进程的PCB放入相应队列，如就绪队列
  - 选择新进程执行，更新其PCB
  - 更新内存管理的数据结构
  - 恢复处理机context

> xv6中的**进程切换**
>
> - 从user进入kernel模式，从旧进程进入到其内核中的kernel thread
> - context switch，从旧进程的kernel thread切换到当前CPU的scheduler thread
> - context switch，从CPU的scheduler thread切换到新进程的kernel thread
> - trap return，返回user mode，运行新进程
>
> context switch时的操作
>
> - 保存旧线程的寄存器（包括pc、stack pointer等）
> - 恢复新线程之前保存的寄存器值
> - 由于stack pointer和pc都会被保存或恢复，因此线程切换时CPU会切换stack及所执行的代码

### 进程通信

- PV操作
- 共享存储：进程之间存在一块可直接访问的共享空间，通过对这片共享空间的读写操作实现进程之间的信息交换
- 消息传递
- 管道通信：管道指**一个读进程、一个写进程**及实现它们之间通信的一个**共享文件**。写进程以**字符流**形式将数据**写入**管道，读进程则从管道**读出**数据，管道是**半双工通信**
- Linux中的管道：
  - 管道是一个固定大小的缓冲区，大小为4KB
  - 当管道满了后，写进程调用`write()`将被阻塞，当管道空了，读进程调用`read()`将被**阻塞**

### 线程的概念

- 线程
  - 线程是**独立调度**的基本单位
  - **一个进程**可以有**多个线程**，它们**共享进程资源**
- 进程与线程的区别
  - 进程是**资源分配**的基本单位，但是**线程不拥有资源**，线程可以访问隶属进程的资源
  - 线程是**独立调度**的基本单位，在同一进程中，**线程的切换不会引起进程切换**，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换
  - 由于**创建或撤销进程时**，系统都要为之**分配或回收资源**，如内存空间、I/O 设备等，所付出的开销**远大于创建或撤销线程时的开销**。类似地，在进行**进程切换**时，涉及当前执行**进程 CPU 环境的保存**及**新调度进程 CPU 环境的设置**，而**线程切换**时只需**保存和设置少量寄存器内容**，开销很小
  - **线程**间可以通过直接**读写同一进程中的数据**进行通信，但是进程通信需要借助 **进程间通信技术（IPC）**

- 线程的实现方式
  - **用户级**线程
  - **内核级**线程
  - **组合方式**实现多线程，线程创建在用户空间中完成，线程调度和同步也在应用程序进行，**多个用户级线程**被映射到**一些内核级线程**上
    - 多对一模型，一个线程使用内核服务被阻塞时整个进程都会被阻塞
    - 一对一模型，创建线程的开销较大
    - 多对多模型，n个用户级线程映射到m个内核级线程，一般$m \leq n$

## 2.2 进程调度算法

### 进程调度的层次

- 调度的三个层次：作业调度、中级调度、进程调度
- **作业调度**，**内存**与**辅存**之间的调度，按一定原则从外存上选择处于后备状态的作业，给它们分配内存、I/O设备等资源，并建立相应进程
- **中级调度**，又称内存调度，将暂时不能运行的进程调出外存等待，此时进程状态为挂起态，当它们具备运行条件时再将其重新调入内存，挂在就绪队列上等待
- **进程调度**，按一定方法和策略，从**就绪队列**上选取一个进程，分配**CPU时间**

### 进程调度的方式

- **非剥夺**调度方式，当进程在CPU上运行时，优先级更高的进程到来，**仍然让该进程继续运行**直到时间片结束或阻塞
- **剥夺**调度方式，当进程在CPU上运行时，优先级更高的进程到来，**立刻暂停正在执行的进程**，将CPU分配给优先级更高的进程

### 调度算法

#### 批处理系统

- **先来先服务（FCFS）**，短作业不利
- **短作业优先（SJF）**，长作业不利（饥饿）
- **最短剩余时间优先（SRTN）**，最短作业优先的剥夺调度版本

#### 交互时系统

- **时间片轮转调度**，按FCFS原则将就绪进程排成队列，每次调度时将CPU时间片分配给队首进程，执行一个时间片后该进程暂停执行并回到队尾，**合适的时间片选取**是关键
- **优先级调度**，优先级高的先执行，一般来说按以下原则设置优先级
  - 系统进程 > 用户进程
  - 交互进程 > 非交互进程
  - I/O型进程 > 计算型进程
  - 随着等待时间增加，提高进程的优先级，防止”饥饿“

> - **饥饿**，在一定进程调度算法的作用下，进程长期分配不到CPU时间的现象

- **多级反馈队列**
  - 设置**多个就绪队列**，赋予**不同的优先级和时间片**，**第1级**队列**优先级最高、时间片最小**，**最后一级**队列**优先级最低、时间片最长**
  - 仅当**第1-i级队列都为空**时，才**调度第i+1级队列**中的进程
  - 每级队列按**时间片轮转调度**
  - **新进程加入第1级队列的队尾**，当进程在**第i级队列被调度后**，**加入第i+1级队列**的队尾
  - **剥夺式**优先级调度，如果运行第i级队列的进程时，有新进程加入就绪队列，它将位于优先级更高的第1级队列，此时立刻暂停当前进程执行，将CPU分配给新进程
  - 综合了**时间片轮转调度**和**优先级调度**算法

## 2.3 进程同步

### 基本概念

- 一次仅允许一个进程使用的资源为**临界资源**
- **访问**临界资源的那段**代码**称为**临界区**
- 对临界资源的访问过程分为4部分
  - **进入区**，**检查**是否可以进入临界区，若可以则**设置**访问标志
  - **临界区**，访问临界资源的代码
  - **退出区**，**清除**访问标志
  - **剩余区**，其余部分
- **同步**：多个进程因为**合作**产生的**直接制约关系**，使得进程有一定的**先后执行关系**
- **互斥**：多个进程在**同一时刻只有一个进程能进入临界区**

### 实现临界区互斥的基本方法

#### 硬件实现方法

- **中断屏蔽**方法：关中断、临界区、开中断

- **Test-And-Set**，读出指定标志后将其设置为真，原子操作

  ```c++
  while TestAndSet(&lock);
  // 临界区
  lock = false;
  ```

  - 读出lock的值，并将lock设置为true
  - 假如临界资源**被占有**，则lock原来的值为true，因此`TestAndSet`**对lock其无影响**，且返回值为true，因此**继续循环**
  - 假如临界资源**不被占有**，则lock原来的值为false，因此`TestAndSet`**将lock置为true**，同时返回值为false，跳出while循环并**进入临界区**

- **Swap**，交换两个字节的内容，原子操作

  ```c++
  bool key = true;
  while (key)
      swap(&key, &lock);
  // 临界区
  lock = false;
  ```

  - 效果与Test-And-Set类似

#### 信号量

- **信号量（Semaphore）**是一个整型变量，**P操作和V操作**
- **P操作**：如果信号量大于0 ，将其减1；如果信号量等于0，**进程睡眠**，等待信号量大于0
- **V操作**：将信号量加1，**唤醒睡眠的进程**，让其完成P操作
- P和V操作需要被设计成**原语，不可分割**，通常的做法是在执行这些操作的时候**屏蔽中断**
- 如果信号量的取值**只能为0或者1**，那么就成为了**互斥量（Mutex）** ，0表示临界区已经加锁，1表示临界区解锁

- 信号量实现**互斥**：将信号量作为互斥量，设置**临界区**在**P操作和V操作之间**

  ```c++
  Semaphore mutex = 1;
  P(mutex);
  // 临界区
  V(mutex);
  ```

- 信号量实现**同步**：两个进程的执行必须保证先后关系，为**每对先后关系**设置**一个信号量**

  - 每个前操作后执行`V(S)`
  - 每个后操作后执行`P(S)`

### 管程

- 利用**共享数据结构**表示系统的**共享资源**，以及由对该共享数据结构**实施操作的一组过程**所组成的**资源管理程序**，称为**管程**
- 管程保证了**进程互斥**，即每次仅允许一个进程进入管程
- **条件变量**，管程需要阻塞时，将**阻塞原因**定义为条件变量
  - `x.wait`，`x`对应的条件不满足时，调用管程的进程通过`x.wait`将自己插入`x`条件的等待队列中，并释放管程，此时其他进程可以使用该管程
  - `x.signal`，`x`对应的条件发生变化，调用`x.signal`，唤醒一个`x`的等待队列中的进程

## 2.4 经典同步问题

### 生产者-消费者问题

- **问题描述**：使用一个**缓冲区**来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品

- **信号量**设置：一个**互斥量**`mutex`用于控制**对缓冲区的互斥访问**，**信号量**`empty`表示**生产者可用的资源**，**信号量**`full`表示**消费者可用的资源**

  ```c++
  semaphore mutex = 1;
  semaphore empty = n;
  semaphore full = 0;
  ```

- **生产者模型**

  ```c++
  while (1) {
      P(empty);
      P(mutex);
      // 写入数据
      V(mutex);
      V(full);
  }
  ```

- **消费者模型**

  ```c++
  while (1) {
      P(full);
      P(mutex);
      // 读取数据
      V(mutex);
      V(empty);
  }
  ```

- 不能先对`mutex`进行P操作，再对`empty`或`full`进行P操作。原因是如果缓存区已满，而生产者对`mutex`进行了P操作，再对`empty`进行P操作的时候会阻塞。此时，如果有消费者想读出数据，它对`mutex`进行P操作时也会阻塞，因而导致了**死锁**



### 读者-写者问题

- 问题描述：一组读者进程和一组写者进程共享一个文件，两个或以上读进程可同时访问，写进程不能与其他任何进程同时访问

- 信号量设置：对文件资源的读写互斥访问设置一个互斥量`rw`，对**读进程数量**设置**计数器**`counter`，读进程访问计数器是互斥的，设置互斥量`mutex`。读进程进入临界区和退出临界区都要更新计数器，特别地，进入时如果计数器为0，则该读进程需要确保读写互斥，因此对`rw`执行P操作；退出临界区时如果计数器为0，则需要释放读写互斥量，因此对`rw`执行V操作

- 读者模型

  ```c++
  P(mutex);
  if (counter == 0)
      P(rw);
  ++counter;
  V(mutex);
  // read
  P(mutex);
  --counter;
  if (counter == 0)
      V(rw);
  V(mutex);
  ```

- 写者模型

  ```c++
  P(rw);
  // write
  V(rw);
  ```

- 上述程序，可能导致**写进程的饥饿问题**，因为只要有一个读进程在读，随后而来的读进程都会被允许访问，而写进程则会被阻塞

### 哲学家进餐问题

- 方法一：至多允许4名哲学家同时进餐
- 方法二：奇数哲学家先拿左边、再拿右边；偶数哲学家反之

- 实现，利用C++的`mutex`类、`unique_lock`类和`condition_variable`类实现**信号量**

  ```c++
  class Semaphore {
  public:
  	Semaphore(int c = 1): _cnt(c) {}
      
      void set(int c) { _cnt = c; }
      
      void signal() {
          unique_lock<mutex> lock(_mtx);
          ++_cnt;
          _cv.notify_one();
      }
      
      void  () {
          unique_lock<mutex> lock(_mtx);
          while (_cnt <= 0)
              _cv.wait(lock);
          --cnt;
      }
  private:
      int _cnt;
      mutex _mtx;
      condition_variable _cv;
  };
  ```



## 2.5 死锁

### 四个必要条件

- **互斥**：每个资源要么已经分配给了一个进程，要么就是可用的
- **占有和等待**：已经得到了某个资源的进程可以再请求新的资源，如果该资源被其他进程占有，则请求进程被阻塞，但对自己已获得的资源保持不放
- **不可抢占**：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放
- **环路等待**：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源

### 死锁的处理方法

- **鸵鸟策略**，忽略它
- **死锁检测**与**死锁恢复**
- **死锁预防**
- **死锁避免**

### 死锁预防

- 死锁预防：在程序运行**之前预防**发生死锁，从死锁的四个必要条件入手

- **破坏互斥条件**，例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程

- **破坏占有和等待条件**，一种实现方式是规定所有进程在**开始执行前请求所需要的全部资源**

- **破坏不可抢占条件**

- **破坏环路等待**，给资源统一编号，进程只能**按编号顺序**来请求资源。

### 死锁检测与死锁恢复

- 死锁**检测**：若**资源分配图**能够**完全简化**，则**不会发生死锁**

- 死锁**恢复**
  - 利用**抢占**恢复，挂起某些进程，抢占其资源并分配给其他进程
  - 利用**回滚**恢复，让一或多个进程回退到足以避免死锁的地步，要求系统保持进程的历史信息并设置还原点
  - 通过**杀死进程**恢复，撤销（部分或全部）死锁进程，回收其资源，撤销的原则可按**进程优先级**、撤销进程**代价**等进行

### 死锁避免——银行家算法

- 数据结构：**可利用资源向量Available**、**最大需求矩阵Max**、**分配矩阵Allocation**、**需求矩阵Need**
- 算法描述
  - 首先根据Max和Allocation计算**Need矩阵**
  - 收到进程P的**请求向量Request**时，首先检查Request中的元素是否小于等于Need矩阵中对应元素，若否则进程请求的资源超出了其声称的最大值，拒绝该请求
  - 若没超过，则**尝试**把资源分配给进程P，更新Allocation、Available、Need矩阵
  - 执行**安全性算法**，若通过检查则进行分配，否则拒绝该请求，并让进程P等待
- 安全性算法
  - 对于给定的Max、Allocation和Available，若存在一种**安全序列**可以让**所有进程都执行完成**，则系统处于**安全状态**，否则处于不安全状态

## 2.6 补充: 锁

- 如果系统调用并行地运行在多个CPU上，则可能并行地访问内核中共享的数据结构，为了确保数据的一致性，需要使用锁来协调对于共享数据的更新

- 当一份共享数据同时被读写，而没有锁的保护，则可能出现race condition

- 锁的使用

  `acquire`，获取锁，确保任何时间只有一个进程能够成功获取锁

  `release`，释放所持有的lock

- 死锁的预防，如果需要获取多个锁，则对锁进行排序，所有操作都必须**按相同的顺序**获取这些锁（打破死锁的**环路等待**条件）

- 锁限制了并发性，限制了性能。为了更好的性能，可以对数据结构和锁进行拆分，但者会带来较大工作量

### 自旋锁spinlock的实现

- 使用特殊的**硬件指令**，保证一次test-and-set操作的**原子性**，xv6中，`amoswap`接收3个参数，分别是**address、寄存器r1和寄存器r2**，指令先锁住address，将address中的数据保存在临时变量中，然后将r1的数据写入address中，再将临时变量的数据写入r2中，然后对地址解锁

- 指令`while(__sync_lock_test_and_set(&locked, 1) != 0)`，会将1写入`locked`，并且读出`locked`原来的值

  - 若原来的值为1说明该锁被占有，因此写入1无影响，继续执行while循环（因此称为**自旋锁**）

  - 若原来的值为0说明该锁未被占有，因此写入1**获取该锁**，并退出while循环继续执行下面的代码

### sleep locks

- 自旋锁的缺点

  - 有的进程会长期持有锁，如果其他进程一直自旋会**浪费CPU资源**
  - 持有自旋锁的进程**不能让出CPU**，否则调度至另一进程，它想获取该锁将会一直自旋，从而导致死锁

- 需要一种锁，在锁被持有时允许让出CPU和允许中断，这就是sleep locks

  - **不能在interrupt handler中使用睡眠锁**，因为它允许中断
  - **不能在spinlock的临界区使用sleep lock**，因为sleep lock可能让出CP

  > **解释**
  >
  > - interrupt handler和临界区都具有原子性，它们不会让出CPU。假如进程A获取了sleep lock，而由于sleeplock允许中断，当中断发生并进入interrupt handler时执行到获取sleep lock的指令时将阻塞， 而由于中断处理程序不会让出CPU，因此它会一直阻塞，进程A也不可能获得CPU而释放sleep lock，导致死锁
  > - 同样地，临界区也具有原子性。假如进程A获取了sleep lock，此后进程调度使得A让出CPU，执行进程B，进程B在其临界区获取该sleep lock，且不让出CPU，从而A也无法执行以释放该sleep lock，导致死锁

- spinlock适合较短的临界区，而sleeplock适用于长时间的操作
